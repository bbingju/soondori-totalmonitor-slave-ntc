###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         06/Sep/2019  23:26:45
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c
#    Command line =
#        -f C:\Users\ilkorea\AppData\Local\Temp\EW7E9E.tmp
#        (D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c
#        -D USE_HAL_DRIVER -D STM32F103xB -lc
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\List
#        -o
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Inc\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/SEGGER\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/FreeRTOSV9\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/FreeRTOSV9/Config\
#        -On -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\List\stm32f1xx_hal_adc.lst
#    Object file  =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\Obj\stm32f1xx_hal_adc.o
#
###############################################################################

D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_adc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_adc.c
      4            * @author  MCD Application Team
      5            * @brief   This file provides firmware functions to manage the following 
      6            *          functionalities of the Analog to Digital Convertor (ADC)
      7            *          peripheral:
      8            *           + Initialization and de-initialization functions
      9            *             ++ Initialization and Configuration of ADC
     10            *           + Operation functions
     11            *             ++ Start, stop, get result of conversions of regular
     12            *                group, using 3 possible modes: polling, interruption or DMA.
     13            *           + Control functions
     14            *             ++ Channels configuration on regular group
     15            *             ++ Channels configuration on injected group
     16            *             ++ Analog Watchdog configuration
     17            *           + State functions
     18            *             ++ ADC state machine management
     19            *             ++ Interrupts and flags management
     20            *          Other functions (extended functions) are available in file 
     21            *          "stm32f1xx_hal_adc_ex.c".
     22            *
     23            @verbatim
     24            ==============================================================================
     25                               ##### ADC peripheral features #####
     26            ==============================================================================
     27            [..]
     28            (+) 12-bit resolution
     29          
     30            (+) Interrupt generation at the end of regular conversion, end of injected
     31                conversion, and in case of analog watchdog or overrun events.
     32            
     33            (+) Single and continuous conversion modes.
     34            
     35            (+) Scan mode for conversion of several channels sequentially.
     36            
     37            (+) Data alignment with in-built data coherency.
     38            
     39            (+) Programmable sampling time (channel wise)
     40            
     41            (+) ADC conversion of regular group and injected group.
     42          
     43            (+) External trigger (timer or EXTI) 
     44                for both regular and injected groups.
     45          
     46            (+) DMA request generation for transfer of conversions data of regular group.
     47          
     48            (+) Multimode Dual mode (available on devices with 2 ADCs or more).
     49            
     50            (+) Configurable DMA data storage in Multimode Dual mode (available on devices
     51                with 2 DCs or more).
     52            
     53            (+) Configurable delay between conversions in Dual interleaved mode (available 
     54                on devices with 2 DCs or more).
     55            
     56            (+) ADC calibration
     57          
     58            (+) ADC supply requirements: 2.4 V to 3.6 V at full speed and down to 1.8 V at 
     59                slower speed.
     60            
     61            (+) ADC input range: from Vref- (connected to Vssa) to Vref+ (connected to 
     62                Vdda or to an external voltage reference).
     63          
     64          
     65                               ##### How to use this driver #####
     66            ==============================================================================
     67              [..]
     68          
     69               *** Configuration of top level parameters related to ADC ***
     70               ============================================================
     71               [..]
     72          
     73              (#) Enable the ADC interface
     74                (++) As prerequisite, ADC clock must be configured at RCC top level.
     75                     Caution: On STM32F1, ADC clock frequency max is 14MHz (refer
     76                              to device datasheet).
     77                              Therefore, ADC clock prescaler must be configured in 
     78                              function of ADC clock source frequency to remain below
     79                              this maximum frequency.
     80                  (++) One clock setting is mandatory:
     81                       ADC clock (core clock, also possibly conversion clock).
     82                       (+++) Example:
     83                             Into HAL_ADC_MspInit() (recommended code location) or with
     84                             other device clock parameters configuration:
     85                         (+++) RCC_PeriphCLKInitTypeDef  PeriphClkInit;
     86                         (+++) __ADC1_CLK_ENABLE();
     87                         (+++) PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
     88                         (+++) PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;
     89                         (+++) HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);
     90          
     91              (#) ADC pins configuration
     92                   (++) Enable the clock for the ADC GPIOs
     93                        using macro __HAL_RCC_GPIOx_CLK_ENABLE()
     94                   (++) Configure these ADC pins in analog mode
     95                        using function HAL_GPIO_Init()
     96          
     97              (#) Optionally, in case of usage of ADC with interruptions:
     98                   (++) Configure the NVIC for ADC
     99                        using function HAL_NVIC_EnableIRQ(ADCx_IRQn)
    100                   (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
    101                        into the function of corresponding ADC interruption vector 
    102                        ADCx_IRQHandler().
    103          
    104              (#) Optionally, in case of usage of DMA:
    105                   (++) Configure the DMA (DMA channel, mode normal or circular, ...)
    106                        using function HAL_DMA_Init().
    107                   (++) Configure the NVIC for DMA
    108                        using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)
    109                   (++) Insert the ADC interruption handler function HAL_ADC_IRQHandler() 
    110                        into the function of corresponding DMA interruption vector 
    111                        DMAx_Channelx_IRQHandler().
    112          
    113               *** Configuration of ADC, groups regular/injected, channels parameters ***
    114               ==========================================================================
    115               [..]
    116          
    117              (#) Configure the ADC parameters (resolution, data alignment, ...)
    118                  and regular group parameters (conversion trigger, sequencer, ...)
    119                  using function HAL_ADC_Init().
    120          
    121              (#) Configure the channels for regular group parameters (channel number, 
    122                  channel rank into sequencer, ..., into regular group)
    123                  using function HAL_ADC_ConfigChannel().
    124          
    125              (#) Optionally, configure the injected group parameters (conversion trigger, 
    126                  sequencer, ..., of injected group)
    127                  and the channels for injected group parameters (channel number, 
    128                  channel rank into sequencer, ..., into injected group)
    129                  using function HAL_ADCEx_InjectedConfigChannel().
    130          
    131              (#) Optionally, configure the analog watchdog parameters (channels
    132                  monitored, thresholds, ...)
    133                  using function HAL_ADC_AnalogWDGConfig().
    134          
    135              (#) Optionally, for devices with several ADC instances: configure the 
    136                  multimode parameters
    137                  using function HAL_ADCEx_MultiModeConfigChannel().
    138          
    139               *** Execution of ADC conversions ***
    140               ====================================
    141               [..]
    142          
    143              (#) Optionally, perform an automatic ADC calibration to improve the
    144                  conversion accuracy
    145                  using function HAL_ADCEx_Calibration_Start().
    146          
    147              (#) ADC driver can be used among three modes: polling, interruption,
    148                  transfer by DMA.
    149          
    150                  (++) ADC conversion by polling:
    151                    (+++) Activate the ADC peripheral and start conversions
    152                          using function HAL_ADC_Start()
    153                    (+++) Wait for ADC conversion completion 
    154                          using function HAL_ADC_PollForConversion()
    155                          (or for injected group: HAL_ADCEx_InjectedPollForConversion() )
    156                    (+++) Retrieve conversion results 
    157                          using function HAL_ADC_GetValue()
    158                          (or for injected group: HAL_ADCEx_InjectedGetValue() )
    159                    (+++) Stop conversion and disable the ADC peripheral 
    160                          using function HAL_ADC_Stop()
    161          
    162                  (++) ADC conversion by interruption: 
    163                    (+++) Activate the ADC peripheral and start conversions
    164                          using function HAL_ADC_Start_IT()
    165                    (+++) Wait for ADC conversion completion by call of function
    166                          HAL_ADC_ConvCpltCallback()
    167                          (this function must be implemented in user program)
    168                          (or for injected group: HAL_ADCEx_InjectedConvCpltCallback() )
    169                    (+++) Retrieve conversion results 
    170                          using function HAL_ADC_GetValue()
    171                          (or for injected group: HAL_ADCEx_InjectedGetValue() )
    172                    (+++) Stop conversion and disable the ADC peripheral 
    173                          using function HAL_ADC_Stop_IT()
    174          
    175                  (++) ADC conversion with transfer by DMA:
    176                    (+++) Activate the ADC peripheral and start conversions
    177                          using function HAL_ADC_Start_DMA()
    178                    (+++) Wait for ADC conversion completion by call of function
    179                          HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
    180                          (these functions must be implemented in user program)
    181                    (+++) Conversion results are automatically transferred by DMA into
    182                          destination variable address.
    183                    (+++) Stop conversion and disable the ADC peripheral 
    184                          using function HAL_ADC_Stop_DMA()
    185          
    186                  (++) For devices with several ADCs: ADC multimode conversion 
    187                       with transfer by DMA:
    188                    (+++) Activate the ADC peripheral (slave) and start conversions
    189                          using function HAL_ADC_Start()
    190                    (+++) Activate the ADC peripheral (master) and start conversions
    191                          using function HAL_ADCEx_MultiModeStart_DMA()
    192                    (+++) Wait for ADC conversion completion by call of function
    193                          HAL_ADC_ConvCpltCallback() or HAL_ADC_ConvHalfCpltCallback()
    194                          (these functions must be implemented in user program)
    195                    (+++) Conversion results are automatically transferred by DMA into
    196                          destination variable address.
    197                    (+++) Stop conversion and disable the ADC peripheral (master)
    198                          using function HAL_ADCEx_MultiModeStop_DMA()
    199                    (+++) Stop conversion and disable the ADC peripheral (slave)
    200                          using function HAL_ADC_Stop_IT()
    201          
    202               [..]
    203          
    204              (@) Callback functions must be implemented in user program:
    205                (+@) HAL_ADC_ErrorCallback()
    206                (+@) HAL_ADC_LevelOutOfWindowCallback() (callback of analog watchdog)
    207                (+@) HAL_ADC_ConvCpltCallback()
    208                (+@) HAL_ADC_ConvHalfCpltCallback
    209                (+@) HAL_ADCEx_InjectedConvCpltCallback()
    210          
    211               *** Deinitialization of ADC ***
    212               ============================================================
    213               [..]
    214          
    215              (#) Disable the ADC interface
    216                (++) ADC clock can be hard reset and disabled at RCC top level.
    217                  (++) Hard reset of ADC peripherals
    218                       using macro __ADCx_FORCE_RESET(), __ADCx_RELEASE_RESET().
    219                  (++) ADC clock disable
    220                       using the equivalent macro/functions as configuration step.
    221                       (+++) Example:
    222                             Into HAL_ADC_MspDeInit() (recommended code location) or with
    223                             other device clock parameters configuration:
    224                         (+++) PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC
    225                         (+++) PeriphClkInit.AdcClockSelection = RCC_ADCPLLCLK2_OFF
    226                         (+++) HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit)
    227          
    228              (#) ADC pins configuration
    229                   (++) Disable the clock for the ADC GPIOs
    230                        using macro __HAL_RCC_GPIOx_CLK_DISABLE()
    231          
    232              (#) Optionally, in case of usage of ADC with interruptions:
    233                   (++) Disable the NVIC for ADC
    234                        using function HAL_NVIC_EnableIRQ(ADCx_IRQn)
    235          
    236              (#) Optionally, in case of usage of DMA:
    237                   (++) Deinitialize the DMA
    238                        using function HAL_DMA_Init().
    239                   (++) Disable the NVIC for DMA
    240                        using function HAL_NVIC_EnableIRQ(DMAx_Channelx_IRQn)
    241          
    242              [..]
    243            
    244              @endverbatim
    245            ******************************************************************************
    246            * @attention
    247            *
    248            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    249            *
    250            * Redistribution and use in source and binary forms, with or without modification,
    251            * are permitted provided that the following conditions are met:
    252            *   1. Redistributions of source code must retain the above copyright notice,
    253            *      this list of conditions and the following disclaimer.
    254            *   2. Redistributions in binary form must reproduce the above copyright notice,
    255            *      this list of conditions and the following disclaimer in the documentation
    256            *      and/or other materials provided with the distribution.
    257            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    258            *      may be used to endorse or promote products derived from this software
    259            *      without specific prior written permission.
    260            *
    261            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    262            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    263            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    264            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    265            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    266            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    267            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    268            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    269            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    270            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    271            *
    272            ******************************************************************************  
    273            */
    274          
    275          /* Includes ------------------------------------------------------------------*/
    276          #include "stm32f1xx_hal.h"
    277          
    278          /** @addtogroup STM32F1xx_HAL_Driver
    279            * @{
    280            */
    281          
    282          /** @defgroup ADC ADC
    283            * @brief ADC HAL module driver
    284            * @{
    285            */
    286          
    287          #ifdef HAL_ADC_MODULE_ENABLED
    288          
    289          /* Private typedef -----------------------------------------------------------*/
    290          /* Private define ------------------------------------------------------------*/
    291          /** @defgroup ADC_Private_Constants ADC Private Constants
    292            * @{
    293            */
    294          
    295            /* Timeout values for ADC enable and disable settling time.                 */
    296            /* Values defined to be higher than worst cases: low clocks freq,           */
    297            /* maximum prescaler.                                                       */
    298            /* Ex of profile low frequency : Clock source at 0.1 MHz, ADC clock         */
    299            /* prescaler 4, sampling time 12.5 ADC clock cycles, resolution 12 bits.    */
    300            /* Unit: ms                                                                 */
    301            #define ADC_ENABLE_TIMEOUT              2U
    302            #define ADC_DISABLE_TIMEOUT             2U
    303          
    304            /* Delay for ADC stabilization time.                                        */
    305            /* Maximum delay is 1us (refer to device datasheet, parameter tSTAB).       */
    306            /* Unit: us                                                                 */
    307            #define ADC_STAB_DELAY_US               1U
    308          
    309            /* Delay for temperature sensor stabilization time.                         */
    310            /* Maximum delay is 10us (refer to device datasheet, parameter tSTART).     */
    311            /* Unit: us                                                                 */
    312            #define ADC_TEMPSENSOR_DELAY_US         10U
    313          
    314          /**
    315            * @}
    316            */
    317          
    318          /* Private macro -------------------------------------------------------------*/
    319          /* Private variables ---------------------------------------------------------*/
    320          /* Private function prototypes -----------------------------------------------*/
    321          /** @defgroup ADC_Private_Functions ADC Private Functions
    322            * @{
    323            */
    324          /**
    325            * @}
    326            */
    327          
    328          /* Exported functions --------------------------------------------------------*/
    329          
    330          /** @defgroup ADC_Exported_Functions ADC Exported Functions
    331            * @{
    332            */
    333          
    334          /** @defgroup ADC_Exported_Functions_Group1 Initialization/de-initialization functions 
    335            * @brief    Initialization and Configuration functions
    336            *
    337          @verbatim    
    338           ===============================================================================
    339                        ##### Initialization and de-initialization functions #####
    340           ===============================================================================
    341              [..]  This section provides functions allowing to:
    342                (+) Initialize and configure the ADC. 
    343                (+) De-initialize the ADC.
    344          
    345          @endverbatim
    346            * @{
    347            */
    348          
    349          /**
    350            * @brief  Initializes the ADC peripheral and regular group according to  
    351            *         parameters specified in structure "ADC_InitTypeDef".
    352            * @note   As prerequisite, ADC clock must be configured at RCC top level
    353            *         (clock source APB2).
    354            *         See commented example code below that can be copied and uncommented 
    355            *         into HAL_ADC_MspInit().
    356            * @note   Possibility to update parameters on the fly:
    357            *         This function initializes the ADC MSP (HAL_ADC_MspInit()) only when
    358            *         coming from ADC state reset. Following calls to this function can
    359            *         be used to reconfigure some parameters of ADC_InitTypeDef  
    360            *         structure on the fly, without modifying MSP configuration. If ADC  
    361            *         MSP has to be modified again, HAL_ADC_DeInit() must be called
    362            *         before HAL_ADC_Init().
    363            *         The setting of these parameters is conditioned to ADC state.
    364            *         For parameters constraints, see comments of structure 
    365            *         "ADC_InitTypeDef".
    366            * @note   This function configures the ADC within 2 scopes: scope of entire 
    367            *         ADC and scope of regular group. For parameters details, see comments 
    368            *         of structure "ADC_InitTypeDef".
    369            * @param  hadc: ADC handle
    370            * @retval HAL status
    371            */
    372          HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
    373          {
    374            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    375            uint32_t tmp_cr1 = 0U;
    376            uint32_t tmp_cr2 = 0U;
    377            uint32_t tmp_sqr1 = 0U;
    378            
    379            /* Check ADC handle */
    380            if(hadc == NULL)
    381            {
    382              return HAL_ERROR;
    383            }
    384            
    385            /* Check the parameters */
    386            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    387            assert_param(IS_ADC_DATA_ALIGN(hadc->Init.DataAlign));
    388            assert_param(IS_ADC_SCAN_MODE(hadc->Init.ScanConvMode));
    389            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
    390            assert_param(IS_ADC_EXTTRIG(hadc->Init.ExternalTrigConv));
    391            
    392            if(hadc->Init.ScanConvMode != ADC_SCAN_DISABLE)
    393            {
    394              assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
    395              assert_param(IS_FUNCTIONAL_STATE(hadc->Init.DiscontinuousConvMode));
    396              if(hadc->Init.DiscontinuousConvMode != DISABLE)
    397              {
    398                assert_param(IS_ADC_REGULAR_DISCONT_NUMBER(hadc->Init.NbrOfDiscConversion));
    399              }
    400            }
    401            
    402            /* As prerequisite, into HAL_ADC_MspInit(), ADC clock must be configured    */
    403            /* at RCC top level.                                                        */
    404            /* Refer to header of this file for more details on clock enabling          */
    405            /* procedure.                                                               */
    406          
    407            /* Actions performed only if ADC is coming from state reset:                */
    408            /* - Initialization of ADC MSP                                              */
    409            if (hadc->State == HAL_ADC_STATE_RESET)
    410            {
    411              /* Initialize ADC error code */
    412              ADC_CLEAR_ERRORCODE(hadc);
    413              
    414              /* Allocate lock resource and initialize it */
    415              hadc->Lock = HAL_UNLOCKED;
    416              
    417              /* Init the low level hardware */
    418              HAL_ADC_MspInit(hadc);
    419            }
    420            
    421            /* Stop potential conversion on going, on regular and injected groups */
    422            /* Disable ADC peripheral */
    423            /* Note: In case of ADC already enabled, precaution to not launch an        */
    424            /*       unwanted conversion while modifying register CR2 by writing 1 to   */
    425            /*       bit ADON.                                                          */
    426            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
    427            
    428            
    429            /* Configuration of ADC parameters if previous preliminary actions are      */ 
    430            /* correctly completed.                                                     */
    431            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL) &&
    432                (tmp_hal_status == HAL_OK)                                  )
    433            {
    434              /* Set ADC state */
    435              ADC_STATE_CLR_SET(hadc->State,
    436                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    437                                HAL_ADC_STATE_BUSY_INTERNAL);
    438              
    439              /* Set ADC parameters */
    440              
    441              /* Configuration of ADC:                                                  */
    442              /*  - data alignment                                                      */
    443              /*  - external trigger to start conversion                                */
    444              /*  - external trigger polarity (always set to 1, because needed for all  */
    445              /*    triggers: external trigger of SW start)                             */
    446              /*  - continuous conversion mode                                          */
    447              /* Note: External trigger polarity (ADC_CR2_EXTTRIG) is set into          */
    448              /*       HAL_ADC_Start_xxx functions because if set in this function,     */
    449              /*       a conversion on injected group would start a conversion also on  */
    450              /*       regular group after ADC enabling.                                */
    451              tmp_cr2 |= (hadc->Init.DataAlign                               |
    452                          ADC_CFGR_EXTSEL(hadc, hadc->Init.ExternalTrigConv) |
    453                          ADC_CR2_CONTINUOUS(hadc->Init.ContinuousConvMode)   );
    454              
    455              /* Configuration of ADC:                                                  */
    456              /*  - scan mode                                                           */
    457              /*  - discontinuous mode disable/enable                                   */
    458              /*  - discontinuous mode number of conversions                            */
    459              tmp_cr1 |= (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode));
    460              
    461              /* Enable discontinuous mode only if continuous mode is disabled */
    462              /* Note: If parameter "Init.ScanConvMode" is set to disable, parameter    */
    463              /*       discontinuous is set anyway, but will have no effect on ADC HW.  */
    464              if (hadc->Init.DiscontinuousConvMode == ENABLE)
    465              {
    466                if (hadc->Init.ContinuousConvMode == DISABLE)
    467                {
    468                  /* Enable the selected ADC regular discontinuous mode */
    469                  /* Set the number of channels to be converted in discontinuous mode */
    470                  SET_BIT(tmp_cr1, ADC_CR1_DISCEN                                            |
    471                                   ADC_CR1_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion)  );
    472                }
    473                else
    474                {
    475                  /* ADC regular group settings continuous and sequencer discontinuous*/
    476                  /* cannot be enabled simultaneously.                                */
    477                  
    478                  /* Update ADC state machine to error */
    479                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    480                  
    481                  /* Set ADC error code to ADC IP internal error */
    482                  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    483                }
    484              }
    485              
    486              /* Update ADC configuration register CR1 with previous settings */
    487                MODIFY_REG(hadc->Instance->CR1,
    488                           ADC_CR1_SCAN    |
    489                           ADC_CR1_DISCEN  |
    490                           ADC_CR1_DISCNUM    ,
    491                           tmp_cr1             );
    492              
    493              /* Update ADC configuration register CR2 with previous settings */
    494                MODIFY_REG(hadc->Instance->CR2,
    495                           ADC_CR2_ALIGN   |
    496                           ADC_CR2_EXTSEL  |
    497                           ADC_CR2_EXTTRIG |
    498                           ADC_CR2_CONT       ,
    499                           tmp_cr2             );
    500          
    501              /* Configuration of regular group sequencer:                              */
    502              /* - if scan mode is disabled, regular channels sequence length is set to */
    503              /*   0x00: 1 channel converted (channel on regular rank 1)                */
    504              /*   Parameter "NbrOfConversion" is discarded.                            */
    505              /*   Note: Scan mode is present by hardware on this device and, if        */
    506              /*   disabled, discards automatically nb of conversions. Anyway, nb of    */
    507              /*   conversions is forced to 0x00 for alignment over all STM32 devices.  */
    508              /* - if scan mode is enabled, regular channels sequence length is set to  */
    509              /*   parameter "NbrOfConversion"                                          */
    510              if (ADC_CR1_SCAN_SET(hadc->Init.ScanConvMode) == ADC_SCAN_ENABLE)
    511              {
    512                tmp_sqr1 = ADC_SQR1_L_SHIFT(hadc->Init.NbrOfConversion);
    513              }
    514                
    515              MODIFY_REG(hadc->Instance->SQR1,
    516                         ADC_SQR1_L          ,
    517                         tmp_sqr1             );
    518              
    519              /* Check back that ADC registers have effectively been configured to      */
    520              /* ensure of no potential problem of ADC core IP clocking.                */
    521              /* Check through register CR2 (excluding bits set in other functions:     */
    522              /* execution control bits (ADON, JSWSTART, SWSTART), regular group bits   */
    523              /* (DMA), injected group bits (JEXTTRIG and JEXTSEL), channel internal    */
    524              /* measurement path bit (TSVREFE).                                        */
    525              if (READ_BIT(hadc->Instance->CR2, ~(ADC_CR2_ADON | ADC_CR2_DMA |
    526                                                  ADC_CR2_SWSTART | ADC_CR2_JSWSTART |
    527                                                  ADC_CR2_JEXTTRIG | ADC_CR2_JEXTSEL |
    528                                                  ADC_CR2_TSVREFE                     ))
    529                   == tmp_cr2)
    530              {
    531                /* Set ADC error code to none */
    532                ADC_CLEAR_ERRORCODE(hadc);
    533                
    534                /* Set the ADC state */
    535                ADC_STATE_CLR_SET(hadc->State,
    536                                  HAL_ADC_STATE_BUSY_INTERNAL,
    537                                  HAL_ADC_STATE_READY);
    538              }
    539              else
    540              {
    541                /* Update ADC state machine to error */
    542                ADC_STATE_CLR_SET(hadc->State,
    543                                  HAL_ADC_STATE_BUSY_INTERNAL,
    544                                  HAL_ADC_STATE_ERROR_INTERNAL);
    545                
    546                /* Set ADC error code to ADC IP internal error */
    547                SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
    548                
    549                tmp_hal_status = HAL_ERROR;
    550              }
    551            
    552            }
    553            else
    554            {
    555              /* Update ADC state machine to error */
    556              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
    557                  
    558              tmp_hal_status = HAL_ERROR;
    559            }
    560            
    561            /* Return function status */
    562            return tmp_hal_status;
    563          }
    564          
    565          /**
    566            * @brief  Deinitialize the ADC peripheral registers to their default reset
    567            *         values, with deinitialization of the ADC MSP.
    568            *         If needed, the example code can be copied and uncommented into
    569            *         function HAL_ADC_MspDeInit().
    570            * @param  hadc: ADC handle
    571            * @retval HAL status
    572            */
    573          HAL_StatusTypeDef HAL_ADC_DeInit(ADC_HandleTypeDef* hadc)
    574          {
    575            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    576            
    577            /* Check ADC handle */
    578            if(hadc == NULL)
    579            {
    580               return HAL_ERROR;
    581            }
    582            
    583            /* Check the parameters */
    584            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    585            
    586            /* Set ADC state */
    587            SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
    588            
    589            /* Stop potential conversion on going, on regular and injected groups */
    590            /* Disable ADC peripheral */
    591            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
    592            
    593            
    594            /* Configuration of ADC parameters if previous preliminary actions are      */ 
    595            /* correctly completed.                                                     */
    596            if (tmp_hal_status == HAL_OK)
    597            {
    598              /* ========== Reset ADC registers ========== */
    599          
    600          
    601          
    602          
    603              /* Reset register SR */
    604              __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD | ADC_FLAG_JEOC | ADC_FLAG_EOC |
    605                                          ADC_FLAG_JSTRT | ADC_FLAG_STRT));
    606                                   
    607              /* Reset register CR1 */
    608              CLEAR_BIT(hadc->Instance->CR1, (ADC_CR1_AWDEN   | ADC_CR1_JAWDEN | ADC_CR1_DISCNUM | 
    609                                              ADC_CR1_JDISCEN | ADC_CR1_DISCEN | ADC_CR1_JAUTO   | 
    610                                              ADC_CR1_AWDSGL  | ADC_CR1_SCAN   | ADC_CR1_JEOCIE  |   
    611                                              ADC_CR1_AWDIE   | ADC_CR1_EOCIE  | ADC_CR1_AWDCH    ));
    612              
    613              /* Reset register CR2 */
    614              CLEAR_BIT(hadc->Instance->CR2, (ADC_CR2_TSVREFE | ADC_CR2_SWSTART | ADC_CR2_JSWSTART | 
    615                                              ADC_CR2_EXTTRIG | ADC_CR2_EXTSEL  | ADC_CR2_JEXTTRIG |  
    616                                              ADC_CR2_JEXTSEL | ADC_CR2_ALIGN   | ADC_CR2_DMA      |        
    617                                              ADC_CR2_RSTCAL  | ADC_CR2_CAL     | ADC_CR2_CONT     |          
    618                                              ADC_CR2_ADON                                          ));
    619              
    620              /* Reset register SMPR1 */
    621              CLEAR_BIT(hadc->Instance->SMPR1, (ADC_SMPR1_SMP17 | ADC_SMPR1_SMP16 | ADC_SMPR1_SMP15 | 
    622                                                ADC_SMPR1_SMP14 | ADC_SMPR1_SMP13 | ADC_SMPR1_SMP12 | 
    623                                                ADC_SMPR1_SMP11 | ADC_SMPR1_SMP10                    ));
    624              
    625              /* Reset register SMPR2 */
    626              CLEAR_BIT(hadc->Instance->SMPR2, (ADC_SMPR2_SMP9 | ADC_SMPR2_SMP8 | ADC_SMPR2_SMP7 | 
    627                                                ADC_SMPR2_SMP6 | ADC_SMPR2_SMP5 | ADC_SMPR2_SMP4 | 
    628                                                ADC_SMPR2_SMP3 | ADC_SMPR2_SMP2 | ADC_SMPR2_SMP1 | 
    629                                                ADC_SMPR2_SMP0                                    ));
    630          
    631              /* Reset register JOFR1 */
    632              CLEAR_BIT(hadc->Instance->JOFR1, ADC_JOFR1_JOFFSET1);
    633              /* Reset register JOFR2 */
    634              CLEAR_BIT(hadc->Instance->JOFR2, ADC_JOFR2_JOFFSET2);
    635              /* Reset register JOFR3 */
    636              CLEAR_BIT(hadc->Instance->JOFR3, ADC_JOFR3_JOFFSET3);
    637              /* Reset register JOFR4 */
    638              CLEAR_BIT(hadc->Instance->JOFR4, ADC_JOFR4_JOFFSET4);
    639              
    640              /* Reset register HTR */
    641              CLEAR_BIT(hadc->Instance->HTR, ADC_HTR_HT);
    642              /* Reset register LTR */
    643              CLEAR_BIT(hadc->Instance->LTR, ADC_LTR_LT);
    644              
    645              /* Reset register SQR1 */
    646              CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
    647                                              ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
    648                                              ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
    649              
    650              /* Reset register SQR1 */
    651              CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L    |
    652                                              ADC_SQR1_SQ16 | ADC_SQR1_SQ15 | 
    653                                              ADC_SQR1_SQ14 | ADC_SQR1_SQ13  );
    654              
    655              /* Reset register SQR2 */
    656              CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ12 | ADC_SQR2_SQ11 | ADC_SQR2_SQ10 | 
    657                                              ADC_SQR2_SQ9  | ADC_SQR2_SQ8  | ADC_SQR2_SQ7   );
    658              
    659              /* Reset register SQR3 */
    660              CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ6 | ADC_SQR3_SQ5 | ADC_SQR3_SQ4 | 
    661                                              ADC_SQR3_SQ3 | ADC_SQR3_SQ2 | ADC_SQR3_SQ1  );
    662              
    663              /* Reset register JSQR */
    664              CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
    665                                              ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
    666                                              ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
    667              
    668              /* Reset register JSQR */
    669              CLEAR_BIT(hadc->Instance->JSQR, ADC_JSQR_JL |
    670                                              ADC_JSQR_JSQ4 | ADC_JSQR_JSQ3 | 
    671                                              ADC_JSQR_JSQ2 | ADC_JSQR_JSQ1  );
    672              
    673              /* Reset register DR */
    674              /* bits in access mode read only, no direct reset applicable*/
    675              
    676              /* Reset registers JDR1, JDR2, JDR3, JDR4 */
    677              /* bits in access mode read only, no direct reset applicable*/
    678              
    679              /* ========== Hard reset ADC peripheral ========== */
    680              /* Performs a global reset of the entire ADC peripheral: ADC state is     */
    681              /* forced to a similar state after device power-on.                       */
    682              /* If needed, copy-paste and uncomment the following reset code into      */
    683              /* function "void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)":              */
    684              /*                                                                        */
    685              /*  __HAL_RCC_ADC1_FORCE_RESET()                                          */
    686              /*  __HAL_RCC_ADC1_RELEASE_RESET()                                        */
    687              
    688              /* DeInit the low level hardware */
    689              HAL_ADC_MspDeInit(hadc);
    690              
    691              /* Set ADC error code to none */
    692              ADC_CLEAR_ERRORCODE(hadc);
    693              
    694              /* Set ADC state */
    695              hadc->State = HAL_ADC_STATE_RESET; 
    696            
    697            }
    698            
    699            /* Process unlocked */
    700            __HAL_UNLOCK(hadc);
    701            
    702            /* Return function status */
    703            return tmp_hal_status;
    704          }
    705          
    706          /**
    707            * @brief  Initializes the ADC MSP.
    708            * @param  hadc: ADC handle
    709            * @retval None
    710            */
    711          __weak void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc)
    712          {
    713            /* Prevent unused argument(s) compilation warning */
    714            UNUSED(hadc);
    715            /* NOTE : This function should not be modified. When the callback is needed,
    716                      function HAL_ADC_MspInit must be implemented in the user file.
    717             */ 
    718          }
    719          
    720          /**
    721            * @brief  DeInitializes the ADC MSP.
    722            * @param  hadc: ADC handle
    723            * @retval None
    724            */
    725          __weak void HAL_ADC_MspDeInit(ADC_HandleTypeDef* hadc)
    726          {
    727            /* Prevent unused argument(s) compilation warning */
    728            UNUSED(hadc);
    729            /* NOTE : This function should not be modified. When the callback is needed,
    730                      function HAL_ADC_MspDeInit must be implemented in the user file.
    731             */ 
    732          }
    733          
    734          /**
    735            * @}
    736            */
    737          
    738          /** @defgroup ADC_Exported_Functions_Group2 IO operation functions
    739           *  @brief    Input and Output operation functions
    740           *
    741          @verbatim   
    742           ===============================================================================
    743                                ##### IO operation functions #####
    744           ===============================================================================
    745              [..]  This section provides functions allowing to:
    746                (+) Start conversion of regular group.
    747                (+) Stop conversion of regular group.
    748                (+) Poll for conversion complete on regular group.
    749                (+) Poll for conversion event.
    750                (+) Get result of regular channel conversion.
    751                (+) Start conversion of regular group and enable interruptions.
    752                (+) Stop conversion of regular group and disable interruptions.
    753                (+) Handle ADC interrupt request
    754                (+) Start conversion of regular group and enable DMA transfer.
    755                (+) Stop conversion of regular group and disable ADC DMA transfer.
    756          @endverbatim
    757            * @{
    758            */
    759          
    760          /**
    761            * @brief  Enables ADC, starts conversion of regular group.
    762            *         Interruptions enabled in this function: None.
    763            * @param  hadc: ADC handle
    764            * @retval HAL status
    765            */
    766          HAL_StatusTypeDef HAL_ADC_Start(ADC_HandleTypeDef* hadc)
    767          {
    768            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    769            
    770            /* Check the parameters */
    771            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    772            
    773            /* Process locked */
    774            __HAL_LOCK(hadc);
    775             
    776            /* Enable the ADC peripheral */
    777            tmp_hal_status = ADC_Enable(hadc);
    778            
    779            /* Start conversion if ADC is effectively enabled */
    780            if (tmp_hal_status == HAL_OK)
    781            {
    782              /* Set ADC state                                                          */
    783              /* - Clear state bitfield related to regular group conversion results     */
    784              /* - Set state bitfield related to regular operation                      */
    785              ADC_STATE_CLR_SET(hadc->State,
    786                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC,
    787                                HAL_ADC_STATE_REG_BUSY);
    788              
    789              /* Set group injected state (from auto-injection) and multimode state     */
    790              /* for all cases of multimode: independent mode, multimode ADC master     */
    791              /* or multimode ADC slave (for devices with several ADCs):                */
    792              if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
    793              {
    794                /* Set ADC state (ADC independent or master) */
    795                CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
    796                
    797                /* If conversions on group regular are also triggering group injected,  */
    798                /* update ADC state.                                                    */
    799                if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
    800                {
    801                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
    802                }
    803              }
    804              else
    805              {
    806                /* Set ADC state (ADC slave) */
    807                SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
    808                
    809                /* If conversions on group regular are also triggering group injected,  */
    810                /* update ADC state.                                                    */
    811                if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
    812                {
    813                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
    814                }
    815              }
    816              
    817              /* State machine update: Check if an injected conversion is ongoing */
    818              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
    819              {
    820                /* Reset ADC error code fields related to conversions on group regular */
    821                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
    822              }
    823              else
    824              {
    825                /* Reset ADC all error code fields */
    826                ADC_CLEAR_ERRORCODE(hadc);
    827              }
    828              
    829              /* Process unlocked */
    830              /* Unlock before starting ADC conversions: in case of potential           */
    831              /* interruption, to let the process to ADC IRQ Handler.                   */
    832              __HAL_UNLOCK(hadc);
    833            
    834              /* Clear regular group conversion flag */
    835              /* (To ensure of no unknown state from potential previous ADC operations) */
    836              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
    837              
    838              /* Enable conversion of regular group.                                    */
    839              /* If software start has been selected, conversion starts immediately.    */
    840              /* If external trigger has been selected, conversion will start at next   */
    841              /* trigger event.                                                         */
    842              /* Case of multimode enabled:                                             */ 
    843              /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
    844              /*  - if ADC is master, ADC is enabled and conversion is started.         */
    845              /* If ADC is master, ADC is enabled and conversion is started.            */
    846              /* Note: Alternate trigger for single conversion could be to force an     */
    847              /*       additional set of bit ADON "hadc->Instance->CR2 |= ADC_CR2_ADON;"*/
    848              if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
    849                  ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
    850              {
    851                /* Start ADC conversion on regular group with SW start */
    852                SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
    853              }
    854              else
    855              {
    856                /* Start ADC conversion on regular group with external trigger */
    857                SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
    858              }
    859            }
    860            else
    861            {
    862              /* Process unlocked */
    863              __HAL_UNLOCK(hadc);
    864            }
    865              
    866            /* Return function status */
    867            return tmp_hal_status;
    868          }
    869          
    870          /**
    871            * @brief  Stop ADC conversion of regular group (and injected channels in 
    872            *         case of auto_injection mode), disable ADC peripheral.
    873            * @note:  ADC peripheral disable is forcing stop of potential 
    874            *         conversion on injected group. If injected group is under use, it
    875            *         should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
    876            * @param  hadc: ADC handle
    877            * @retval HAL status.
    878            */
    879          HAL_StatusTypeDef HAL_ADC_Stop(ADC_HandleTypeDef* hadc)
    880          {
    881            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
    882            
    883            /* Check the parameters */
    884            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    885               
    886            /* Process locked */
    887            __HAL_LOCK(hadc);
    888            
    889            /* Stop potential conversion on going, on regular and injected groups */
    890            /* Disable ADC peripheral */
    891            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
    892            
    893            /* Check if ADC is effectively disabled */
    894            if (tmp_hal_status == HAL_OK)
    895            {
    896              /* Set ADC state */
    897              ADC_STATE_CLR_SET(hadc->State,
    898                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
    899                                HAL_ADC_STATE_READY);
    900            }
    901            
    902            /* Process unlocked */
    903            __HAL_UNLOCK(hadc);
    904            
    905            /* Return function status */
    906            return tmp_hal_status;
    907          }
    908          
    909          /**
    910            * @brief  Wait for regular group conversion to be completed.
    911            * @note   This function cannot be used in a particular setup: ADC configured 
    912            *         in DMA mode.
    913            *         In this case, DMA resets the flag EOC and polling cannot be
    914            *         performed on each conversion.
    915            * @note   On STM32F1 devices, limitation in case of sequencer enabled
    916            *         (several ranks selected): polling cannot be done on each 
    917            *         conversion inside the sequence. In this case, polling is replaced by
    918            *         wait for maximum conversion time.
    919            * @param  hadc: ADC handle
    920            * @param  Timeout: Timeout value in millisecond.
    921            * @retval HAL status
    922            */
    923          HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
    924          {
    925            uint32_t tickstart = 0U;
    926            
    927            /* Variables for polling in case of scan mode enabled and polling for each  */
    928            /* conversion.                                                              */
    929            __IO uint32_t Conversion_Timeout_CPU_cycles = 0U;
    930            uint32_t Conversion_Timeout_CPU_cycles_max = 0U;
    931           
    932            /* Check the parameters */
    933            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
    934            
    935            /* Get tick count */
    936            tickstart = HAL_GetTick();
    937            
    938            /* Verification that ADC configuration is compliant with polling for        */
    939            /* each conversion:                                                         */
    940            /* Particular case is ADC configured in DMA mode                            */
    941            if (HAL_IS_BIT_SET(hadc->Instance->CR2, ADC_CR2_DMA))
    942            {
    943              /* Update ADC state machine to error */
    944              SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
    945              
    946              /* Process unlocked */
    947              __HAL_UNLOCK(hadc);
    948              
    949              return HAL_ERROR;
    950            }
    951            
    952            /* Polling for end of conversion: differentiation if single/sequence        */
    953            /* conversion.                                                              */
    954            /*  - If single conversion for regular group (Scan mode disabled or enabled */
    955            /*    with NbrOfConversion =1), flag EOC is used to determine the           */
    956            /*    conversion completion.                                                */
    957            /*  - If sequence conversion for regular group (scan mode enabled and       */
    958            /*    NbrOfConversion >=2), flag EOC is set only at the end of the          */
    959            /*    sequence.                                                             */
    960            /*    To poll for each conversion, the maximum conversion time is computed  */
    961            /*    from ADC conversion time (selected sampling time + conversion time of */
    962            /*    12.5 ADC clock cycles) and APB2/ADC clock prescalers (depending on    */
    963            /*    settings, conversion time range can be from 28 to 32256 CPU cycles).  */
    964            /*    As flag EOC is not set after each conversion, no timeout status can   */
    965            /*    be set.                                                               */
    966            if (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_SCAN) &&
    967                HAL_IS_BIT_CLR(hadc->Instance->SQR1, ADC_SQR1_L)    )
    968            {
    969              /* Wait until End of Conversion flag is raised */
    970              while(HAL_IS_BIT_CLR(hadc->Instance->SR, ADC_FLAG_EOC))
    971              {
    972                /* Check if timeout is disabled (set to infinite wait) */
    973                if(Timeout != HAL_MAX_DELAY)
    974                {
    975                  if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
    976                  {
    977                    /* Update ADC state machine to timeout */
    978                    SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
    979                    
    980                    /* Process unlocked */
    981                    __HAL_UNLOCK(hadc);
    982                    
    983                    return HAL_TIMEOUT;
    984                  }
    985                }
    986              }
    987            }
    988            else
    989            {
    990              /* Replace polling by wait for maximum conversion time */
    991              /*  - Computation of CPU clock cycles corresponding to ADC clock cycles   */
    992              /*    and ADC maximum conversion cycles on all channels.                  */
    993              /*  - Wait for the expected ADC clock cycles delay                        */
    994              Conversion_Timeout_CPU_cycles_max = ((SystemCoreClock
    995                                                    / HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_ADC))
    996                                                   * ADC_CONVCYCLES_MAX_RANGE(hadc)                 );
    997              
    998              while(Conversion_Timeout_CPU_cycles < Conversion_Timeout_CPU_cycles_max)
    999              {
   1000                /* Check if timeout is disabled (set to infinite wait) */
   1001                if(Timeout != HAL_MAX_DELAY)
   1002                {
   1003                  if((Timeout == 0U) || ((HAL_GetTick() - tickstart) > Timeout))
   1004                  {
   1005                    /* Update ADC state machine to timeout */
   1006                    SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   1007                    
   1008                    /* Process unlocked */
   1009                    __HAL_UNLOCK(hadc);
   1010                    
   1011                    return HAL_TIMEOUT;
   1012                  }
   1013                }
   1014                Conversion_Timeout_CPU_cycles ++;
   1015              }
   1016            }
   1017            
   1018            /* Clear regular group conversion flag */
   1019            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
   1020            
   1021            /* Update ADC state machine */
   1022            SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   1023            
   1024            /* Determine whether any further conversion upcoming on group regular       */
   1025            /* by external trigger, continuous mode or scan sequence on going.          */
   1026            /* Note: On STM32F1 devices, in case of sequencer enabled                   */
   1027            /*       (several ranks selected), end of conversion flag is raised         */
   1028            /*       at the end of the sequence.                                        */
   1029            if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
   1030               (hadc->Init.ContinuousConvMode == DISABLE)   )
   1031            {   
   1032              /* Set ADC state */
   1033              CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   1034          
   1035              if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   1036              { 
   1037                SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   1038              }
   1039            }
   1040            
   1041            /* Return ADC state */
   1042            return HAL_OK;
   1043          }
   1044          
   1045          /**
   1046            * @brief  Poll for conversion event.
   1047            * @param  hadc: ADC handle
   1048            * @param  EventType: the ADC event type.
   1049            *          This parameter can be one of the following values:
   1050            *            @arg ADC_AWD_EVENT: ADC Analog watchdog event.
   1051            * @param  Timeout: Timeout value in millisecond.
   1052            * @retval HAL status
   1053            */
   1054          HAL_StatusTypeDef HAL_ADC_PollForEvent(ADC_HandleTypeDef* hadc, uint32_t EventType, uint32_t Timeout)
   1055          {
   1056            uint32_t tickstart = 0U; 
   1057          
   1058            /* Check the parameters */
   1059            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1060            assert_param(IS_ADC_EVENT_TYPE(EventType));
   1061            
   1062            /* Get tick count */
   1063            tickstart = HAL_GetTick();
   1064            
   1065            /* Check selected event flag */
   1066            while(__HAL_ADC_GET_FLAG(hadc, EventType) == RESET)
   1067            {
   1068              /* Check if timeout is disabled (set to infinite wait) */
   1069              if(Timeout != HAL_MAX_DELAY)
   1070              {
   1071                if((Timeout == 0U) || ((HAL_GetTick() - tickstart ) > Timeout))
   1072                {
   1073                  /* Update ADC state machine to timeout */
   1074                  SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
   1075                  
   1076                  /* Process unlocked */
   1077                  __HAL_UNLOCK(hadc);
   1078                  
   1079                  return HAL_TIMEOUT;
   1080                }
   1081              }
   1082            }
   1083            
   1084            /* Analog watchdog (level out of window) event */
   1085            /* Set ADC state */
   1086            SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
   1087              
   1088            /* Clear ADC analog watchdog flag */
   1089            __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
   1090            
   1091            /* Return ADC state */
   1092            return HAL_OK;
   1093          }
   1094          
   1095          /**
   1096            * @brief  Enables ADC, starts conversion of regular group with interruption.
   1097            *         Interruptions enabled in this function:
   1098            *          - EOC (end of conversion of regular group)
   1099            *         Each of these interruptions has its dedicated callback function.
   1100            * @param  hadc: ADC handle
   1101            * @retval HAL status
   1102            */
   1103          HAL_StatusTypeDef HAL_ADC_Start_IT(ADC_HandleTypeDef* hadc)
   1104          {
   1105            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1106            
   1107            /* Check the parameters */
   1108            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1109            
   1110            /* Process locked */
   1111            __HAL_LOCK(hadc);
   1112              
   1113            /* Enable the ADC peripheral */
   1114            tmp_hal_status = ADC_Enable(hadc);
   1115            
   1116            /* Start conversion if ADC is effectively enabled */
   1117            if (tmp_hal_status == HAL_OK)
   1118            {
   1119              /* Set ADC state                                                          */
   1120              /* - Clear state bitfield related to regular group conversion results     */
   1121              /* - Set state bitfield related to regular operation                      */
   1122              ADC_STATE_CLR_SET(hadc->State,
   1123                                HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
   1124                                HAL_ADC_STATE_REG_BUSY);
   1125              
   1126              /* Set group injected state (from auto-injection) and multimode state     */
   1127              /* for all cases of multimode: independent mode, multimode ADC master     */
   1128              /* or multimode ADC slave (for devices with several ADCs):                */
   1129              if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
   1130              {
   1131                /* Set ADC state (ADC independent or master) */
   1132                CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   1133                
   1134                /* If conversions on group regular are also triggering group injected,  */
   1135                /* update ADC state.                                                    */
   1136                if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   1137                {
   1138                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   1139                }
   1140              }
   1141              else
   1142              {
   1143                /* Set ADC state (ADC slave) */
   1144                SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   1145                
   1146                /* If conversions on group regular are also triggering group injected,  */
   1147                /* update ADC state.                                                    */
   1148                if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
   1149                {
   1150                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
   1151                }
   1152              }
   1153              
   1154              /* State machine update: Check if an injected conversion is ongoing */
   1155              if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   1156              {
   1157                /* Reset ADC error code fields related to conversions on group regular */
   1158                CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   1159              }
   1160              else
   1161              {
   1162                /* Reset ADC all error code fields */
   1163                ADC_CLEAR_ERRORCODE(hadc);
   1164              }
   1165              
   1166              /* Process unlocked */
   1167              /* Unlock before starting ADC conversions: in case of potential           */
   1168              /* interruption, to let the process to ADC IRQ Handler.                   */
   1169              __HAL_UNLOCK(hadc);
   1170              
   1171              /* Clear regular group conversion flag and overrun flag */
   1172              /* (To ensure of no unknown state from potential previous ADC operations) */
   1173              __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   1174              
   1175              /* Enable end of conversion interrupt for regular group */
   1176              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_EOC);
   1177              
   1178              /* Enable conversion of regular group.                                    */
   1179              /* If software start has been selected, conversion starts immediately.    */
   1180              /* If external trigger has been selected, conversion will start at next   */
   1181              /* trigger event.                                                         */
   1182              /* Case of multimode enabled:                                             */ 
   1183              /*  - if ADC is slave, ADC is enabled only (conversion is not started).   */
   1184              /*  - if ADC is master, ADC is enabled and conversion is started.         */
   1185              if (ADC_IS_SOFTWARE_START_REGULAR(hadc)      &&
   1186                  ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc)  )
   1187              {
   1188                /* Start ADC conversion on regular group with SW start */
   1189                SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
   1190              }
   1191              else
   1192              {
   1193                /* Start ADC conversion on regular group with external trigger */
   1194                SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
   1195              }
   1196            }
   1197            else
   1198            {
   1199              /* Process unlocked */
   1200              __HAL_UNLOCK(hadc);
   1201            }
   1202            
   1203            /* Return function status */
   1204            return tmp_hal_status;
   1205          }
   1206          
   1207          /**
   1208            * @brief  Stop ADC conversion of regular group (and injected group in 
   1209            *         case of auto_injection mode), disable interrution of 
   1210            *         end-of-conversion, disable ADC peripheral.
   1211            * @param  hadc: ADC handle
   1212            * @retval None
   1213            */
   1214          HAL_StatusTypeDef HAL_ADC_Stop_IT(ADC_HandleTypeDef* hadc)
   1215          {
   1216            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1217            
   1218            /* Check the parameters */
   1219            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1220               
   1221            /* Process locked */
   1222            __HAL_LOCK(hadc);
   1223            
   1224            /* Stop potential conversion on going, on regular and injected groups */
   1225            /* Disable ADC peripheral */
   1226            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   1227            
   1228            /* Check if ADC is effectively disabled */
   1229            if (tmp_hal_status == HAL_OK)
   1230            {
   1231              /* Disable ADC end of conversion interrupt for regular group */
   1232              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   1233              
   1234              /* Set ADC state */
   1235              ADC_STATE_CLR_SET(hadc->State,
   1236                                HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
   1237                                HAL_ADC_STATE_READY);
   1238            }
   1239            
   1240            /* Process unlocked */
   1241            __HAL_UNLOCK(hadc);
   1242            
   1243            /* Return function status */
   1244            return tmp_hal_status;
   1245          }
   1246          
   1247          /**
   1248            * @brief  Enables ADC, starts conversion of regular group and transfers result
   1249            *         through DMA.
   1250            *         Interruptions enabled in this function:
   1251            *          - DMA transfer complete
   1252            *          - DMA half transfer
   1253            *         Each of these interruptions has its dedicated callback function.
   1254            * @note   For devices with several ADCs: This function is for single-ADC mode 
   1255            *         only. For multimode, use the dedicated MultimodeStart function.
   1256            * @note   On STM32F1 devices, only ADC1 and ADC3 (ADC availability depending
   1257            *         on devices) have DMA capability.
   1258            *         ADC2 converted data can be transferred in dual ADC mode using DMA
   1259            *         of ADC1 (ADC master in multimode).
   1260            *         In case of using ADC1 with DMA on a device featuring 2 ADC
   1261            *         instances: ADC1 conversion register DR contains ADC1 conversion 
   1262            *         result (ADC1 register DR bits 0 to 11) and, additionally, ADC2 last
   1263            *         conversion result (ADC1 register DR bits 16 to 27). Therefore, to
   1264            *         have DMA transferring the conversion results of ADC1 only, DMA must
   1265            *         be configured to transfer size: half word.
   1266            * @param  hadc: ADC handle
   1267            * @param  pData: The destination Buffer address.
   1268            * @param  Length: The length of data to be transferred from ADC peripheral to memory.
   1269            * @retval None
   1270            */
   1271          HAL_StatusTypeDef HAL_ADC_Start_DMA(ADC_HandleTypeDef* hadc, uint32_t* pData, uint32_t Length)
   1272          {
   1273            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1274            
   1275            /* Check the parameters */
   1276            assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
   1277              
   1278            /* Verification if multimode is disabled (for devices with several ADC)     */
   1279            /* If multimode is enabled, dedicated function multimode conversion         */
   1280            /* start DMA must be used.                                                  */
   1281            if(ADC_MULTIMODE_IS_ENABLE(hadc) == RESET)
   1282            {
   1283              /* Process locked */
   1284              __HAL_LOCK(hadc);
   1285              
   1286              /* Enable the ADC peripheral */
   1287              tmp_hal_status = ADC_Enable(hadc);
   1288              
   1289              /* Start conversion if ADC is effectively enabled */
   1290              if (tmp_hal_status == HAL_OK)
   1291              {
   1292                /* Set ADC state                                                        */
   1293                /* - Clear state bitfield related to regular group conversion results   */
   1294                /* - Set state bitfield related to regular operation                    */
   1295                ADC_STATE_CLR_SET(hadc->State,
   1296                                  HAL_ADC_STATE_READY | HAL_ADC_STATE_REG_EOC | HAL_ADC_STATE_REG_OVR | HAL_ADC_STATE_REG_EOSMP,
   1297                                  HAL_ADC_STATE_REG_BUSY);
   1298              
   1299              /* Set group injected state (from auto-injection) and multimode state     */
   1300              /* for all cases of multimode: independent mode, multimode ADC master     */
   1301              /* or multimode ADC slave (for devices with several ADCs):                */
   1302              if (ADC_NONMULTIMODE_OR_MULTIMODEMASTER(hadc))
   1303              {
   1304                /* Set ADC state (ADC independent or master) */
   1305                CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   1306                
   1307                /* If conversions on group regular are also triggering group injected,  */
   1308                /* update ADC state.                                                    */
   1309                if (READ_BIT(hadc->Instance->CR1, ADC_CR1_JAUTO) != RESET)
   1310                {
   1311                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
   1312                }
   1313              }
   1314              else
   1315              {
   1316                /* Set ADC state (ADC slave) */
   1317                SET_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
   1318                
   1319                /* If conversions on group regular are also triggering group injected,  */
   1320                /* update ADC state.                                                    */
   1321                if (ADC_MULTIMODE_AUTO_INJECTED(hadc))
   1322                {
   1323                  ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);
   1324                }
   1325              }
   1326                
   1327                /* State machine update: Check if an injected conversion is ongoing */
   1328                if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   1329                {
   1330                  /* Reset ADC error code fields related to conversions on group regular */
   1331                  CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
   1332                }
   1333                else
   1334                {
   1335                  /* Reset ADC all error code fields */
   1336                  ADC_CLEAR_ERRORCODE(hadc);
   1337                }
   1338                
   1339                /* Process unlocked */
   1340                /* Unlock before starting ADC conversions: in case of potential         */
   1341                /* interruption, to let the process to ADC IRQ Handler.                 */
   1342                __HAL_UNLOCK(hadc);
   1343                
   1344                /* Set the DMA transfer complete callback */
   1345                hadc->DMA_Handle->XferCpltCallback = ADC_DMAConvCplt;
   1346          
   1347                /* Set the DMA half transfer complete callback */
   1348                hadc->DMA_Handle->XferHalfCpltCallback = ADC_DMAHalfConvCplt;
   1349                
   1350                /* Set the DMA error callback */
   1351                hadc->DMA_Handle->XferErrorCallback = ADC_DMAError;
   1352          
   1353                
   1354                /* Manage ADC and DMA start: ADC overrun interruption, DMA start, ADC   */
   1355                /* start (in case of SW start):                                         */
   1356                
   1357                /* Clear regular group conversion flag and overrun flag */
   1358                /* (To ensure of no unknown state from potential previous ADC           */
   1359                /* operations)                                                          */
   1360                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOC);
   1361                
   1362                /* Enable ADC DMA mode */
   1363                SET_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
   1364                
   1365                /* Start the DMA channel */
   1366                HAL_DMA_Start_IT(hadc->DMA_Handle, (uint32_t)&hadc->Instance->DR, (uint32_t)pData, Length);
   1367                
   1368                /* Enable conversion of regular group.                                  */
   1369                /* If software start has been selected, conversion starts immediately.  */
   1370                /* If external trigger has been selected, conversion will start at next */
   1371                /* trigger event.                                                       */
   1372                if (ADC_IS_SOFTWARE_START_REGULAR(hadc))
   1373                {
   1374                  /* Start ADC conversion on regular group with SW start */
   1375                  SET_BIT(hadc->Instance->CR2, (ADC_CR2_SWSTART | ADC_CR2_EXTTRIG));
   1376                }
   1377                else
   1378                {
   1379                  /* Start ADC conversion on regular group with external trigger */
   1380                  SET_BIT(hadc->Instance->CR2, ADC_CR2_EXTTRIG);
   1381                }
   1382              }
   1383              else
   1384              {
   1385                /* Process unlocked */
   1386                __HAL_UNLOCK(hadc);
   1387              }
   1388            }
   1389            else
   1390            {
   1391              tmp_hal_status = HAL_ERROR;
   1392            }
   1393            
   1394            /* Return function status */
   1395            return tmp_hal_status;
   1396          }
   1397          
   1398          /**
   1399            * @brief  Stop ADC conversion of regular group (and injected group in 
   1400            *         case of auto_injection mode), disable ADC DMA transfer, disable 
   1401            *         ADC peripheral.
   1402            * @note:  ADC peripheral disable is forcing stop of potential 
   1403            *         conversion on injected group. If injected group is under use, it
   1404            *         should be preliminarily stopped using HAL_ADCEx_InjectedStop function.
   1405            * @note   For devices with several ADCs: This function is for single-ADC mode 
   1406            *         only. For multimode, use the dedicated MultimodeStop function.
   1407            * @note   On STM32F1 devices, only ADC1 and ADC3 (ADC availability depending
   1408            *         on devices) have DMA capability.
   1409            * @param  hadc: ADC handle
   1410            * @retval HAL status.
   1411            */
   1412          HAL_StatusTypeDef HAL_ADC_Stop_DMA(ADC_HandleTypeDef* hadc)
   1413          {
   1414            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1415            
   1416            /* Check the parameters */
   1417            assert_param(IS_ADC_DMA_CAPABILITY_INSTANCE(hadc->Instance));
   1418               
   1419            /* Process locked */
   1420            __HAL_LOCK(hadc);
   1421            
   1422            /* Stop potential conversion on going, on regular and injected groups */
   1423            /* Disable ADC peripheral */
   1424            tmp_hal_status = ADC_ConversionStop_Disable(hadc);
   1425            
   1426            /* Check if ADC is effectively disabled */
   1427            if (tmp_hal_status == HAL_OK)
   1428            {
   1429              /* Disable ADC DMA mode */
   1430              CLEAR_BIT(hadc->Instance->CR2, ADC_CR2_DMA);
   1431              
   1432              /* Disable the DMA channel (in case of DMA in circular mode or stop while */
   1433              /* DMA transfer is on going)                                              */
   1434              tmp_hal_status = HAL_DMA_Abort(hadc->DMA_Handle);
   1435              
   1436              /* Check if DMA channel effectively disabled */
   1437              if (tmp_hal_status == HAL_OK)
   1438              {
   1439                /* Set ADC state */
   1440                ADC_STATE_CLR_SET(hadc->State,
   1441                                  HAL_ADC_STATE_REG_BUSY | HAL_ADC_STATE_INJ_BUSY,
   1442                                  HAL_ADC_STATE_READY);
   1443              }
   1444              else
   1445              {
   1446                /* Update ADC state machine to error */
   1447                SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
   1448              }
   1449            }
   1450              
   1451            /* Process unlocked */
   1452            __HAL_UNLOCK(hadc);
   1453              
   1454            /* Return function status */
   1455            return tmp_hal_status;
   1456          }
   1457          
   1458          /**
   1459            * @brief  Get ADC regular group conversion result.
   1460            * @note   Reading register DR automatically clears ADC flag EOC
   1461            *         (ADC group regular end of unitary conversion).
   1462            * @note   This function does not clear ADC flag EOS 
   1463            *         (ADC group regular end of sequence conversion).
   1464            *         Occurrence of flag EOS rising:
   1465            *          - If sequencer is composed of 1 rank, flag EOS is equivalent
   1466            *            to flag EOC.
   1467            *          - If sequencer is composed of several ranks, during the scan
   1468            *            sequence flag EOC only is raised, at the end of the scan sequence
   1469            *            both flags EOC and EOS are raised.
   1470            *         To clear this flag, either use function: 
   1471            *         in programming model IT: @ref HAL_ADC_IRQHandler(), in programming
   1472            *         model polling: @ref HAL_ADC_PollForConversion() 
   1473            *         or @ref __HAL_ADC_CLEAR_FLAG(&hadc, ADC_FLAG_EOS).
   1474            * @param  hadc: ADC handle
   1475            * @retval ADC group regular conversion data
   1476            */
   1477          uint32_t HAL_ADC_GetValue(ADC_HandleTypeDef* hadc)
   1478          {
   1479            /* Check the parameters */
   1480            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1481          
   1482            /* Note: EOC flag is not cleared here by software because automatically     */
   1483            /*       cleared by hardware when reading register DR.                      */
   1484            
   1485            /* Return ADC converted value */ 
   1486            return hadc->Instance->DR;
   1487          }
   1488          
   1489          /**
   1490            * @brief  Handles ADC interrupt request  
   1491            * @param  hadc: ADC handle
   1492            * @retval None
   1493            */
   1494          void HAL_ADC_IRQHandler(ADC_HandleTypeDef* hadc)
   1495          {
   1496            /* Check the parameters */
   1497            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1498            assert_param(IS_FUNCTIONAL_STATE(hadc->Init.ContinuousConvMode));
   1499            assert_param(IS_ADC_REGULAR_NB_CONV(hadc->Init.NbrOfConversion));
   1500            
   1501            
   1502            /* ========== Check End of Conversion flag for regular group ========== */
   1503            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_EOC))
   1504            {
   1505              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOC) )
   1506              {
   1507                /* Update state machine on conversion status if not in error state */
   1508                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   1509                {
   1510                  /* Set ADC state */
   1511                  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC); 
   1512                }
   1513                
   1514                /* Determine whether any further conversion upcoming on group regular   */
   1515                /* by external trigger, continuous mode or scan sequence on going.      */
   1516                /* Note: On STM32F1 devices, in case of sequencer enabled               */
   1517                /*       (several ranks selected), end of conversion flag is raised     */
   1518                /*       at the end of the sequence.                                    */
   1519                if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
   1520                   (hadc->Init.ContinuousConvMode == DISABLE)   )
   1521                {
   1522                  /* Disable ADC end of conversion interrupt on group regular */
   1523                  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_EOC);
   1524                  
   1525                  /* Set ADC state */
   1526                  CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   1527                  
   1528                  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   1529                  {
   1530                    SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   1531                  }
   1532                }
   1533          
   1534                /* Conversion complete callback */
   1535                HAL_ADC_ConvCpltCallback(hadc);
   1536                
   1537                /* Clear regular group conversion flag */
   1538                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_STRT | ADC_FLAG_EOC);
   1539              }
   1540            }
   1541            
   1542            /* ========== Check End of Conversion flag for injected group ========== */
   1543            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_JEOC))
   1544            {
   1545              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOC))
   1546              {
   1547                /* Update state machine on conversion status if not in error state */
   1548                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
   1549                {
   1550                  /* Set ADC state */
   1551                  SET_BIT(hadc->State, HAL_ADC_STATE_INJ_EOC);
   1552                }
   1553          
   1554                /* Determine whether any further conversion upcoming on group injected  */
   1555                /* by external trigger, scan sequence on going or by automatic injected */
   1556                /* conversion from group regular (same conditions as group regular      */
   1557                /* interruption disabling above).                                       */
   1558                /* Note: On STM32F1 devices, in case of sequencer enabled               */
   1559                /*       (several ranks selected), end of conversion flag is raised     */
   1560                /*       at the end of the sequence.                                    */
   1561                if(ADC_IS_SOFTWARE_START_INJECTED(hadc)                     || 
   1562                   (HAL_IS_BIT_CLR(hadc->Instance->CR1, ADC_CR1_JAUTO) &&     
   1563                   (ADC_IS_SOFTWARE_START_REGULAR(hadc)        &&
   1564                    (hadc->Init.ContinuousConvMode == DISABLE)   )        )   )
   1565                {
   1566                  /* Disable ADC end of conversion interrupt on group injected */
   1567                  __HAL_ADC_DISABLE_IT(hadc, ADC_IT_JEOC);
   1568                  
   1569                  /* Set ADC state */
   1570                  CLEAR_BIT(hadc->State, HAL_ADC_STATE_INJ_BUSY);   
   1571          
   1572                  if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_REG_BUSY))
   1573                  { 
   1574                    SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   1575                  }
   1576                }
   1577          
   1578                /* Conversion complete callback */ 
   1579                HAL_ADCEx_InjectedConvCpltCallback(hadc);
   1580                
   1581                /* Clear injected group conversion flag */
   1582                __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_JSTRT | ADC_FLAG_JEOC));
   1583              }
   1584            }
   1585             
   1586            /* ========== Check Analog watchdog flags ========== */
   1587            if(__HAL_ADC_GET_IT_SOURCE(hadc, ADC_IT_AWD))
   1588            {
   1589              if(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_AWD))
   1590              {
   1591                /* Set ADC state */
   1592                SET_BIT(hadc->State, HAL_ADC_STATE_AWD1);
   1593                
   1594                /* Level out of window callback */ 
   1595                HAL_ADC_LevelOutOfWindowCallback(hadc);
   1596                
   1597                /* Clear the ADC analog watchdog flag */
   1598                __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_AWD);
   1599              }
   1600            }
   1601            
   1602          }
   1603          
   1604          /**
   1605            * @brief  Conversion complete callback in non blocking mode 
   1606            * @param  hadc: ADC handle
   1607            * @retval None
   1608            */
   1609          __weak void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
   1610          {
   1611            /* Prevent unused argument(s) compilation warning */
   1612            UNUSED(hadc);
   1613            /* NOTE : This function should not be modified. When the callback is needed,
   1614                      function HAL_ADC_ConvCpltCallback must be implemented in the user file.
   1615             */
   1616          }
   1617          
   1618          /**
   1619            * @brief  Conversion DMA half-transfer callback in non blocking mode 
   1620            * @param  hadc: ADC handle
   1621            * @retval None
   1622            */
   1623          __weak void HAL_ADC_ConvHalfCpltCallback(ADC_HandleTypeDef* hadc)
   1624          {
   1625            /* Prevent unused argument(s) compilation warning */
   1626            UNUSED(hadc);
   1627            /* NOTE : This function should not be modified. When the callback is needed,
   1628                      function HAL_ADC_ConvHalfCpltCallback must be implemented in the user file.
   1629            */
   1630          }
   1631          
   1632          /**
   1633            * @brief  Analog watchdog callback in non blocking mode. 
   1634            * @param  hadc: ADC handle
   1635            * @retval None
   1636            */
   1637          __weak void HAL_ADC_LevelOutOfWindowCallback(ADC_HandleTypeDef* hadc)
   1638          {
   1639            /* Prevent unused argument(s) compilation warning */
   1640            UNUSED(hadc);
   1641            /* NOTE : This function should not be modified. When the callback is needed,
   1642                      function HAL_ADC_LevelOutOfWindowCallback must be implemented in the user file.
   1643            */
   1644          }
   1645          
   1646          /**
   1647            * @brief  ADC error callback in non blocking mode
   1648            *        (ADC conversion with interruption or transfer by DMA)
   1649            * @param  hadc: ADC handle
   1650            * @retval None
   1651            */
   1652          __weak void HAL_ADC_ErrorCallback(ADC_HandleTypeDef *hadc)
   1653          {
   1654            /* Prevent unused argument(s) compilation warning */
   1655            UNUSED(hadc);
   1656            /* NOTE : This function should not be modified. When the callback is needed,
   1657                      function HAL_ADC_ErrorCallback must be implemented in the user file.
   1658            */
   1659          }
   1660          
   1661          
   1662          /**
   1663            * @}
   1664            */
   1665          
   1666          /** @defgroup ADC_Exported_Functions_Group3 Peripheral Control functions
   1667           *  @brief    Peripheral Control functions
   1668           *
   1669          @verbatim   
   1670           ===============================================================================
   1671                       ##### Peripheral Control functions #####
   1672           ===============================================================================  
   1673              [..]  This section provides functions allowing to:
   1674                (+) Configure channels on regular group
   1675                (+) Configure the analog watchdog
   1676                
   1677          @endverbatim
   1678            * @{
   1679            */
   1680          
   1681          /**
   1682            * @brief  Configures the the selected channel to be linked to the regular
   1683            *         group.
   1684            * @note   In case of usage of internal measurement channels:
   1685            *         Vbat/VrefInt/TempSensor.
   1686            *         These internal paths can be be disabled using function 
   1687            *         HAL_ADC_DeInit().
   1688            * @note   Possibility to update parameters on the fly:
   1689            *         This function initializes channel into regular group, following  
   1690            *         calls to this function can be used to reconfigure some parameters 
   1691            *         of structure "ADC_ChannelConfTypeDef" on the fly, without reseting 
   1692            *         the ADC.
   1693            *         The setting of these parameters is conditioned to ADC state.
   1694            *         For parameters constraints, see comments of structure 
   1695            *         "ADC_ChannelConfTypeDef".
   1696            * @param  hadc: ADC handle
   1697            * @param  sConfig: Structure of ADC channel for regular group.
   1698            * @retval HAL status
   1699            */
   1700          HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
   1701          { 
   1702            HAL_StatusTypeDef tmp_hal_status = HAL_OK;
   1703            __IO uint32_t wait_loop_index = 0U;
   1704            
   1705            /* Check the parameters */
   1706            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1707            assert_param(IS_ADC_CHANNEL(sConfig->Channel));
   1708            assert_param(IS_ADC_REGULAR_RANK(sConfig->Rank));
   1709            assert_param(IS_ADC_SAMPLE_TIME(sConfig->SamplingTime));
   1710            
   1711            /* Process locked */
   1712            __HAL_LOCK(hadc);
   1713            
   1714            
   1715            /* Regular sequence configuration */
   1716            /* For Rank 1 to 6 */
   1717            if (sConfig->Rank < 7U)
   1718            {
   1719              MODIFY_REG(hadc->Instance->SQR3                        ,
   1720                         ADC_SQR3_RK(ADC_SQR3_SQ1, sConfig->Rank)    ,
   1721                         ADC_SQR3_RK(sConfig->Channel, sConfig->Rank) );
   1722            }
   1723            /* For Rank 7 to 12 */
   1724            else if (sConfig->Rank < 13U)
   1725            {
   1726              MODIFY_REG(hadc->Instance->SQR2                        ,
   1727                         ADC_SQR2_RK(ADC_SQR2_SQ7, sConfig->Rank)    ,
   1728                         ADC_SQR2_RK(sConfig->Channel, sConfig->Rank) );
   1729            }
   1730            /* For Rank 13 to 16 */
   1731            else
   1732            {
   1733              MODIFY_REG(hadc->Instance->SQR1                        ,
   1734                         ADC_SQR1_RK(ADC_SQR1_SQ13, sConfig->Rank)   ,
   1735                         ADC_SQR1_RK(sConfig->Channel, sConfig->Rank) );
   1736            }
   1737            
   1738            
   1739            /* Channel sampling time configuration */
   1740            /* For channels 10 to 17 */
   1741            if (sConfig->Channel >= ADC_CHANNEL_10)
   1742            {
   1743              MODIFY_REG(hadc->Instance->SMPR1                             ,
   1744                         ADC_SMPR1(ADC_SMPR1_SMP10, sConfig->Channel)      ,
   1745                         ADC_SMPR1(sConfig->SamplingTime, sConfig->Channel) );
   1746            }
   1747            else /* For channels 0 to 9 */
   1748            {
   1749              MODIFY_REG(hadc->Instance->SMPR2                             ,
   1750                         ADC_SMPR2(ADC_SMPR2_SMP0, sConfig->Channel)       ,
   1751                         ADC_SMPR2(sConfig->SamplingTime, sConfig->Channel) );
   1752            }
   1753            
   1754            /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor  */
   1755            /* and VREFINT measurement path.                                            */
   1756            if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) ||
   1757                (sConfig->Channel == ADC_CHANNEL_VREFINT)      )
   1758            {
   1759              /* For STM32F1 devices with several ADC: Only ADC1 can access internal    */
   1760              /* measurement channels (VrefInt/TempSensor). If these channels are       */
   1761              /* intended to be set on other ADC instances, an error is reported.       */
   1762              if (hadc->Instance == ADC1)
   1763              {
   1764                if (READ_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE) == RESET)
   1765                {
   1766                  SET_BIT(hadc->Instance->CR2, ADC_CR2_TSVREFE);
   1767                  
   1768                  if ((sConfig->Channel == ADC_CHANNEL_TEMPSENSOR))
   1769                  {
   1770                    /* Delay for temperature sensor stabilization time */
   1771                    /* Compute number of CPU cycles to wait for */
   1772                    wait_loop_index = (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U));
   1773                    while(wait_loop_index != 0U)
   1774                    {
   1775                      wait_loop_index--;
   1776                    }
   1777                  }
   1778                }
   1779              }
   1780              else
   1781              {
   1782                /* Update ADC state machine to error */
   1783                SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
   1784                
   1785                tmp_hal_status = HAL_ERROR;
   1786              }
   1787            }
   1788            
   1789            /* Process unlocked */
   1790            __HAL_UNLOCK(hadc);
   1791            
   1792            /* Return function status */
   1793            return tmp_hal_status;
   1794          }
   1795          
   1796          /**
   1797            * @brief  Configures the analog watchdog.
   1798            * @note   Analog watchdog thresholds can be modified while ADC conversion
   1799            *         is on going.
   1800            *         In this case, some constraints must be taken into account:
   1801            *         the programmed threshold values are effective from the next
   1802            *         ADC EOC (end of unitary conversion).
   1803            *         Considering that registers write delay may happen due to
   1804            *         bus activity, this might cause an uncertainty on the
   1805            *         effective timing of the new programmed threshold values.
   1806            * @param  hadc: ADC handle
   1807            * @param  AnalogWDGConfig: Structure of ADC analog watchdog configuration
   1808            * @retval HAL status
   1809            */
   1810          HAL_StatusTypeDef HAL_ADC_AnalogWDGConfig(ADC_HandleTypeDef* hadc, ADC_AnalogWDGConfTypeDef* AnalogWDGConfig)
   1811          {
   1812            /* Check the parameters */
   1813            assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
   1814            assert_param(IS_ADC_ANALOG_WATCHDOG_MODE(AnalogWDGConfig->WatchdogMode));
   1815            assert_param(IS_FUNCTIONAL_STATE(AnalogWDGConfig->ITMode));
   1816            assert_param(IS_ADC_RANGE(AnalogWDGConfig->HighThreshold));
   1817            assert_param(IS_ADC_RANGE(AnalogWDGConfig->LowThreshold));
   1818            
   1819            if((AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REG)     ||
   1820               (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_INJEC)   ||
   1821               (AnalogWDGConfig->WatchdogMode == ADC_ANALOGWATCHDOG_SINGLE_REGINJEC)  )
   1822            {
   1823              assert_param(IS_ADC_CHANNEL(AnalogWDGConfig->Channel));
   1824            }
   1825            
   1826            /* Process locked */
   1827            __HAL_LOCK(hadc);
   1828            
   1829            /* Analog watchdog configuration */
   1830          
   1831            /* Configure ADC Analog watchdog interrupt */
   1832            if(AnalogWDGConfig->ITMode == ENABLE)
   1833            {
   1834              /* Enable the ADC Analog watchdog interrupt */
   1835              __HAL_ADC_ENABLE_IT(hadc, ADC_IT_AWD);
   1836            }
   1837            else
   1838            {
   1839              /* Disable the ADC Analog watchdog interrupt */
   1840              __HAL_ADC_DISABLE_IT(hadc, ADC_IT_AWD);
   1841            }
   1842            
   1843            /* Configuration of analog watchdog:                                        */
   1844            /*  - Set the analog watchdog enable mode: regular and/or injected groups,  */
   1845            /*    one or all channels.                                                  */
   1846            /*  - Set the Analog watchdog channel (is not used if watchdog              */
   1847            /*    mode "all channels": ADC_CFGR_AWD1SGL=0).                             */
   1848            MODIFY_REG(hadc->Instance->CR1            ,
   1849                       ADC_CR1_AWDSGL |
   1850                       ADC_CR1_JAWDEN |
   1851                       ADC_CR1_AWDEN  |
   1852                       ADC_CR1_AWDCH                  ,
   1853                       AnalogWDGConfig->WatchdogMode |
   1854                       AnalogWDGConfig->Channel        );
   1855            
   1856            /* Set the high threshold */
   1857            WRITE_REG(hadc->Instance->HTR, AnalogWDGConfig->HighThreshold);
   1858            
   1859            /* Set the low threshold */
   1860            WRITE_REG(hadc->Instance->LTR, AnalogWDGConfig->LowThreshold);
   1861          
   1862            /* Process unlocked */
   1863            __HAL_UNLOCK(hadc);
   1864            
   1865            /* Return function status */
   1866            return HAL_OK;
   1867          }
   1868          
   1869          
   1870          /**
   1871            * @}
   1872            */
   1873          
   1874          
   1875          /** @defgroup ADC_Exported_Functions_Group4 Peripheral State functions
   1876           *  @brief    Peripheral State functions
   1877           *
   1878          @verbatim
   1879           ===============================================================================
   1880                      ##### Peripheral State and Errors functions #####
   1881           ===============================================================================  
   1882              [..]
   1883              This subsection provides functions to get in run-time the status of the  
   1884              peripheral.
   1885                (+) Check the ADC state
   1886                (+) Check the ADC error code
   1887          
   1888          @endverbatim
   1889            * @{
   1890            */
   1891          
   1892          /**
   1893            * @brief  return the ADC state
   1894            * @param  hadc: ADC handle
   1895            * @retval HAL state
   1896            */
   1897          uint32_t HAL_ADC_GetState(ADC_HandleTypeDef* hadc)
   1898          {
   1899            /* Return ADC state */
   1900            return hadc->State;
   1901          }
   1902          
   1903          /**
   1904            * @brief  Return the ADC error code
   1905            * @param  hadc: ADC handle
   1906            * @retval ADC Error Code
   1907            */
   1908          uint32_t HAL_ADC_GetError(ADC_HandleTypeDef *hadc)
   1909          {
   1910            return hadc->ErrorCode;
   1911          }
   1912          
   1913          /**
   1914            * @}
   1915            */
   1916          
   1917          /**
   1918            * @}
   1919            */
   1920          
   1921          /** @defgroup ADC_Private_Functions ADC Private Functions
   1922            * @{
   1923            */
   1924          
   1925          /**
   1926            * @brief  Enable the selected ADC.
   1927            * @note   Prerequisite condition to use this function: ADC must be disabled
   1928            *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
   1929            * @param  hadc: ADC handle
   1930            * @retval HAL status.
   1931            */
   1932          HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
   1933          {
   1934            uint32_t tickstart = 0U;
   1935            __IO uint32_t wait_loop_index = 0U;
   1936            
   1937            /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
   1938            /* enabling phase not yet completed: flag ADC ready not yet set).           */
   1939            /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
   1940            /* causes: ADC clock not running, ...).                                     */
   1941            if (ADC_IS_ENABLE(hadc) == RESET)
   1942            {
   1943              /* Enable the Peripheral */
   1944              __HAL_ADC_ENABLE(hadc);
   1945              
   1946              /* Delay for ADC stabilization time */
   1947              /* Compute number of CPU cycles to wait for */
   1948              wait_loop_index = (ADC_STAB_DELAY_US * (SystemCoreClock / 1000000U));
   1949              while(wait_loop_index != 0U)
   1950              {
   1951                wait_loop_index--;
   1952              }
   1953              
   1954              /* Get tick count */
   1955              tickstart = HAL_GetTick();
   1956          
   1957              /* Wait for ADC effectively enabled */
   1958              while(ADC_IS_ENABLE(hadc) == RESET)
   1959              {
   1960                if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
   1961                {
   1962                  /* Update ADC state machine to error */
   1963                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
   1964                
   1965                  /* Set ADC error code to ADC IP internal error */
   1966                  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   1967                  
   1968                  /* Process unlocked */
   1969                  __HAL_UNLOCK(hadc);
   1970                
   1971                  return HAL_ERROR;
   1972                }
   1973              }
   1974            }
   1975             
   1976            /* Return HAL status */
   1977            return HAL_OK;
   1978          }
   1979          
   1980          /**
   1981            * @brief  Stop ADC conversion and disable the selected ADC
   1982            * @note   Prerequisite condition to use this function: ADC conversions must be
   1983            *         stopped to disable the ADC.
   1984            * @param  hadc: ADC handle
   1985            * @retval HAL status.
   1986            */
   1987          HAL_StatusTypeDef ADC_ConversionStop_Disable(ADC_HandleTypeDef* hadc)
   1988          {
   1989            uint32_t tickstart = 0U;
   1990            
   1991            /* Verification if ADC is not already disabled */
   1992            if (ADC_IS_ENABLE(hadc) != RESET)
   1993            {
   1994              /* Disable the ADC peripheral */
   1995              __HAL_ADC_DISABLE(hadc);
   1996               
   1997              /* Get tick count */
   1998              tickstart = HAL_GetTick();
   1999              
   2000              /* Wait for ADC effectively disabled */
   2001              while(ADC_IS_ENABLE(hadc) != RESET)
   2002              {
   2003                if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
   2004                {
   2005                  /* Update ADC state machine to error */
   2006                  SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
   2007                  
   2008                  /* Set ADC error code to ADC IP internal error */
   2009                  SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
   2010                  
   2011                  return HAL_ERROR;
   2012                }
   2013              }
   2014            }
   2015            
   2016            /* Return HAL status */
   2017            return HAL_OK;
   2018          }
   2019          
   2020          /**
   2021            * @brief  DMA transfer complete callback. 
   2022            * @param  hdma: pointer to DMA handle.
   2023            * @retval None
   2024            */
   2025          void ADC_DMAConvCplt(DMA_HandleTypeDef *hdma)
   2026          {
   2027            /* Retrieve ADC handle corresponding to current DMA handle */
   2028            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2029           
   2030            /* Update state machine on conversion status if not in error state */
   2031            if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL | HAL_ADC_STATE_ERROR_DMA))
   2032            {
   2033              /* Update ADC state machine */
   2034              SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
   2035              
   2036              /* Determine whether any further conversion upcoming on group regular     */
   2037              /* by external trigger, continuous mode or scan sequence on going.        */
   2038              /* Note: On STM32F1 devices, in case of sequencer enabled                 */
   2039              /*       (several ranks selected), end of conversion flag is raised       */
   2040              /*       at the end of the sequence.                                      */
   2041              if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
   2042                 (hadc->Init.ContinuousConvMode == DISABLE)   )
   2043              {
   2044                /* Set ADC state */
   2045                CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);   
   2046                
   2047                if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
   2048                {
   2049                  SET_BIT(hadc->State, HAL_ADC_STATE_READY);
   2050                }
   2051              }
   2052              
   2053              /* Conversion complete callback */
   2054              HAL_ADC_ConvCpltCallback(hadc); 
   2055            }
   2056            else
   2057            {
   2058              /* Call DMA error callback */
   2059              hadc->DMA_Handle->XferErrorCallback(hdma);
   2060            }
   2061          }
   2062          
   2063          /**
   2064            * @brief  DMA half transfer complete callback. 
   2065            * @param  hdma: pointer to DMA handle.
   2066            * @retval None
   2067            */
   2068          void ADC_DMAHalfConvCplt(DMA_HandleTypeDef *hdma)   
   2069          {
   2070            /* Retrieve ADC handle corresponding to current DMA handle */
   2071            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2072            
   2073            /* Half conversion callback */
   2074            HAL_ADC_ConvHalfCpltCallback(hadc); 
   2075          }
   2076          
   2077          /**
   2078            * @brief  DMA error callback 
   2079            * @param  hdma: pointer to DMA handle.
   2080            * @retval None
   2081            */
   2082          void ADC_DMAError(DMA_HandleTypeDef *hdma)   
   2083          {
   2084            /* Retrieve ADC handle corresponding to current DMA handle */
   2085            ADC_HandleTypeDef* hadc = ( ADC_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   2086            
   2087            /* Set ADC state */
   2088            SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_DMA);
   2089            
   2090            /* Set ADC error code to DMA error */
   2091            SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_DMA);
   2092            
   2093            /* Error callback */
   2094            HAL_ADC_ErrorCallback(hadc); 
   2095          }
   2096          
   2097          /**
   2098            * @}
   2099            */
   2100          
   2101          #endif /* HAL_ADC_MODULE_ENABLED */
   2102          /**
   2103            * @}
   2104            */
   2105          
   2106          /**
   2107            * @}
   2108            */
   2109          
   2110          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADC_ConversionStop_Disable
        16   -> HAL_GetTick
      16   ADC_DMAConvCplt
        16   -- Indirect call
        16   -> HAL_ADC_ConvCpltCallback
      16   ADC_DMAError
        16   -> HAL_ADC_ErrorCallback
      16   ADC_DMAHalfConvCplt
        16   -> HAL_ADC_ConvHalfCpltCallback
      16   ADC_Enable
        16   -> HAL_GetTick
       0   HAL_ADC_AnalogWDGConfig
      16   HAL_ADC_ConfigChannel
       0   HAL_ADC_ConvCpltCallback
       0   HAL_ADC_ConvHalfCpltCallback
      16   HAL_ADC_DeInit
        16   -> ADC_ConversionStop_Disable
        16   -> HAL_ADC_MspDeInit
       0   HAL_ADC_ErrorCallback
       0   HAL_ADC_GetError
       0   HAL_ADC_GetState
       0   HAL_ADC_GetValue
       8   HAL_ADC_IRQHandler
         8   -> HAL_ADCEx_InjectedConvCpltCallback
         8   -> HAL_ADC_ConvCpltCallback
         8   -> HAL_ADC_LevelOutOfWindowCallback
      24   HAL_ADC_Init
        24   -> ADC_ConversionStop_Disable
        24   -> HAL_ADC_MspInit
       0   HAL_ADC_LevelOutOfWindowCallback
       0   HAL_ADC_MspDeInit
       0   HAL_ADC_MspInit
      32   HAL_ADC_PollForConversion
        32   -> HAL_GetTick
        32   -> HAL_RCCEx_GetPeriphCLKFreq
      24   HAL_ADC_PollForEvent
        24   -> HAL_GetTick
      16   HAL_ADC_Start
        16   -> ADC_Enable
      32   HAL_ADC_Start_DMA
        32   -> ADC_Enable
        32   -> HAL_DMA_Start_IT
      16   HAL_ADC_Start_IT
        16   -> ADC_Enable
      16   HAL_ADC_Stop
        16   -> ADC_ConversionStop_Disable
      16   HAL_ADC_Stop_DMA
        16   -> ADC_ConversionStop_Disable
        16   -> HAL_DMA_Abort
      16   HAL_ADC_Stop_IT
        16   -> ADC_ConversionStop_Disable


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_12
       4  ??DataTable8_13
       4  ??DataTable8_14
       4  ??DataTable8_15
       4  ??DataTable8_16
       4  ??DataTable8_17
       4  ??DataTable8_18
       4  ??DataTable8_19
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      74  ADC_ConversionStop_Disable
      82  ADC_DMAConvCplt
      30  ADC_DMAError
      14  ADC_DMAHalfConvCplt
     110  ADC_Enable
     118  HAL_ADC_AnalogWDGConfig
     338  HAL_ADC_ConfigChannel
       2  HAL_ADC_ConvCpltCallback
       2  HAL_ADC_ConvHalfCpltCallback
     268  HAL_ADC_DeInit
       2  HAL_ADC_ErrorCallback
       4  HAL_ADC_GetError
       4  HAL_ADC_GetState
       6  HAL_ADC_GetValue
     262  HAL_ADC_IRQHandler
     324  HAL_ADC_Init
       2  HAL_ADC_LevelOutOfWindowCallback
       2  HAL_ADC_MspDeInit
       2  HAL_ADC_MspInit
     354  HAL_ADC_PollForConversion
      90  HAL_ADC_PollForEvent
     290  HAL_ADC_Start
     368  HAL_ADC_Start_DMA
     304  HAL_ADC_Start_IT
      60  HAL_ADC_Stop
     102  HAL_ADC_Stop_DMA
      72  HAL_ADC_Stop_IT

 
 3'366 bytes in section .text
 
 3'354 bytes of CODE memory (+ 12 bytes shared)

Errors: none
Warnings: none
