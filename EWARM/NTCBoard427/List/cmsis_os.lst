###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         06/Sep/2019  23:26:44
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\cmsis_os.c
#    Command line =
#        -f C:\Users\ilkorea\AppData\Local\Temp\EW7C52.tmp
#        (D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\cmsis_os.c
#        -D USE_HAL_DRIVER -D STM32F103xB -lc
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\List
#        -o
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Inc\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/SEGGER\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/FreeRTOSV9\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/FreeRTOSV9/Config\
#        -On -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\List\cmsis_os.lst
#    Object file  =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\Obj\cmsis_os.o
#
###############################################################################

D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Middlewares\Third_Party\FreeRTOS\Source\CMSIS_RTOS\cmsis_os.c
      1          /* ----------------------------------------------------------------------
      2           * $Date:        5. February 2013
      3           * $Revision:    V1.02
      4           *
      5           * Project:      CMSIS-RTOS API
      6           * Title:        cmsis_os.c
      7           *
      8           * Version 0.02
      9           *    Initial Proposal Phase
     10           * Version 0.03
     11           *    osKernelStart added, optional feature: main started as thread
     12           *    osSemaphores have standard behavior
     13           *    osTimerCreate does not start the timer, added osTimerStart
     14           *    osThreadPass is renamed to osThreadYield
     15           * Version 1.01
     16           *    Support for C++ interface
     17           *     - const attribute removed from the osXxxxDef_t typedef's
     18           *     - const attribute added to the osXxxxDef macros
     19           *    Added: osTimerDelete, osMutexDelete, osSemaphoreDelete
     20           *    Added: osKernelInitialize
     21           * Version 1.02
     22           *    Control functions for short timeouts in microsecond resolution:
     23           *    Added: osKernelSysTick, osKernelSysTickFrequency, osKernelSysTickMicroSec
     24           *    Removed: osSignalGet 
     25           *    
     26           *  
     27           *----------------------------------------------------------------------------
     28           *
     29           * Portions Copyright © 2016 STMicroelectronics International N.V. All rights reserved.
     30           * Portions Copyright (c) 2013 ARM LIMITED
     31           * All rights reserved.
     32           * Redistribution and use in source and binary forms, with or without
     33           * modification, are permitted provided that the following conditions are met:
     34           *  - Redistributions of source code must retain the above copyright
     35           *    notice, this list of conditions and the following disclaimer.
     36           *  - Redistributions in binary form must reproduce the above copyright
     37           *    notice, this list of conditions and the following disclaimer in the
     38           *    documentation and/or other materials provided with the distribution.
     39           *  - Neither the name of ARM  nor the names of its contributors may be used
     40           *    to endorse or promote products derived from this software without
     41           *    specific prior written permission.
     42           *
     43           * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     44           * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     45           * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
     46           * ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
     47           * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
     48           * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
     49           * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
     50           * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
     51           * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
     52           * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
     53           * POSSIBILITY OF SUCH DAMAGE.
     54           *---------------------------------------------------------------------------*/
     55          
     56           /**
     57            ******************************************************************************
     58            * @file    cmsis_os.c
     59            * @author  MCD Application Team
     60            * @date    03-March-2017
     61            * @brief   CMSIS-RTOS API implementation for FreeRTOS V9.0.0
     62            ******************************************************************************
     63            * @attention
     64            *
     65            * Redistribution and use in source and binary forms, with or without 
     66            * modification, are permitted, provided that the following conditions are met:
     67            *
     68            * 1. Redistribution of source code must retain the above copyright notice, 
     69            *    this list of conditions and the following disclaimer.
     70            * 2. Redistributions in binary form must reproduce the above copyright notice,
     71            *    this list of conditions and the following disclaimer in the documentation
     72            *    and/or other materials provided with the distribution.
     73            * 3. Neither the name of STMicroelectronics nor the names of other 
     74            *    contributors to this software may be used to endorse or promote products 
     75            *    derived from this software without specific written permission.
     76            * 4. This software, including modifications and/or derivative works of this 
     77            *    software, must execute solely and exclusively on microcontroller or
     78            *    microprocessor devices manufactured by or for STMicroelectronics.
     79            * 5. Redistribution and use of this software other than as permitted under 
     80            *    this license is void and will automatically terminate your rights under 
     81            *    this license. 
     82            *
     83            * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS" 
     84            * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT 
     85            * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
     86            * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
     87            * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT 
     88            * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
     89            * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     90            * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
     91            * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
     92            * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
     93            * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     94            * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     95            *
     96            ******************************************************************************
     97            */ 
     98          
     99          #include <string.h>
    100          #include "cmsis_os.h"
    101          
    102          /*
    103           * ARM Compiler 4/5
    104           */
    105          #if   defined ( __CC_ARM )
    106          
    107            #define __ASM            __asm                                      
    108            #define __INLINE         __inline                                     
    109            #define __STATIC_INLINE  static __inline
    110            #include "cmsis_armcc.h"
    111          
    112          /*
    113           * GNU Compiler
    114           */
    115          #elif defined ( __GNUC__ )
    116          
    117            #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
    118            #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
    119            #define __STATIC_INLINE  static inline
    120          
    121          
    122            #include "cmsis_gcc.h"
    123          
    124          
    125          /*
    126           * IAR Compiler
    127           */
    128          #elif defined ( __ICCARM__ )
    129          
    130            #ifndef   __ASM
    131              #define __ASM                     __asm
    132            #endif
    133            #ifndef   __INLINE
    134              #define __INLINE                  inline
    135            #endif
    136            #ifndef   __STATIC_INLINE
    137              #define __STATIC_INLINE           static inline
    138            #endif
    139          
    140            #include <cmsis_iar.h>
    141          #endif
    142          
    143          extern void xPortSysTickHandler(void);
    144          
    145          /* Convert from CMSIS type osPriority to FreeRTOS priority number */
    146          static unsigned portBASE_TYPE makeFreeRtosPriority (osPriority priority)
    147          {
    148            unsigned portBASE_TYPE fpriority = tskIDLE_PRIORITY;
    149            
    150            if (priority != osPriorityError) {
    151              fpriority += (priority - osPriorityIdle);
    152            }
    153            
    154            return fpriority;
    155          }
    156          
    157          #if (INCLUDE_uxTaskPriorityGet == 1)
    158          /* Convert from FreeRTOS priority number to CMSIS type osPriority */
    159          static osPriority makeCmsisPriority (unsigned portBASE_TYPE fpriority)
    160          {
    161            osPriority priority = osPriorityError;
    162            
    163            if ((fpriority - tskIDLE_PRIORITY) <= (osPriorityRealtime - osPriorityIdle)) {
    164              priority = (osPriority)((int)osPriorityIdle + (int)(fpriority - tskIDLE_PRIORITY));
    165            }
    166            
    167            return priority;
    168          }
    169          #endif
    170          
    171          
    172          /* Determine whether we are in thread mode or handler mode. */
    173          static int inHandlerMode (void)
    174          {
    175            return __get_IPSR() != 0;
    176          }
    177          
    178          /*********************** Kernel Control Functions *****************************/
    179          /**
    180          * @brief  Initialize the RTOS Kernel for creating objects.
    181          * @retval status code that indicates the execution status of the function.
    182          * @note   MUST REMAIN UNCHANGED: \b osKernelInitialize shall be consistent in every CMSIS-RTOS.
    183          */
    184          osStatus osKernelInitialize (void);
    185          
    186          /**
    187          * @brief  Start the RTOS Kernel with executing the specified thread.
    188          * @param  thread_def    thread definition referenced with \ref osThread.
    189          * @param  argument      pointer that is passed to the thread function as start argument.
    190          * @retval status code that indicates the execution status of the function
    191          * @note   MUST REMAIN UNCHANGED: \b osKernelStart shall be consistent in every CMSIS-RTOS.
    192          */
    193          osStatus osKernelStart (void)
    194          {
    195            vTaskStartScheduler();
    196            
    197            return osOK;
    198          }
    199          
    200          /**
    201          * @brief  Check if the RTOS kernel is already started
    202          * @param  None
    203          * @retval (0) RTOS is not started
    204          *         (1) RTOS is started
    205          *         (-1) if this feature is disabled in FreeRTOSConfig.h 
    206          * @note  MUST REMAIN UNCHANGED: \b osKernelRunning shall be consistent in every CMSIS-RTOS.
    207          */
    208          int32_t osKernelRunning(void)
    209          {
    210          #if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
    211            if (xTaskGetSchedulerState() == taskSCHEDULER_NOT_STARTED)
    212              return 0;
    213            else
    214              return 1;
    215          #else
    216          	return (-1);
    217          #endif	
    218          }
    219          
    220          #if (defined (osFeature_SysTick)  &&  (osFeature_SysTick != 0))     // System Timer available
    221          /**
    222          * @brief  Get the value of the Kernel SysTick timer
    223          * @param  None
    224          * @retval None
    225          * @note   MUST REMAIN UNCHANGED: \b osKernelSysTick shall be consistent in every CMSIS-RTOS.
    226          */
    227          uint32_t osKernelSysTick(void)
    228          {
    229            if (inHandlerMode()) {
    230              return xTaskGetTickCountFromISR();
    231            }
    232            else {
    233              return xTaskGetTickCount();
    234            }
    235          }
    236          #endif    // System Timer available
    237          /*********************** Thread Management *****************************/
    238          /**
    239          * @brief  Create a thread and add it to Active Threads and set it to state READY.
    240          * @param  thread_def    thread definition referenced with \ref osThread.
    241          * @param  argument      pointer that is passed to the thread function as start argument.
    242          * @retval thread ID for reference by other functions or NULL in case of error.
    243          * @note   MUST REMAIN UNCHANGED: \b osThreadCreate shall be consistent in every CMSIS-RTOS.
    244          */
    245          osThreadId osThreadCreate (const osThreadDef_t *thread_def, void *argument)
    246          {
    247            TaskHandle_t handle;
    248            
    249          #if( configSUPPORT_STATIC_ALLOCATION == 1 ) &&  ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    250            if((thread_def->buffer != NULL) && (thread_def->controlblock != NULL)) {
    251              handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
    252                        thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
    253                        thread_def->buffer, thread_def->controlblock);
    254            }
    255            else {
    256              if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
    257                        thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
    258                        &handle) != pdPASS)  {
    259                return NULL;
    260              } 
    261            }
    262          #elif( configSUPPORT_STATIC_ALLOCATION == 1 )
    263          
    264              handle = xTaskCreateStatic((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
    265                        thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
    266                        thread_def->buffer, thread_def->controlblock);
    267          #else
    268            if (xTaskCreate((TaskFunction_t)thread_def->pthread,(const portCHAR *)thread_def->name,
    269                             thread_def->stacksize, argument, makeFreeRtosPriority(thread_def->tpriority),
    270                             &handle) != pdPASS)  {
    271              return NULL;
    272            }     
    273          #endif
    274            
    275            return handle;
    276          }
    277          
    278          /**
    279          * @brief  Return the thread ID of the current running thread.
    280          * @retval thread ID for reference by other functions or NULL in case of error.
    281          * @note   MUST REMAIN UNCHANGED: \b osThreadGetId shall be consistent in every CMSIS-RTOS.
    282          */
    283          osThreadId osThreadGetId (void)
    284          {
    285          #if ( ( INCLUDE_xTaskGetCurrentTaskHandle == 1 ) || ( configUSE_MUTEXES == 1 ) )
    286            return xTaskGetCurrentTaskHandle();
    287          #else
    288          	return NULL;
    289          #endif
    290          }
    291          
    292          /**
    293          * @brief  Terminate execution of a thread and remove it from Active Threads.
    294          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    295          * @retval  status code that indicates the execution status of the function.
    296          * @note   MUST REMAIN UNCHANGED: \b osThreadTerminate shall be consistent in every CMSIS-RTOS.
    297          */
    298          osStatus osThreadTerminate (osThreadId thread_id)
    299          {
    300          #if (INCLUDE_vTaskDelete == 1)
    301            vTaskDelete(thread_id);
    302            return osOK;
    303          #else
    304            return osErrorOS;
    305          #endif
    306          }
    307          
    308          /**
    309          * @brief  Pass control to next thread that is in state \b READY.
    310          * @retval status code that indicates the execution status of the function.
    311          * @note   MUST REMAIN UNCHANGED: \b osThreadYield shall be consistent in every CMSIS-RTOS.
    312          */
    313          osStatus osThreadYield (void)
    314          {
    315            taskYIELD();
    316            
    317            return osOK;
    318          }
    319          
    320          /**
    321          * @brief   Change priority of an active thread.
    322          * @param   thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    323          * @param   priority      new priority value for the thread function.
    324          * @retval  status code that indicates the execution status of the function.
    325          * @note   MUST REMAIN UNCHANGED: \b osThreadSetPriority shall be consistent in every CMSIS-RTOS.
    326          */
    327          osStatus osThreadSetPriority (osThreadId thread_id, osPriority priority)
    328          {
    329          #if (INCLUDE_vTaskPrioritySet == 1)
    330            vTaskPrioritySet(thread_id, makeFreeRtosPriority(priority));
    331            return osOK;
    332          #else
    333            return osErrorOS;
    334          #endif
    335          }
    336          
    337          /**
    338          * @brief   Get current priority of an active thread.
    339          * @param   thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    340          * @retval  current priority value of the thread function.
    341          * @note   MUST REMAIN UNCHANGED: \b osThreadGetPriority shall be consistent in every CMSIS-RTOS.
    342          */
    343          osPriority osThreadGetPriority (osThreadId thread_id)
    344          {
    345          #if (INCLUDE_uxTaskPriorityGet == 1)
    346            if (inHandlerMode())
    347            {
    348              return makeCmsisPriority(uxTaskPriorityGetFromISR(thread_id));  
    349            }
    350            else
    351            {  
    352              return makeCmsisPriority(uxTaskPriorityGet(thread_id));
    353            }
    354          #else
    355            return osPriorityError;
    356          #endif
    357          }
    358          
    359          /*********************** Generic Wait Functions *******************************/
    360          /**
    361          * @brief   Wait for Timeout (Time Delay)
    362          * @param   millisec      time delay value
    363          * @retval  status code that indicates the execution status of the function.
    364          */
    365          osStatus osDelay (uint32_t millisec)
    366          {
    367          #if INCLUDE_vTaskDelay
    368            TickType_t ticks = millisec / portTICK_PERIOD_MS;
    369            
    370            vTaskDelay(ticks ? ticks : 1);          /* Minimum delay = 1 tick */
    371            
    372            return osOK;
    373          #else
    374            (void) millisec;
    375            
    376            return osErrorResource;
    377          #endif
    378          }
    379          
    380          #if (defined (osFeature_Wait)  &&  (osFeature_Wait != 0)) /* Generic Wait available */
    381          /**
    382          * @brief  Wait for Signal, Message, Mail, or Timeout
    383          * @param   millisec  timeout value or 0 in case of no time-out
    384          * @retval  event that contains signal, message, or mail information or error code.
    385          * @note   MUST REMAIN UNCHANGED: \b osWait shall be consistent in every CMSIS-RTOS.
    386          */
    387          osEvent osWait (uint32_t millisec);
    388          
    389          #endif  /* Generic Wait available */
    390          
    391          /***********************  Timer Management Functions ***************************/
    392          /**
    393          * @brief  Create a timer.
    394          * @param  timer_def     timer object referenced with \ref osTimer.
    395          * @param  type          osTimerOnce for one-shot or osTimerPeriodic for periodic behavior.
    396          * @param  argument      argument to the timer call back function.
    397          * @retval  timer ID for reference by other functions or NULL in case of error.
    398          * @note   MUST REMAIN UNCHANGED: \b osTimerCreate shall be consistent in every CMSIS-RTOS.
    399          */
    400          osTimerId osTimerCreate (const osTimerDef_t *timer_def, os_timer_type type, void *argument)
    401          {
    402          #if (configUSE_TIMERS == 1)
    403          
    404          #if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) 
    405            if(timer_def->controlblock != NULL) {
    406              return xTimerCreateStatic((const char *)"",
    407                                1, // period should be filled when starting the Timer using osTimerStart
    408                                (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
    409                                (void *) argument,
    410                                (TaskFunction_t)timer_def->ptimer,
    411                                (StaticTimer_t *)timer_def->controlblock);
    412            }
    413            else {
    414              return xTimerCreate((const char *)"",
    415                                1, // period should be filled when starting the Timer using osTimerStart
    416                                (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
    417                                (void *) argument,
    418                                (TaskFunction_t)timer_def->ptimer);
    419           }
    420          #elif( configSUPPORT_STATIC_ALLOCATION == 1 )
    421            return xTimerCreateStatic((const char *)"",
    422                                1, // period should be filled when starting the Timer using osTimerStart
    423                                (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
    424                                (void *) argument,
    425                                (TaskFunction_t)timer_def->ptimer,
    426                                (StaticTimer_t *)timer_def->controlblock);  
    427          #else
    428            return xTimerCreate((const char *)"",
    429                                1, // period should be filled when starting the Timer using osTimerStart
    430                                (type == osTimerPeriodic) ? pdTRUE : pdFALSE,
    431                                (void *) argument,
    432                                (TaskFunction_t)timer_def->ptimer);
    433          #endif
    434          
    435          #else 
    436          	return NULL;
    437          #endif
    438          }
    439          
    440          /**
    441          * @brief  Start or restart a timer.
    442          * @param  timer_id      timer ID obtained by \ref osTimerCreate.
    443          * @param  millisec      time delay value of the timer.
    444          * @retval  status code that indicates the execution status of the function
    445          * @note   MUST REMAIN UNCHANGED: \b osTimerStart shall be consistent in every CMSIS-RTOS.
    446          */
    447          osStatus osTimerStart (osTimerId timer_id, uint32_t millisec)
    448          {
    449            osStatus result = osOK;
    450          #if (configUSE_TIMERS == 1)  
    451            portBASE_TYPE taskWoken = pdFALSE;
    452            TickType_t ticks = millisec / portTICK_PERIOD_MS;
    453          
    454            if (ticks == 0)
    455              ticks = 1;
    456              
    457            if (inHandlerMode()) 
    458            {
    459              if (xTimerChangePeriodFromISR(timer_id, ticks, &taskWoken) != pdPASS)
    460              {
    461                result = osErrorOS;
    462              }
    463              else
    464              {
    465                portEND_SWITCHING_ISR(taskWoken);     
    466              }
    467            }
    468            else 
    469            {
    470              if (xTimerChangePeriod(timer_id, ticks, 0) != pdPASS)
    471                result = osErrorOS;
    472            }
    473          
    474          #else 
    475            result = osErrorOS;
    476          #endif
    477            return result;
    478          }
    479          
    480          /**
    481          * @brief  Stop a timer.
    482          * @param  timer_id      timer ID obtained by \ref osTimerCreate
    483          * @retval  status code that indicates the execution status of the function.
    484          * @note   MUST REMAIN UNCHANGED: \b osTimerStop shall be consistent in every CMSIS-RTOS.
    485          */
    486          osStatus osTimerStop (osTimerId timer_id)
    487          {
    488            osStatus result = osOK;
    489          #if (configUSE_TIMERS == 1)  
    490            portBASE_TYPE taskWoken = pdFALSE;
    491          
    492            if (inHandlerMode()) {
    493              if (xTimerStopFromISR(timer_id, &taskWoken) != pdPASS) {
    494                return osErrorOS;
    495              }
    496              portEND_SWITCHING_ISR(taskWoken);
    497            }
    498            else {
    499              if (xTimerStop(timer_id, 0) != pdPASS) {
    500                result = osErrorOS;
    501              }
    502            }
    503          #else 
    504            result = osErrorOS;
    505          #endif 
    506            return result;
    507          }
    508          
    509          /**
    510          * @brief  Delete a timer.
    511          * @param  timer_id      timer ID obtained by \ref osTimerCreate
    512          * @retval  status code that indicates the execution status of the function.
    513          * @note   MUST REMAIN UNCHANGED: \b osTimerDelete shall be consistent in every CMSIS-RTOS.
    514          */
    515          osStatus osTimerDelete (osTimerId timer_id)
    516          {
    517          osStatus result = osOK;
    518          
    519          #if (configUSE_TIMERS == 1)
    520          
    521             if (inHandlerMode()) {
    522               return osErrorISR;
    523            }
    524            else { 
    525              if ((xTimerDelete(timer_id, osWaitForever )) != pdPASS) {
    526                result = osErrorOS;
    527              }
    528            } 
    529              
    530          #else 
    531            result = osErrorOS;
    532          #endif 
    533           
    534            return result;
    535          }
    536          
    537          /***************************  Signal Management ********************************/
    538          /**
    539          * @brief  Set the specified Signal Flags of an active thread.
    540          * @param  thread_id     thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    541          * @param  signals       specifies the signal flags of the thread that should be set.
    542          * @retval previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
    543          * @note   MUST REMAIN UNCHANGED: \b osSignalSet shall be consistent in every CMSIS-RTOS.
    544          */
    545          int32_t osSignalSet (osThreadId thread_id, int32_t signal)
    546          {
    547          #if( configUSE_TASK_NOTIFICATIONS == 1 )	
    548            BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    549            uint32_t ulPreviousNotificationValue = 0;
    550            
    551            if (inHandlerMode())
    552            {
    553              if(xTaskGenericNotifyFromISR( thread_id , (uint32_t)signal, eSetBits, &ulPreviousNotificationValue, &xHigherPriorityTaskWoken ) != pdPASS )
    554                return 0x80000000;
    555              
    556              portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
    557            }  
    558            else if(xTaskGenericNotify( thread_id , (uint32_t)signal, eSetBits, &ulPreviousNotificationValue) != pdPASS )
    559              return 0x80000000;
    560            
    561            return ulPreviousNotificationValue;
    562          #else
    563            (void) thread_id;
    564            (void) signal;
    565          
    566            return 0x80000000; /* Task Notification not supported */ 	
    567          #endif
    568          }
    569          
    570          /**
    571          * @brief  Clear the specified Signal Flags of an active thread.
    572          * @param  thread_id  thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
    573          * @param  signals    specifies the signal flags of the thread that shall be cleared.
    574          * @retval  previous signal flags of the specified thread or 0x80000000 in case of incorrect parameters.
    575          * @note   MUST REMAIN UNCHANGED: \b osSignalClear shall be consistent in every CMSIS-RTOS.
    576          */
    577          int32_t osSignalClear (osThreadId thread_id, int32_t signal);
    578          
    579          /**
    580          * @brief  Wait for one or more Signal Flags to become signaled for the current \b RUNNING thread.
    581          * @param  signals   wait until all specified signal flags set or 0 for any single signal flag.
    582          * @param  millisec  timeout value or 0 in case of no time-out.
    583          * @retval  event flag information or error code.
    584          * @note   MUST REMAIN UNCHANGED: \b osSignalWait shall be consistent in every CMSIS-RTOS.
    585          */
    586          osEvent osSignalWait (int32_t signals, uint32_t millisec)
    587          {
    588            osEvent ret;
    589          
    590          #if( configUSE_TASK_NOTIFICATIONS == 1 )
    591          	
    592            TickType_t ticks;
    593          
    594            ret.value.signals = 0;  
    595            ticks = 0;
    596            if (millisec == osWaitForever) {
    597              ticks = portMAX_DELAY;
    598            }
    599            else if (millisec != 0) {
    600              ticks = millisec / portTICK_PERIOD_MS;
    601              if (ticks == 0) {
    602                ticks = 1;
    603              }
    604            }  
    605            
    606            if (inHandlerMode())
    607            {
    608              ret.status = osErrorISR;  /*Not allowed in ISR*/
    609            }
    610            else
    611            {
    612              if(xTaskNotifyWait( 0,(uint32_t) signals, (uint32_t *)&ret.value.signals, ticks) != pdTRUE)
    613              {
    614                if(ticks == 0)  ret.status = osOK;
    615                else  ret.status = osEventTimeout;
    616              }
    617              else if(ret.value.signals < 0)
    618              {
    619                ret.status =  osErrorValue;     
    620              }
    621              else  ret.status =  osEventSignal;
    622            }
    623          #else
    624            (void) signals;
    625            (void) millisec;
    626          	
    627            ret.status =  osErrorOS;	/* Task Notification not supported */
    628          #endif
    629            
    630            return ret;
    631          }
    632          
    633          /****************************  Mutex Management ********************************/
    634          /**
    635          * @brief  Create and Initialize a Mutex object
    636          * @param  mutex_def     mutex definition referenced with \ref osMutex.
    637          * @retval  mutex ID for reference by other functions or NULL in case of error.
    638          * @note   MUST REMAIN UNCHANGED: \b osMutexCreate shall be consistent in every CMSIS-RTOS.
    639          */
    640          osMutexId osMutexCreate (const osMutexDef_t *mutex_def)
    641          {
    642          #if ( configUSE_MUTEXES == 1)
    643          
    644          #if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    645          
    646            if (mutex_def->controlblock != NULL) {
    647              return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
    648               }
    649            else {
    650              return xSemaphoreCreateMutex(); 
    651            }
    652          #elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
    653            return xSemaphoreCreateMutexStatic( mutex_def->controlblock );
    654          #else  
    655              return xSemaphoreCreateMutex(); 
    656          #endif
    657          #else
    658            return NULL;
    659          #endif
    660          }
    661          
    662          /**
    663          * @brief Wait until a Mutex becomes available
    664          * @param mutex_id      mutex ID obtained by \ref osMutexCreate.
    665          * @param millisec      timeout value or 0 in case of no time-out.
    666          * @retval  status code that indicates the execution status of the function.
    667          * @note   MUST REMAIN UNCHANGED: \b osMutexWait shall be consistent in every CMSIS-RTOS.
    668          */
    669          osStatus osMutexWait (osMutexId mutex_id, uint32_t millisec)
    670          {
    671            TickType_t ticks;
    672            portBASE_TYPE taskWoken = pdFALSE;  
    673            
    674            
    675            if (mutex_id == NULL) {
    676              return osErrorParameter;
    677            }
    678            
    679            ticks = 0;
    680            if (millisec == osWaitForever) {
    681              ticks = portMAX_DELAY;
    682            }
    683            else if (millisec != 0) {
    684              ticks = millisec / portTICK_PERIOD_MS;
    685              if (ticks == 0) {
    686                ticks = 1;
    687              }
    688            }
    689            
    690            if (inHandlerMode()) {
    691              if (xSemaphoreTakeFromISR(mutex_id, &taskWoken) != pdTRUE) {
    692                return osErrorOS;
    693              }
    694          	portEND_SWITCHING_ISR(taskWoken);
    695            } 
    696            else if (xSemaphoreTake(mutex_id, ticks) != pdTRUE) {
    697              return osErrorOS;
    698            }
    699            
    700            return osOK;
    701          }
    702          
    703          /**
    704          * @brief Release a Mutex that was obtained by \ref osMutexWait
    705          * @param mutex_id      mutex ID obtained by \ref osMutexCreate.
    706          * @retval  status code that indicates the execution status of the function.
    707          * @note   MUST REMAIN UNCHANGED: \b osMutexRelease shall be consistent in every CMSIS-RTOS.
    708          */
    709          osStatus osMutexRelease (osMutexId mutex_id)
    710          {
    711            osStatus result = osOK;
    712            portBASE_TYPE taskWoken = pdFALSE;
    713            
    714            if (inHandlerMode()) {
    715              if (xSemaphoreGiveFromISR(mutex_id, &taskWoken) != pdTRUE) {
    716                return osErrorOS;
    717              }
    718              portEND_SWITCHING_ISR(taskWoken);
    719            }
    720            else if (xSemaphoreGive(mutex_id) != pdTRUE) 
    721            {
    722              result = osErrorOS;
    723            }
    724            return result;
    725          }
    726          
    727          /**
    728          * @brief Delete a Mutex
    729          * @param mutex_id  mutex ID obtained by \ref osMutexCreate.
    730          * @retval  status code that indicates the execution status of the function.
    731          * @note   MUST REMAIN UNCHANGED: \b osMutexDelete shall be consistent in every CMSIS-RTOS.
    732          */
    733          osStatus osMutexDelete (osMutexId mutex_id)
    734          {
    735            if (inHandlerMode()) {
    736              return osErrorISR;
    737            }
    738          
    739            vQueueDelete(mutex_id);
    740          
    741            return osOK;
    742          }
    743          
    744          /********************  Semaphore Management Functions **************************/
    745          
    746          #if (defined (osFeature_Semaphore)  &&  (osFeature_Semaphore != 0))
    747          
    748          /**
    749          * @brief Create and Initialize a Semaphore object used for managing resources
    750          * @param semaphore_def semaphore definition referenced with \ref osSemaphore.
    751          * @param count         number of available resources.
    752          * @retval  semaphore ID for reference by other functions or NULL in case of error.
    753          * @note   MUST REMAIN UNCHANGED: \b osSemaphoreCreate shall be consistent in every CMSIS-RTOS.
    754          */
    755          osSemaphoreId osSemaphoreCreate (const osSemaphoreDef_t *semaphore_def, int32_t count)
    756          { 
    757          #if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
    758          
    759            osSemaphoreId sema;
    760            
    761            if (semaphore_def->controlblock != NULL){
    762              if (count == 1) {
    763                return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
    764              }
    765              else {
    766          #if (configUSE_COUNTING_SEMAPHORES == 1 )
    767                return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );
    768          #else
    769                return NULL;
    770          #endif
    771              }
    772            }
    773            else {
    774              if (count == 1) {
    775                vSemaphoreCreateBinary(sema);
    776                return sema;
    777              }
    778              else {
    779          #if (configUSE_COUNTING_SEMAPHORES == 1 )	
    780                return xSemaphoreCreateCounting(count, count);
    781          #else
    782                return NULL;
    783          #endif    
    784              }
    785            }
    786          #elif ( configSUPPORT_STATIC_ALLOCATION == 1 ) // configSUPPORT_DYNAMIC_ALLOCATION == 0
    787            if(count == 1) {
    788              return xSemaphoreCreateBinaryStatic( semaphore_def->controlblock );
    789            }
    790            else
    791            {
    792          #if (configUSE_COUNTING_SEMAPHORES == 1 )
    793                return xSemaphoreCreateCountingStatic( count, count, semaphore_def->controlblock );
    794          #else
    795                return NULL;
    796          #endif    
    797            }
    798          #else  // configSUPPORT_STATIC_ALLOCATION == 0  && configSUPPORT_DYNAMIC_ALLOCATION == 1
    799            osSemaphoreId sema;
    800           
    801            if (count == 1) {
    802              vSemaphoreCreateBinary(sema);
    803              return sema;
    804            }
    805            else {
    806          #if (configUSE_COUNTING_SEMAPHORES == 1 )	
    807              return xSemaphoreCreateCounting(count, count);
    808          #else
    809              return NULL;
    810          #endif
    811            }
    812          #endif
    813          }
    814          
    815          /**
    816          * @brief Wait until a Semaphore token becomes available
    817          * @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
    818          * @param  millisec      timeout value or 0 in case of no time-out.
    819          * @retval  number of available tokens, or -1 in case of incorrect parameters.
    820          * @note   MUST REMAIN UNCHANGED: \b osSemaphoreWait shall be consistent in every CMSIS-RTOS.
    821          */
    822          int32_t osSemaphoreWait (osSemaphoreId semaphore_id, uint32_t millisec)
    823          {
    824            TickType_t ticks;
    825            portBASE_TYPE taskWoken = pdFALSE;  
    826            
    827            
    828            if (semaphore_id == NULL) {
    829              return osErrorParameter;
    830            }
    831            
    832            ticks = 0;
    833            if (millisec == osWaitForever) {
    834              ticks = portMAX_DELAY;
    835            }
    836            else if (millisec != 0) {
    837              ticks = millisec / portTICK_PERIOD_MS;
    838              if (ticks == 0) {
    839                ticks = 1;
    840              }
    841            }
    842            
    843            if (inHandlerMode()) {
    844              if (xSemaphoreTakeFromISR(semaphore_id, &taskWoken) != pdTRUE) {
    845                return osErrorOS;
    846              }
    847          	portEND_SWITCHING_ISR(taskWoken);
    848            }  
    849            else if (xSemaphoreTake(semaphore_id, ticks) != pdTRUE) {
    850              return osErrorOS;
    851            }
    852            
    853            return osOK;
    854          }
    855          
    856          /**
    857          * @brief Release a Semaphore token
    858          * @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
    859          * @retval  status code that indicates the execution status of the function.
    860          * @note   MUST REMAIN UNCHANGED: \b osSemaphoreRelease shall be consistent in every CMSIS-RTOS.
    861          */
    862          osStatus osSemaphoreRelease (osSemaphoreId semaphore_id)
    863          {
    864            osStatus result = osOK;
    865            portBASE_TYPE taskWoken = pdFALSE;
    866            
    867            
    868            if (inHandlerMode()) {
    869              if (xSemaphoreGiveFromISR(semaphore_id, &taskWoken) != pdTRUE) {
    870                return osErrorOS;
    871              }
    872              portEND_SWITCHING_ISR(taskWoken);
    873            }
    874            else {
    875              if (xSemaphoreGive(semaphore_id) != pdTRUE) {
    876                result = osErrorOS;
    877              }
    878            }
    879            
    880            return result;
    881          }
    882          
    883          /**
    884          * @brief Delete a Semaphore
    885          * @param  semaphore_id  semaphore object referenced with \ref osSemaphore.
    886          * @retval  status code that indicates the execution status of the function.
    887          * @note   MUST REMAIN UNCHANGED: \b osSemaphoreDelete shall be consistent in every CMSIS-RTOS.
    888          */
    889          osStatus osSemaphoreDelete (osSemaphoreId semaphore_id)
    890          {
    891            if (inHandlerMode()) {
    892              return osErrorISR;
    893            }
    894          
    895            vSemaphoreDelete(semaphore_id);
    896          
    897            return osOK; 
    898          }
    899          
    900          #endif    /* Use Semaphores */
    901          
    902          /*******************   Memory Pool Management Functions  ***********************/
    903          
    904          #if (defined (osFeature_Pool)  &&  (osFeature_Pool != 0)) 
    905          
    906          //TODO
    907          //This is a primitive and inefficient wrapper around the existing FreeRTOS memory management.
    908          //A better implementation will have to modify heap_x.c!
    909          
    910          
    911          typedef struct os_pool_cb {
    912            void *pool;
    913            uint8_t *markers;
    914            uint32_t pool_sz;
    915            uint32_t item_sz;
    916            uint32_t currentIndex;
    917          } os_pool_cb_t;
    918          
    919          
    920          /**
    921          * @brief Create and Initialize a memory pool
    922          * @param  pool_def      memory pool definition referenced with \ref osPool.
    923          * @retval  memory pool ID for reference by other functions or NULL in case of error.
    924          * @note   MUST REMAIN UNCHANGED: \b osPoolCreate shall be consistent in every CMSIS-RTOS.
    925          */
    926          osPoolId osPoolCreate (const osPoolDef_t *pool_def)
    927          {
    928          #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
    929            osPoolId thePool;
    930            int itemSize = 4 * ((pool_def->item_sz + 3) / 4);
    931            uint32_t i;
    932            
    933            /* First have to allocate memory for the pool control block. */
    934           thePool = pvPortMalloc(sizeof(os_pool_cb_t));
    935          
    936            
    937            if (thePool) {
    938              thePool->pool_sz = pool_def->pool_sz;
    939              thePool->item_sz = itemSize;
    940              thePool->currentIndex = 0;
    941              
    942              /* Memory for markers */
    943              thePool->markers = pvPortMalloc(pool_def->pool_sz);
    944             
    945              if (thePool->markers) {
    946                /* Now allocate the pool itself. */
    947               thePool->pool = pvPortMalloc(pool_def->pool_sz * itemSize);
    948                
    949                if (thePool->pool) {
    950                  for (i = 0; i < pool_def->pool_sz; i++) {
    951                    thePool->markers[i] = 0;
    952                  }
    953                }
    954                else {
    955                  vPortFree(thePool->markers);
    956                  vPortFree(thePool);
    957                  thePool = NULL;
    958                }
    959              }
    960              else {
    961                vPortFree(thePool);
    962                thePool = NULL;
    963              }
    964            }
    965          
    966            return thePool;
    967           
    968          #else
    969            return NULL;
    970          #endif
    971          }
    972          
    973          /**
    974          * @brief Allocate a memory block from a memory pool
    975          * @param pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
    976          * @retval  address of the allocated memory block or NULL in case of no memory available.
    977          * @note   MUST REMAIN UNCHANGED: \b osPoolAlloc shall be consistent in every CMSIS-RTOS.
    978          */
    979          void *osPoolAlloc (osPoolId pool_id)
    980          {
    981            int dummy = 0;
    982            void *p = NULL;
    983            uint32_t i;
    984            uint32_t index;
    985            
    986            if (inHandlerMode()) {
    987              dummy = portSET_INTERRUPT_MASK_FROM_ISR();
    988            }
    989            else {
    990              vPortEnterCritical();
    991            }
    992            
    993            for (i = 0; i < pool_id->pool_sz; i++) {
    994              index = pool_id->currentIndex + i;
    995              if (index >= pool_id->pool_sz) {
    996                index = 0;
    997              }
    998              
    999              if (pool_id->markers[index] == 0) {
   1000                pool_id->markers[index] = 1;
   1001                p = (void *)((uint32_t)(pool_id->pool) + (index * pool_id->item_sz));
   1002                pool_id->currentIndex = index;
   1003                break;
   1004              }
   1005            }
   1006            
   1007            if (inHandlerMode()) {
   1008              portCLEAR_INTERRUPT_MASK_FROM_ISR(dummy);
   1009            }
   1010            else {
   1011              vPortExitCritical();
   1012            }
   1013            
   1014            return p;
   1015          }
   1016          
   1017          /**
   1018          * @brief Allocate a memory block from a memory pool and set memory block to zero
   1019          * @param  pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
   1020          * @retval  address of the allocated memory block or NULL in case of no memory available.
   1021          * @note   MUST REMAIN UNCHANGED: \b osPoolCAlloc shall be consistent in every CMSIS-RTOS.
   1022          */
   1023          void *osPoolCAlloc (osPoolId pool_id)
   1024          {
   1025            void *p = osPoolAlloc(pool_id);
   1026            
   1027            if (p != NULL)
   1028            {
   1029              memset(p, 0, sizeof(pool_id->pool_sz));
   1030            }
   1031            
   1032            return p;
   1033          }
   1034          
   1035          /**
   1036          * @brief Return an allocated memory block back to a specific memory pool
   1037          * @param  pool_id       memory pool ID obtain referenced with \ref osPoolCreate.
   1038          * @param  block         address of the allocated memory block that is returned to the memory pool.
   1039          * @retval  status code that indicates the execution status of the function.
   1040          * @note   MUST REMAIN UNCHANGED: \b osPoolFree shall be consistent in every CMSIS-RTOS.
   1041          */
   1042          osStatus osPoolFree (osPoolId pool_id, void *block)
   1043          {
   1044            uint32_t index;
   1045            
   1046            if (pool_id == NULL) {
   1047              return osErrorParameter;
   1048            }
   1049            
   1050            if (block == NULL) {
   1051              return osErrorParameter;
   1052            }
   1053            
   1054            if (block < pool_id->pool) {
   1055              return osErrorParameter;
   1056            }
   1057            
   1058            index = (uint32_t)block - (uint32_t)(pool_id->pool);
   1059            if (index % pool_id->item_sz) {
   1060              return osErrorParameter;
   1061            }
   1062            index = index / pool_id->item_sz;
   1063            if (index >= pool_id->pool_sz) {
   1064              return osErrorParameter;
   1065            }
   1066            
   1067            pool_id->markers[index] = 0;
   1068            
   1069            return osOK;
   1070          }
   1071          
   1072          
   1073          #endif   /* Use Memory Pool Management */
   1074          
   1075          /*******************   Message Queue Management Functions  *********************/
   1076          
   1077          #if (defined (osFeature_MessageQ)  &&  (osFeature_MessageQ != 0)) /* Use Message Queues */
   1078          
   1079          /**
   1080          * @brief Create and Initialize a Message Queue
   1081          * @param queue_def     queue definition referenced with \ref osMessageQ.
   1082          * @param  thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
   1083          * @retval  message queue ID for reference by other functions or NULL in case of error.
   1084          * @note   MUST REMAIN UNCHANGED: \b osMessageCreate shall be consistent in every CMSIS-RTOS.
   1085          */
   1086          osMessageQId osMessageCreate (const osMessageQDef_t *queue_def, osThreadId thread_id)
   1087          {
   1088            (void) thread_id;
   1089            
   1090          #if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
   1091          
   1092            if ((queue_def->buffer != NULL) && (queue_def->controlblock != NULL)) {
   1093              return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
   1094            }
   1095            else {
   1096              return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
   1097            }
   1098          #elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
   1099            return xQueueCreateStatic(queue_def->queue_sz, queue_def->item_sz, queue_def->buffer, queue_def->controlblock);
   1100          #else  
   1101            return xQueueCreate(queue_def->queue_sz, queue_def->item_sz);
   1102          #endif
   1103          }
   1104          
   1105          /**
   1106          * @brief Put a Message to a Queue.
   1107          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
   1108          * @param  info      message information.
   1109          * @param  millisec  timeout value or 0 in case of no time-out.
   1110          * @retval status code that indicates the execution status of the function.
   1111          * @note   MUST REMAIN UNCHANGED: \b osMessagePut shall be consistent in every CMSIS-RTOS.
   1112          */
   1113          osStatus osMessagePut (osMessageQId queue_id, uint32_t info, uint32_t millisec)
   1114          {
   1115            portBASE_TYPE taskWoken = pdFALSE;
   1116            TickType_t ticks;
   1117            
   1118            ticks = millisec / portTICK_PERIOD_MS;
   1119            if (ticks == 0) {
   1120              ticks = 1;
   1121            }
   1122            
   1123            if (inHandlerMode()) {
   1124              if (xQueueSendFromISR(queue_id, &info, &taskWoken) != pdTRUE) {
   1125                return osErrorOS;
   1126              }
   1127              portEND_SWITCHING_ISR(taskWoken);
   1128            }
   1129            else {
   1130              if (xQueueSend(queue_id, &info, ticks) != pdTRUE) {
   1131                return osErrorOS;
   1132              }
   1133            }
   1134            
   1135            return osOK;
   1136          }
   1137          
   1138          /**
   1139          * @brief Get a Message or Wait for a Message from a Queue.
   1140          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
   1141          * @param  millisec  timeout value or 0 in case of no time-out.
   1142          * @retval event information that includes status code.
   1143          * @note   MUST REMAIN UNCHANGED: \b osMessageGet shall be consistent in every CMSIS-RTOS.
   1144          */
   1145          osEvent osMessageGet (osMessageQId queue_id, uint32_t millisec)
   1146          {
   1147            portBASE_TYPE taskWoken;
   1148            TickType_t ticks;
   1149            osEvent event;
   1150            
   1151            event.def.message_id = queue_id;
   1152            event.value.v = 0;
   1153            
   1154            if (queue_id == NULL) {
   1155              event.status = osErrorParameter;
   1156              return event;
   1157            }
   1158            
   1159            taskWoken = pdFALSE;
   1160            
   1161            ticks = 0;
   1162            if (millisec == osWaitForever) {
   1163              ticks = portMAX_DELAY;
   1164            }
   1165            else if (millisec != 0) {
   1166              ticks = millisec / portTICK_PERIOD_MS;
   1167              if (ticks == 0) {
   1168                ticks = 1;
   1169              }
   1170            }
   1171            
   1172            if (inHandlerMode()) {
   1173              if (xQueueReceiveFromISR(queue_id, &event.value.v, &taskWoken) == pdTRUE) {
   1174                /* We have mail */
   1175                event.status = osEventMessage;
   1176              }
   1177              else {
   1178                event.status = osOK;
   1179              }
   1180              portEND_SWITCHING_ISR(taskWoken);
   1181            }
   1182            else {
   1183              if (xQueueReceive(queue_id, &event.value.v, ticks) == pdTRUE) {
   1184                /* We have mail */
   1185                event.status = osEventMessage;
   1186              }
   1187              else {
   1188                event.status = (ticks == 0) ? osOK : osEventTimeout;
   1189              }
   1190            }
   1191            
   1192            return event;
   1193          }
   1194          
   1195          #endif     /* Use Message Queues */
   1196          
   1197          /********************   Mail Queue Management Functions  ***********************/
   1198          #if (defined (osFeature_MailQ)  &&  (osFeature_MailQ != 0))  /* Use Mail Queues */
   1199          
   1200          
   1201          typedef struct os_mailQ_cb {
   1202            const osMailQDef_t *queue_def;
   1203            QueueHandle_t handle;
   1204            osPoolId pool;
   1205          } os_mailQ_cb_t;
   1206          
   1207          /**
   1208          * @brief Create and Initialize mail queue
   1209          * @param  queue_def     reference to the mail queue definition obtain with \ref osMailQ
   1210          * @param   thread_id     thread ID (obtained by \ref osThreadCreate or \ref osThreadGetId) or NULL.
   1211          * @retval mail queue ID for reference by other functions or NULL in case of error.
   1212          * @note   MUST REMAIN UNCHANGED: \b osMailCreate shall be consistent in every CMSIS-RTOS.
   1213          */
   1214          osMailQId osMailCreate (const osMailQDef_t *queue_def, osThreadId thread_id)
   1215          {
   1216          #if (configSUPPORT_DYNAMIC_ALLOCATION == 1)
   1217            (void) thread_id;
   1218            
   1219            osPoolDef_t pool_def = {queue_def->queue_sz, queue_def->item_sz, NULL};
   1220            
   1221            /* Create a mail queue control block */
   1222          
   1223            *(queue_def->cb) = pvPortMalloc(sizeof(struct os_mailQ_cb));
   1224          
   1225            if (*(queue_def->cb) == NULL) {
   1226              return NULL;
   1227            }
   1228            (*(queue_def->cb))->queue_def = queue_def;
   1229            
   1230            /* Create a queue in FreeRTOS */
   1231            (*(queue_def->cb))->handle = xQueueCreate(queue_def->queue_sz, sizeof(void *));
   1232          
   1233          
   1234            if ((*(queue_def->cb))->handle == NULL) {
   1235              vPortFree(*(queue_def->cb));
   1236              return NULL;
   1237            }
   1238            
   1239            /* Create a mail pool */
   1240            (*(queue_def->cb))->pool = osPoolCreate(&pool_def);
   1241            if ((*(queue_def->cb))->pool == NULL) {
   1242              //TODO: Delete queue. How to do it in FreeRTOS?
   1243              vPortFree(*(queue_def->cb));
   1244              return NULL;
   1245            }
   1246            
   1247            return *(queue_def->cb);
   1248          #else
   1249            return NULL;
   1250          #endif
   1251          }
   1252          
   1253          /**
   1254          * @brief Allocate a memory block from a mail
   1255          * @param  queue_id      mail queue ID obtained with \ref osMailCreate.
   1256          * @param  millisec      timeout value or 0 in case of no time-out.
   1257          * @retval pointer to memory block that can be filled with mail or NULL in case error.
   1258          * @note   MUST REMAIN UNCHANGED: \b osMailAlloc shall be consistent in every CMSIS-RTOS.
   1259          */
   1260          void *osMailAlloc (osMailQId queue_id, uint32_t millisec)
   1261          {
   1262            (void) millisec;
   1263            void *p;
   1264            
   1265            
   1266            if (queue_id == NULL) {
   1267              return NULL;
   1268            }
   1269            
   1270            p = osPoolAlloc(queue_id->pool);
   1271            
   1272            return p;
   1273          }
   1274          
   1275          /**
   1276          * @brief Allocate a memory block from a mail and set memory block to zero
   1277          * @param  queue_id      mail queue ID obtained with \ref osMailCreate.
   1278          * @param  millisec      timeout value or 0 in case of no time-out.
   1279          * @retval pointer to memory block that can be filled with mail or NULL in case error.
   1280          * @note   MUST REMAIN UNCHANGED: \b osMailCAlloc shall be consistent in every CMSIS-RTOS.
   1281          */
   1282          void *osMailCAlloc (osMailQId queue_id, uint32_t millisec)
   1283          {
   1284            uint32_t i;
   1285            void *p = osMailAlloc(queue_id, millisec);
   1286            
   1287            if (p) {
   1288              for (i = 0; i < queue_id->queue_def->item_sz; i++) {
   1289                ((uint8_t *)p)[i] = 0;
   1290              }
   1291            }
   1292            
   1293            return p;
   1294          }
   1295          
   1296          /**
   1297          * @brief Put a mail to a queue
   1298          * @param  queue_id      mail queue ID obtained with \ref osMailCreate.
   1299          * @param  mail          memory block previously allocated with \ref osMailAlloc or \ref osMailCAlloc.
   1300          * @retval status code that indicates the execution status of the function.
   1301          * @note   MUST REMAIN UNCHANGED: \b osMailPut shall be consistent in every CMSIS-RTOS.
   1302          */
   1303          osStatus osMailPut (osMailQId queue_id, void *mail)
   1304          {
   1305            portBASE_TYPE taskWoken;
   1306            
   1307            
   1308            if (queue_id == NULL) {
   1309              return osErrorParameter;
   1310            }
   1311            
   1312            taskWoken = pdFALSE;
   1313            
   1314            if (inHandlerMode()) {
   1315              if (xQueueSendFromISR(queue_id->handle, &mail, &taskWoken) != pdTRUE) {
   1316                return osErrorOS;
   1317              }
   1318              portEND_SWITCHING_ISR(taskWoken);
   1319            }
   1320            else {
   1321              if (xQueueSend(queue_id->handle, &mail, 0) != pdTRUE) { 
   1322                return osErrorOS;
   1323              }
   1324            }
   1325            
   1326            return osOK;
   1327          }
   1328          
   1329          /**
   1330          * @brief Get a mail from a queue
   1331          * @param  queue_id   mail queue ID obtained with \ref osMailCreate.
   1332          * @param millisec    timeout value or 0 in case of no time-out
   1333          * @retval event that contains mail information or error code.
   1334          * @note   MUST REMAIN UNCHANGED: \b osMailGet shall be consistent in every CMSIS-RTOS.
   1335          */
   1336          osEvent osMailGet (osMailQId queue_id, uint32_t millisec)
   1337          {
   1338            portBASE_TYPE taskWoken;
   1339            TickType_t ticks;
   1340            osEvent event;
   1341            
   1342            event.def.mail_id = queue_id;
   1343            
   1344            if (queue_id == NULL) {
   1345              event.status = osErrorParameter;
   1346              return event;
   1347            }
   1348            
   1349            taskWoken = pdFALSE;
   1350            
   1351            ticks = 0;
   1352            if (millisec == osWaitForever) {
   1353              ticks = portMAX_DELAY;
   1354            }
   1355            else if (millisec != 0) {
   1356              ticks = millisec / portTICK_PERIOD_MS;
   1357              if (ticks == 0) {
   1358                ticks = 1;
   1359              }
   1360            }
   1361            
   1362            if (inHandlerMode()) {
   1363              if (xQueueReceiveFromISR(queue_id->handle, &event.value.p, &taskWoken) == pdTRUE) {
   1364                /* We have mail */
   1365                event.status = osEventMail;
   1366              }
   1367              else {
   1368                event.status = osOK;
   1369              }
   1370              portEND_SWITCHING_ISR(taskWoken);
   1371            }
   1372            else {
   1373              if (xQueueReceive(queue_id->handle, &event.value.p, ticks) == pdTRUE) {
   1374                /* We have mail */
   1375                event.status = osEventMail;
   1376              }
   1377              else {
   1378                event.status = (ticks == 0) ? osOK : osEventTimeout;
   1379              }
   1380            }
   1381            
   1382            return event;
   1383          }
   1384          
   1385          /**
   1386          * @brief Free a memory block from a mail
   1387          * @param  queue_id mail queue ID obtained with \ref osMailCreate.
   1388          * @param  mail     pointer to the memory block that was obtained with \ref osMailGet.
   1389          * @retval status code that indicates the execution status of the function.
   1390          * @note   MUST REMAIN UNCHANGED: \b osMailFree shall be consistent in every CMSIS-RTOS.
   1391          */
   1392          osStatus osMailFree (osMailQId queue_id, void *mail)
   1393          {
   1394            if (queue_id == NULL) {
   1395              return osErrorParameter;
   1396            }
   1397            
   1398            return osPoolFree(queue_id->pool, mail);
   1399          }
   1400          #endif  /* Use Mail Queues */
   1401          
   1402          /*************************** Additional specific APIs to Free RTOS ************/
   1403          /**
   1404          * @brief  Handles the tick increment
   1405          * @param  none.
   1406          * @retval none.
   1407          */
   1408          void osSystickHandler(void)
   1409          {
   1410          
   1411          #if (INCLUDE_xTaskGetSchedulerState  == 1 )
   1412            if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
   1413            {
   1414          #endif  /* INCLUDE_xTaskGetSchedulerState */  
   1415              xPortSysTickHandler();
   1416          #if (INCLUDE_xTaskGetSchedulerState  == 1 )
   1417            }
   1418          #endif  /* INCLUDE_xTaskGetSchedulerState */  
   1419          }
   1420          
   1421          #if ( INCLUDE_eTaskGetState == 1 )
   1422          /**
   1423          * @brief  Obtain the state of any thread.
   1424          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
   1425          * @retval  the stae of the thread, states are encoded by the osThreadState enumerated type.
   1426          */
   1427          osThreadState osThreadGetState(osThreadId thread_id)
   1428          {
   1429            eTaskState ThreadState;
   1430            osThreadState result;
   1431            
   1432            ThreadState = eTaskGetState(thread_id);
   1433            
   1434            switch (ThreadState)
   1435            {
   1436            case eRunning :
   1437              result = osThreadRunning;
   1438              break;
   1439            case eReady :
   1440              result = osThreadReady;
   1441              break;
   1442            case eBlocked :
   1443              result = osThreadBlocked;
   1444              break;
   1445            case eSuspended :
   1446              result = osThreadSuspended;
   1447              break;
   1448            case eDeleted :
   1449              result = osThreadDeleted;
   1450              break;
   1451            default:
   1452              result = osThreadError;
   1453            } 
   1454            
   1455            return result;
   1456          }
   1457          #endif /* INCLUDE_eTaskGetState */
   1458          
   1459          #if (INCLUDE_eTaskGetState == 1)
   1460          /**
   1461          * @brief Check if a thread is already suspended or not.
   1462          * @param thread_id thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
   1463          * @retval status code that indicates the execution status of the function.
   1464          */
   1465          osStatus osThreadIsSuspended(osThreadId thread_id)
   1466          {
   1467            if (eTaskGetState(thread_id) == eSuspended)
   1468              return osOK;
   1469            else
   1470              return osErrorOS;
   1471          }
   1472          #endif /* INCLUDE_eTaskGetState */
   1473          /**
   1474          * @brief  Suspend execution of a thread.
   1475          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
   1476          * @retval  status code that indicates the execution status of the function.
   1477          */
   1478          osStatus osThreadSuspend (osThreadId thread_id)
   1479          {
   1480          #if (INCLUDE_vTaskSuspend == 1)
   1481              vTaskSuspend(thread_id);
   1482            
   1483            return osOK;
   1484          #else
   1485            return osErrorResource;
   1486          #endif
   1487          }
   1488          
   1489          /**
   1490          * @brief  Resume execution of a suspended thread.
   1491          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId.
   1492          * @retval  status code that indicates the execution status of the function.
   1493          */
   1494          osStatus osThreadResume (osThreadId thread_id)
   1495          {
   1496          #if (INCLUDE_vTaskSuspend == 1)  
   1497            if(inHandlerMode())
   1498            {
   1499              if (xTaskResumeFromISR(thread_id) == pdTRUE)
   1500              {
   1501                portYIELD_FROM_ISR(pdTRUE);
   1502              }
   1503            }
   1504            else
   1505            {
   1506              vTaskResume(thread_id);
   1507            }
   1508            return osOK;
   1509          #else
   1510            return osErrorResource;
   1511          #endif
   1512          }
   1513          
   1514          /**
   1515          * @brief  Suspend execution of a all active threads.
   1516          * @retval  status code that indicates the execution status of the function.
   1517          */
   1518          osStatus osThreadSuspendAll (void)
   1519          {
   1520            vTaskSuspendAll();
   1521            
   1522            return osOK;
   1523          }
   1524          
   1525          /**
   1526          * @brief  Resume execution of a all suspended threads.
   1527          * @retval  status code that indicates the execution status of the function.
   1528          */
   1529          osStatus osThreadResumeAll (void)
   1530          {
   1531            if (xTaskResumeAll() == pdTRUE)
   1532              return osOK;
   1533            else
   1534              return osErrorOS;
   1535            
   1536          }
   1537          
   1538          /**
   1539          * @brief  Delay a task until a specified time
   1540          * @param   PreviousWakeTime   Pointer to a variable that holds the time at which the 
   1541          *          task was last unblocked. PreviousWakeTime must be initialised with the current time
   1542          *          prior to its first use (PreviousWakeTime = osKernelSysTick() )
   1543          * @param   millisec    time delay value
   1544          * @retval  status code that indicates the execution status of the function.
   1545          */
   1546          osStatus osDelayUntil (uint32_t *PreviousWakeTime, uint32_t millisec)
   1547          {
   1548          #if INCLUDE_vTaskDelayUntil
   1549            TickType_t ticks = (millisec / portTICK_PERIOD_MS);
   1550            vTaskDelayUntil((TickType_t *) PreviousWakeTime, ticks ? ticks : 1);
   1551            
   1552            return osOK;
   1553          #else
   1554            (void) millisec;
   1555            (void) PreviousWakeTime;
   1556            
   1557            return osErrorResource;
   1558          #endif
   1559          }
   1560          
   1561          /**
   1562          * @brief   Abort the delay for a specific thread
   1563          * @param   thread_id   thread ID obtained by \ref osThreadCreate or \ref osThreadGetId   
   1564          * @retval  status code that indicates the execution status of the function.
   1565          */
   1566          osStatus osAbortDelay(osThreadId thread_id)
   1567          {
   1568          #if INCLUDE_xTaskAbortDelay
   1569            
   1570            xTaskAbortDelay(thread_id);
   1571            
   1572            return osOK;
   1573          #else
   1574            (void) thread_id;
   1575            
   1576            return osErrorResource;
   1577          #endif
   1578          }
   1579          
   1580          /**
   1581          * @brief   Lists all the current threads, along with their current state 
   1582          *          and stack usage high water mark.
   1583          * @param   buffer   A buffer into which the above mentioned details
   1584          *          will be written
   1585          * @retval  status code that indicates the execution status of the function.
   1586          */
   1587          osStatus osThreadList (uint8_t *buffer)
   1588          {
   1589          #if ( ( configUSE_TRACE_FACILITY == 1 ) && ( configUSE_STATS_FORMATTING_FUNCTIONS == 1 ) )
   1590            vTaskList((char *)buffer);
   1591          #endif
   1592            return osOK;
   1593          }
   1594          
   1595          /**
   1596          * @brief  Receive an item from a queue without removing the item from the queue.
   1597          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
   1598          * @param  millisec  timeout value or 0 in case of no time-out.
   1599          * @retval event information that includes status code.
   1600          */
   1601          osEvent osMessagePeek (osMessageQId queue_id, uint32_t millisec)
   1602          {
   1603            TickType_t ticks;
   1604            osEvent event;
   1605            
   1606            event.def.message_id = queue_id;
   1607            
   1608            if (queue_id == NULL) {
   1609              event.status = osErrorParameter;
   1610              return event;
   1611            }
   1612            
   1613            ticks = 0;
   1614            if (millisec == osWaitForever) {
   1615              ticks = portMAX_DELAY;
   1616            }
   1617            else if (millisec != 0) {
   1618              ticks = millisec / portTICK_PERIOD_MS;
   1619              if (ticks == 0) {
   1620                ticks = 1;
   1621              }
   1622            }
   1623            
   1624            if (xQueuePeek(queue_id, &event.value.v, ticks) == pdTRUE) 
   1625            {
   1626              /* We have mail */
   1627              event.status = osEventMessage;
   1628            }
   1629            else 
   1630            {
   1631              event.status = (ticks == 0) ? osOK : osEventTimeout;
   1632            }
   1633            
   1634            return event;
   1635          }
   1636          
   1637          /**
   1638          * @brief  Get the number of messaged stored in a queue.
   1639          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
   1640          * @retval number of messages stored in a queue.
   1641          */
   1642          uint32_t osMessageWaiting(osMessageQId queue_id)
   1643          {
   1644            if (inHandlerMode()) {
   1645              return uxQueueMessagesWaitingFromISR(queue_id);
   1646            }
   1647            else
   1648            {
   1649              return uxQueueMessagesWaiting(queue_id);
   1650            }
   1651          }
   1652          
   1653          /**
   1654          * @brief  Get the available space in a message queue.
   1655          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
   1656          * @retval available space in a message queue.
   1657          */
   1658          uint32_t osMessageAvailableSpace(osMessageQId queue_id)  
   1659          {
   1660            return uxQueueSpacesAvailable(queue_id);
   1661          }
   1662          
   1663          /**
   1664          * @brief Delete a Message Queue
   1665          * @param  queue_id  message queue ID obtained with \ref osMessageCreate.
   1666          * @retval  status code that indicates the execution status of the function.
   1667          */
   1668          osStatus osMessageDelete (osMessageQId queue_id)
   1669          {
   1670            if (inHandlerMode()) {
   1671              return osErrorISR;
   1672            }
   1673          
   1674            vQueueDelete(queue_id);
   1675          
   1676            return osOK; 
   1677          }
   1678          
   1679          /**
   1680          * @brief  Create and Initialize a Recursive Mutex
   1681          * @param  mutex_def     mutex definition referenced with \ref osMutex.
   1682          * @retval  mutex ID for reference by other functions or NULL in case of error..
   1683          */
   1684          osMutexId osRecursiveMutexCreate (const osMutexDef_t *mutex_def)
   1685          {
   1686          #if (configUSE_RECURSIVE_MUTEXES == 1)
   1687          #if( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
   1688          
   1689            if (mutex_def->controlblock != NULL){
   1690              return xSemaphoreCreateRecursiveMutexStatic( mutex_def->controlblock );
   1691            }
   1692            else {
   1693              return xSemaphoreCreateRecursiveMutex();
   1694            }
   1695          #elif ( configSUPPORT_STATIC_ALLOCATION == 1 )
   1696            return xSemaphoreCreateRecursiveMutexStatic( mutex_def->controlblock );
   1697          #else 
   1698            return xSemaphoreCreateRecursiveMutex();
   1699          #endif
   1700          #else
   1701            return NULL;
   1702          #endif	
   1703          }
   1704          
   1705          /**
   1706          * @brief  Release a Recursive Mutex
   1707          * @param   mutex_id      mutex ID obtained by \ref osRecursiveMutexCreate.
   1708          * @retval  status code that indicates the execution status of the function.
   1709          */
   1710          osStatus osRecursiveMutexRelease (osMutexId mutex_id)
   1711          {
   1712          #if (configUSE_RECURSIVE_MUTEXES == 1)
   1713            osStatus result = osOK;
   1714           
   1715            if (xSemaphoreGiveRecursive(mutex_id) != pdTRUE) 
   1716            {
   1717              result = osErrorOS;
   1718            }
   1719            return result;
   1720          #else
   1721          	return osErrorResource;
   1722          #endif
   1723          }
   1724          
   1725          /**
   1726          * @brief  Release a Recursive Mutex
   1727          * @param   mutex_id    mutex ID obtained by \ref osRecursiveMutexCreate.
   1728          * @param millisec      timeout value or 0 in case of no time-out.
   1729          * @retval  status code that indicates the execution status of the function.
   1730          */
   1731          osStatus osRecursiveMutexWait (osMutexId mutex_id, uint32_t millisec)
   1732          {
   1733          #if (configUSE_RECURSIVE_MUTEXES == 1)
   1734            TickType_t ticks;
   1735            
   1736            if (mutex_id == NULL)
   1737            {
   1738              return osErrorParameter;
   1739            }
   1740            
   1741            ticks = 0;
   1742            if (millisec == osWaitForever) 
   1743            {
   1744              ticks = portMAX_DELAY;
   1745            }
   1746            else if (millisec != 0) 
   1747            {
   1748              ticks = millisec / portTICK_PERIOD_MS;
   1749              if (ticks == 0) 
   1750              {
   1751                ticks = 1;
   1752              }
   1753            }
   1754            
   1755            if (xSemaphoreTakeRecursive(mutex_id, ticks) != pdTRUE) 
   1756            {
   1757              return osErrorOS;
   1758            }
   1759            return osOK;
   1760          #else
   1761          	return osErrorResource;
   1762          #endif
   1763          }
   1764          
   1765          /**
   1766          * @brief  Returns the current count value of a counting semaphore
   1767          * @param  semaphore_id  semaphore_id ID obtained by \ref osSemaphoreCreate.
   1768          * @retval  count value
   1769          */
   1770          uint32_t osSemaphoreGetCount(osSemaphoreId semaphore_id)
   1771          {
   1772            return uxSemaphoreGetCount(semaphore_id);
   1773          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   inHandlerMode
       0   makeCmsisPriority
       0   makeFreeRtosPriority
       0   osAbortDelay
      16   osDelay
        16   -> vTaskDelay
      16   osDelayUntil
        16   -> vTaskDelayUntil
       8   osKernelRunning
         8   -> xTaskGetSchedulerState
       8   osKernelStart
         8   -> vTaskStartScheduler
       8   osKernelSysTick
         8   -> inHandlerMode
         8   -> xTaskGetTickCount
         8   -> xTaskGetTickCountFromISR
      16   osMailAlloc
        16   -> osPoolAlloc
      16   osMailCAlloc
        16   -> osMailAlloc
      24   osMailCreate
        24   -> osPoolCreate
        24   -> pvPortMalloc
        24   -> vPortFree
        24   -> xQueueGenericCreate
      16   osMailFree
        16   -> osPoolFree
      40   osMailGet
        40   -> inHandlerMode
        40   -> xQueueGenericReceive
        40   -> xQueueReceiveFromISR
      16   osMailPut
        16   -> inHandlerMode
        16   -> xQueueGenericSend
        16   -> xQueueGenericSendFromISR
       8   osMessageAvailableSpace
         8   -> uxQueueSpacesAvailable
      16   osMessageCreate
        16   -> xQueueGenericCreate
       8   osMessageDelete
         8   -> inHandlerMode
         8   -> vQueueDelete
      40   osMessageGet
        40   -> inHandlerMode
        40   -> xQueueGenericReceive
        40   -> xQueueReceiveFromISR
      32   osMessagePeek
        32   -> xQueueGenericReceive
      24   osMessagePut
        24   -> inHandlerMode
        24   -> xQueueGenericSend
        24   -> xQueueGenericSendFromISR
       8   osMessageWaiting
         8   -> inHandlerMode
         8   -> uxQueueMessagesWaiting
         8   -> uxQueueMessagesWaitingFromISR
       8   osMutexCreate
         8   -> xQueueCreateMutex
       8   osMutexDelete
         8   -> inHandlerMode
         8   -> vQueueDelete
      16   osMutexRelease
        16   -> inHandlerMode
        16   -> xQueueGenericSend
        16   -> xQueueGiveFromISR
      24   osMutexWait
        24   -> inHandlerMode
        24   -> xQueueGenericReceive
        24   -> xQueueReceiveFromISR
      24   osPoolAlloc
        24   -> inHandlerMode
        24   -> vPortEnterCritical
        24   -> vPortExitCritical
      24   osPoolCAlloc
        24   -> __aeabi_memset
        24   -> osPoolAlloc
      24   osPoolCreate
        24   -> pvPortMalloc
        24   -> vPortFree
       4   osPoolFree
       0   osRecursiveMutexCreate
       0   osRecursiveMutexRelease
       0   osRecursiveMutexWait
      16   osSemaphoreCreate
        16   -> xQueueCreateCountingSemaphore
        16   -> xQueueGenericCreate
        16   -> xQueueGenericSend
       8   osSemaphoreDelete
         8   -> inHandlerMode
         8   -> vQueueDelete
       8   osSemaphoreGetCount
         8   -> uxQueueMessagesWaiting
      16   osSemaphoreRelease
        16   -> inHandlerMode
        16   -> xQueueGenericSend
        16   -> xQueueGiveFromISR
      24   osSemaphoreWait
        24   -> inHandlerMode
        24   -> xQueueGenericReceive
        24   -> xQueueReceiveFromISR
      24   osSignalSet
        24   -> inHandlerMode
        24   -> xTaskGenericNotify
        24   -> xTaskGenericNotifyFromISR
      32   osSignalWait
        32   -> inHandlerMode
        32   -> xTaskNotifyWait
       8   osSystickHandler
         8   -> SysTick_Handler
         8   -> xTaskGetSchedulerState
      24   osThreadCreate
        24   -> makeFreeRtosPriority
        24   -> xTaskCreate
       8   osThreadGetId
         8   -> xTaskGetCurrentTaskHandle
       8   osThreadGetPriority
         8   -> inHandlerMode
         8   -> makeCmsisPriority
         8   -> uxTaskPriorityGet
         8   -> uxTaskPriorityGetFromISR
       0   osThreadList
       8   osThreadResume
         8   -> inHandlerMode
         8   -> vTaskResume
         8   -> xTaskResumeFromISR
       8   osThreadResumeAll
         8   -> xTaskResumeAll
      16   osThreadSetPriority
        16   -> makeFreeRtosPriority
        16   -> vTaskPrioritySet
       8   osThreadSuspend
         8   -> vTaskSuspend
       8   osThreadSuspendAll
         8   -> vTaskSuspendAll
       8   osThreadTerminate
         8   -> vTaskDelete
       0   osThreadYield
       0   osTimerCreate
       0   osTimerDelete
       0   osTimerStart
       0   osTimerStop


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
      12  ?_0
      18  inHandlerMode
      18  makeCmsisPriority
      22  makeFreeRtosPriority
       6  osAbortDelay
      28  osDelay
      32  osDelayUntil
      18  osKernelRunning
      10  osKernelStart
      22  osKernelSysTick
      22  osMailAlloc
      40  osMailCAlloc
     132  osMailCreate
      24  osMailFree
     176  osMailGet
      92  osMailPut
      12  osMessageAvailableSpace
      18  osMessageCreate
      26  osMessageDelete
     180  osMessageGet
     112  osMessagePeek
     100  osMessagePut
      28  osMessageWaiting
      12  osMutexCreate
      26  osMutexDelete
      84  osMutexRelease
     130  osMutexWait
     130  osPoolAlloc
      40  osPoolCAlloc
     116  osPoolCreate
      80  osPoolFree
       6  osRecursiveMutexCreate
       6  osRecursiveMutexRelease
       6  osRecursiveMutexWait
      52  osSemaphoreCreate
      26  osSemaphoreDelete
      12  osSemaphoreGetCount
      84  osSemaphoreRelease
     130  osSemaphoreWait
     100  osSignalSet
     122  osSignalWait
      16  osSystickHandler
      46  osThreadCreate
       8  osThreadGetId
      36  osThreadGetPriority
       6  osThreadList
      50  osThreadResume
      18  osThreadResumeAll
      26  osThreadSetPriority
      14  osThreadSuspend
      10  osThreadSuspendAll
      14  osThreadTerminate
      22  osThreadYield
       6  osTimerCreate
       8  osTimerDelete
       8  osTimerStart
       8  osTimerStop

 
    12 bytes in section .rodata
 2'598 bytes in section .text
 
 2'598 bytes of CODE  memory
    12 bytes of CONST memory

Errors: none
Warnings: none
