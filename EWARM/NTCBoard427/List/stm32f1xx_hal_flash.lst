###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         06/Sep/2019  23:26:45
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash.c
#    Command line =
#        -f C:\Users\ilkorea\AppData\Local\Temp\EW7FDB.tmp
#        (D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash.c
#        -D USE_HAL_DRIVER -D STM32F103xB -lc
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\List
#        -o
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Inc\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/SEGGER\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/FreeRTOSV9\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/FreeRTOSV9/Config\
#        -On -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\List\stm32f1xx_hal_flash.lst
#    Object file  =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\Obj\stm32f1xx_hal_flash.o
#
###############################################################################

D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_flash.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_flash.c
      4            * @author  MCD Application Team
      5            * @brief   FLASH HAL module driver.
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the internal FLASH memory:
      8            *           + Program operations functions
      9            *           + Memory Control functions 
     10            *           + Peripheral State functions
     11            *         
     12            @verbatim
     13            ==============================================================================
     14                                  ##### FLASH peripheral features #####
     15            ==============================================================================
     16            [..] The Flash memory interface manages CPU AHB I-Code and D-Code accesses 
     17                 to the Flash memory. It implements the erase and program Flash memory operations 
     18                 and the read and write protection mechanisms.
     19          
     20            [..] The Flash memory interface accelerates code execution with a system of instruction
     21                prefetch. 
     22          
     23            [..] The FLASH main features are:
     24                (+) Flash memory read operations
     25                (+) Flash memory program/erase operations
     26                (+) Read / write protections
     27                (+) Prefetch on I-Code
     28                (+) Option Bytes programming
     29          
     30          
     31                               ##### How to use this driver #####
     32            ==============================================================================
     33            [..]                             
     34                This driver provides functions and macros to configure and program the FLASH 
     35                memory of all STM32F1xx devices.
     36              
     37                (#) FLASH Memory I/O Programming functions: this group includes all needed
     38                    functions to erase and program the main memory:
     39                  (++) Lock and Unlock the FLASH interface
     40                  (++) Erase function: Erase page, erase all pages
     41                  (++) Program functions: half word, word and doubleword
     42                (#) FLASH Option Bytes Programming functions: this group includes all needed
     43                    functions to manage the Option Bytes:
     44                  (++) Lock and Unlock the Option Bytes
     45                  (++) Set/Reset the write protection
     46                  (++) Set the Read protection Level
     47                  (++) Program the user Option Bytes
     48                  (++) Launch the Option Bytes loader
     49                  (++) Erase Option Bytes
     50                  (++) Program the data Option Bytes
     51                  (++) Get the Write protection.
     52                  (++) Get the user option bytes.
     53              
     54                (#) Interrupts and flags management functions : this group 
     55                    includes all needed functions to:
     56                  (++) Handle FLASH interrupts
     57                  (++) Wait for last FLASH operation according to its status
     58                  (++) Get error flag status
     59          
     60            [..] In addition to these function, this driver includes a set of macros allowing
     61                 to handle the following operations:
     62                
     63                (+) Set/Get the latency
     64                (+) Enable/Disable the prefetch buffer
     65                (+) Enable/Disable the half cycle access
     66                (+) Enable/Disable the FLASH interrupts
     67                (+) Monitor the FLASH flags status
     68                    
     69            @endverbatim
     70            ******************************************************************************
     71            * @attention
     72            *
     73            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
     74            *
     75            * Redistribution and use in source and binary forms, with or without modification,
     76            * are permitted provided that the following conditions are met:
     77            *   1. Redistributions of source code must retain the above copyright notice,
     78            *      this list of conditions and the following disclaimer.
     79            *   2. Redistributions in binary form must reproduce the above copyright notice,
     80            *      this list of conditions and the following disclaimer in the documentation
     81            *      and/or other materials provided with the distribution.
     82            *   3. Neither the name of STMicroelectronics nor the names of its contributors
     83            *      may be used to endorse or promote products derived from this software
     84            *      without specific prior written permission.
     85            *
     86            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     87            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     88            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     89            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     90            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     91            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     92            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     93            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     94            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     95            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     96            *
     97            ******************************************************************************  
     98            */
     99          
    100          /* Includes ------------------------------------------------------------------*/
    101          #include "stm32f1xx_hal.h"
    102          
    103          /** @addtogroup STM32F1xx_HAL_Driver
    104            * @{
    105            */
    106          
    107          #ifdef HAL_FLASH_MODULE_ENABLED
    108          
    109          /** @defgroup FLASH FLASH
    110            * @brief FLASH HAL module driver
    111            * @{
    112            */
    113          
    114          /* Private typedef -----------------------------------------------------------*/
    115          /* Private define ------------------------------------------------------------*/
    116          /** @defgroup FLASH_Private_Constants FLASH Private Constants
    117            * @{
    118            */
    119          /**
    120            * @}
    121            */
    122          
    123          /* Private macro ---------------------------- ---------------------------------*/
    124          /** @defgroup FLASH_Private_Macros FLASH Private Macros
    125            * @{
    126            */
    127           
    128          /**
    129            * @}
    130            */
    131          
    132          /* Private variables ---------------------------------------------------------*/
    133          /** @defgroup FLASH_Private_Variables FLASH Private Variables
    134            * @{
    135            */
    136          /* Variables used for Erase pages under interruption*/
    137          FLASH_ProcessTypeDef pFlash;
    138          /**
    139            * @}
    140            */
    141          
    142          /* Private function prototypes -----------------------------------------------*/
    143          /** @defgroup FLASH_Private_Functions FLASH Private Functions
    144            * @{
    145            */
    146          static  void   FLASH_Program_HalfWord(uint32_t Address, uint16_t Data);
    147          static  void   FLASH_SetErrorCode(void);
    148          extern void    FLASH_PageErase(uint32_t PageAddress);
    149          /**
    150            * @}
    151            */
    152          
    153          /* Exported functions ---------------------------------------------------------*/
    154          /** @defgroup FLASH_Exported_Functions FLASH Exported Functions
    155            * @{
    156            */
    157            
    158          /** @defgroup FLASH_Exported_Functions_Group1 Programming operation functions 
    159            *  @brief   Programming operation functions 
    160            *
    161          @verbatim   
    162          @endverbatim
    163            * @{
    164            */
    165          
    166          /**
    167            * @brief  Program halfword, word or double word at a specified address
    168            * @note   The function HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    169            *         The function HAL_FLASH_Lock() should be called after to lock the FLASH interface
    170            *
    171            * @note   If an erase and a program operations are requested simultaneously,    
    172            *         the erase operation is performed before the program one.
    173            *  
    174            * @note   FLASH should be previously erased before new programmation (only exception to this 
    175            *         is when 0x0000 is programmed)
    176            *
    177            * @param  TypeProgram:  Indicate the way to program at a specified address.
    178            *                       This parameter can be a value of @ref FLASH_Type_Program
    179            * @param  Address:      Specifies the address to be programmed.
    180            * @param  Data:         Specifies the data to be programmed
    181            * 
    182            * @retval HAL_StatusTypeDef HAL Status
    183            */
    184          HAL_StatusTypeDef HAL_FLASH_Program(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    185          {
    186            HAL_StatusTypeDef status = HAL_ERROR;
    187            uint8_t index = 0;
    188            uint8_t nbiterations = 0;
    189            
    190            /* Process Locked */
    191            __HAL_LOCK(&pFlash);
    192          
    193            /* Check the parameters */
    194            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    195            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    196          
    197          #if defined(FLASH_BANK2_END)
    198            if(Address <= FLASH_BANK1_END)
    199            {
    200          #endif /* FLASH_BANK2_END */
    201              /* Wait for last operation to be completed */
    202              status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    203          #if defined(FLASH_BANK2_END)
    204            }
    205            else
    206            {
    207              /* Wait for last operation to be completed */
    208              status = FLASH_WaitForLastOperationBank2(FLASH_TIMEOUT_VALUE);
    209            }
    210          #endif /* FLASH_BANK2_END */
    211            
    212            if(status == HAL_OK)
    213            {
    214              if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
    215              {
    216                /* Program halfword (16-bit) at a specified address. */
    217                nbiterations = 1U;
    218              }
    219              else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
    220              {
    221                /* Program word (32-bit = 2*16-bit) at a specified address. */
    222                nbiterations = 2U;
    223              }
    224              else
    225              {
    226                /* Program double word (64-bit = 4*16-bit) at a specified address. */
    227                nbiterations = 4U;
    228              }
    229          
    230              for (index = 0U; index < nbiterations; index++)
    231              {
    232                FLASH_Program_HalfWord((Address + (2U*index)), (uint16_t)(Data >> (16U*index)));
    233          
    234          #if defined(FLASH_BANK2_END)
    235                if(Address <= FLASH_BANK1_END)
    236                {
    237          #endif /* FLASH_BANK2_END */
    238                  /* Wait for last operation to be completed */
    239                  status = FLASH_WaitForLastOperation(FLASH_TIMEOUT_VALUE);
    240              
    241                  /* If the program operation is completed, disable the PG Bit */
    242                  CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
    243          #if defined(FLASH_BANK2_END)
    244                }
    245                else
    246                {
    247                  /* Wait for last operation to be completed */
    248                  status = FLASH_WaitForLastOperationBank2(FLASH_TIMEOUT_VALUE);
    249                  
    250                  /* If the program operation is completed, disable the PG Bit */
    251                  CLEAR_BIT(FLASH->CR2, FLASH_CR2_PG);
    252                }
    253          #endif /* FLASH_BANK2_END */
    254                /* In case of error, stop programation procedure */
    255                if (status != HAL_OK)
    256                {
    257                  break;
    258                }
    259              }
    260            }
    261          
    262            /* Process Unlocked */
    263            __HAL_UNLOCK(&pFlash);
    264          
    265            return status;
    266          }
    267          
    268          /**
    269            * @brief  Program halfword, word or double word at a specified address  with interrupt enabled.
    270            * @note   The function HAL_FLASH_Unlock() should be called before to unlock the FLASH interface
    271            *         The function HAL_FLASH_Lock() should be called after to lock the FLASH interface
    272            *
    273            * @note   If an erase and a program operations are requested simultaneously,    
    274            *         the erase operation is performed before the program one.
    275            *
    276            * @param  TypeProgram: Indicate the way to program at a specified address.
    277            *                      This parameter can be a value of @ref FLASH_Type_Program
    278            * @param  Address:     Specifies the address to be programmed.
    279            * @param  Data:        Specifies the data to be programmed
    280            * 
    281            * @retval HAL_StatusTypeDef HAL Status
    282            */
    283          HAL_StatusTypeDef HAL_FLASH_Program_IT(uint32_t TypeProgram, uint32_t Address, uint64_t Data)
    284          {
    285            HAL_StatusTypeDef status = HAL_OK;
    286            
    287            /* Process Locked */
    288            __HAL_LOCK(&pFlash);
    289          
    290            /* Check the parameters */
    291            assert_param(IS_FLASH_TYPEPROGRAM(TypeProgram));
    292            assert_param(IS_FLASH_PROGRAM_ADDRESS(Address));
    293          
    294          #if defined(FLASH_BANK2_END)
    295            /* If procedure already ongoing, reject the next one */
    296            if (pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
    297            {
    298              return HAL_ERROR;
    299            }
    300            
    301            if(Address <= FLASH_BANK1_END)
    302            {
    303              /* Enable End of FLASH Operation and Error source interrupts */
    304              __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP_BANK1 | FLASH_IT_ERR_BANK1);
    305          
    306            }else
    307            {
    308              /* Enable End of FLASH Operation and Error source interrupts */
    309              __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP_BANK2 | FLASH_IT_ERR_BANK2);
    310            }
    311          #else
    312            /* Enable End of FLASH Operation and Error source interrupts */
    313            __HAL_FLASH_ENABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
    314          #endif /* FLASH_BANK2_END */
    315            
    316            pFlash.Address = Address;
    317            pFlash.Data = Data;
    318          
    319            if(TypeProgram == FLASH_TYPEPROGRAM_HALFWORD)
    320            {
    321              pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAMHALFWORD;
    322              /* Program halfword (16-bit) at a specified address. */
    323              pFlash.DataRemaining = 1U;
    324            }
    325            else if(TypeProgram == FLASH_TYPEPROGRAM_WORD)
    326            {
    327              pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAMWORD;
    328              /* Program word (32-bit : 2*16-bit) at a specified address. */
    329              pFlash.DataRemaining = 2U;
    330            }
    331            else
    332            {
    333              pFlash.ProcedureOnGoing = FLASH_PROC_PROGRAMDOUBLEWORD;
    334              /* Program double word (64-bit : 4*16-bit) at a specified address. */
    335              pFlash.DataRemaining = 4U;
    336            }
    337          
    338            /* Program halfword (16-bit) at a specified address. */
    339            FLASH_Program_HalfWord(Address, (uint16_t)Data);
    340          
    341            return status;
    342          }
    343          
    344          /**
    345            * @brief This function handles FLASH interrupt request.
    346            * @retval None
    347            */
    348          void HAL_FLASH_IRQHandler(void)
    349          {
    350            uint32_t addresstmp = 0U;
    351            
    352            /* Check FLASH operation error flags */
    353          #if defined(FLASH_BANK2_END)
    354            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK1) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK1) || \
    355              (__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2)))
    356          #else
    357            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) ||__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
    358          #endif /* FLASH_BANK2_END */
    359            {
    360              /* Return the faulty address */
    361              addresstmp = pFlash.Address;
    362              /* Reset address */
    363              pFlash.Address = 0xFFFFFFFFU;
    364            
    365              /* Save the Error code */
    366              FLASH_SetErrorCode();
    367              
    368              /* FLASH error interrupt user callback */
    369              HAL_FLASH_OperationErrorCallback(addresstmp);
    370          
    371              /* Stop the procedure ongoing */
    372              pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    373            }
    374          
    375            /* Check FLASH End of Operation flag  */
    376          #if defined(FLASH_BANK2_END)
    377            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP_BANK1))
    378            {
    379              /* Clear FLASH End of Operation pending bit */
    380              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP_BANK1);
    381          #else
    382            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
    383            {
    384              /* Clear FLASH End of Operation pending bit */
    385              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
    386          #endif /* FLASH_BANK2_END */
    387              
    388              /* Process can continue only if no error detected */
    389              if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
    390              {
    391                if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
    392                {
    393                  /* Nb of pages to erased can be decreased */
    394                  pFlash.DataRemaining--;
    395          
    396                  /* Check if there are still pages to erase */
    397                  if(pFlash.DataRemaining != 0U)
    398                  {
    399                    addresstmp = pFlash.Address;
    400                    /*Indicate user which sector has been erased */
    401                    HAL_FLASH_EndOfOperationCallback(addresstmp);
    402          
    403                    /*Increment sector number*/
    404                    addresstmp = pFlash.Address + FLASH_PAGE_SIZE;
    405                    pFlash.Address = addresstmp;
    406          
    407                    /* If the erase operation is completed, disable the PER Bit */
    408                    CLEAR_BIT(FLASH->CR, FLASH_CR_PER);
    409          
    410                    FLASH_PageErase(addresstmp);
    411                  }
    412                  else
    413                  {
    414                    /* No more pages to Erase, user callback can be called. */
    415                    /* Reset Sector and stop Erase pages procedure */
    416                    pFlash.Address = addresstmp = 0xFFFFFFFFU;
    417                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    418                    /* FLASH EOP interrupt user callback */
    419                    HAL_FLASH_EndOfOperationCallback(addresstmp);
    420                  }
    421                }
    422                else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
    423                {
    424                  /* Operation is completed, disable the MER Bit */
    425                  CLEAR_BIT(FLASH->CR, FLASH_CR_MER);
    426          
    427          #if defined(FLASH_BANK2_END)
    428                  /* Stop Mass Erase procedure if no pending mass erase on other bank */
    429                  if (HAL_IS_BIT_CLR(FLASH->CR2, FLASH_CR2_MER))
    430                  {
    431          #endif /* FLASH_BANK2_END */
    432                    /* MassErase ended. Return the selected bank */
    433                    /* FLASH EOP interrupt user callback */
    434                    HAL_FLASH_EndOfOperationCallback(0U);
    435          
    436                    /* Stop Mass Erase procedure*/
    437                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    438                  }
    439          #if defined(FLASH_BANK2_END)
    440                }
    441          #endif /* FLASH_BANK2_END */
    442                else
    443                {
    444                  /* Nb of 16-bit data to program can be decreased */
    445                  pFlash.DataRemaining--;
    446                  
    447                  /* Check if there are still 16-bit data to program */
    448                  if(pFlash.DataRemaining != 0U)
    449                  {
    450                    /* Increment address to 16-bit */
    451                    pFlash.Address += 2U;
    452                    addresstmp = pFlash.Address;
    453                    
    454                    /* Shift to have next 16-bit data */
    455                    pFlash.Data = (pFlash.Data >> 16U);
    456                    
    457                    /* Operation is completed, disable the PG Bit */
    458                    CLEAR_BIT(FLASH->CR, FLASH_CR_PG);
    459          
    460                    /*Program halfword (16-bit) at a specified address.*/
    461                    FLASH_Program_HalfWord(addresstmp, (uint16_t)pFlash.Data);
    462                  }
    463                  else
    464                  {
    465                    /* Program ended. Return the selected address */
    466                    /* FLASH EOP interrupt user callback */
    467                    if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMHALFWORD)
    468                    {
    469                      HAL_FLASH_EndOfOperationCallback(pFlash.Address);
    470                    }
    471                    else if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMWORD)
    472                    {
    473                      HAL_FLASH_EndOfOperationCallback(pFlash.Address - 2U);
    474                    }
    475                    else 
    476                    {
    477                      HAL_FLASH_EndOfOperationCallback(pFlash.Address - 6U);
    478                    }
    479                  
    480                    /* Reset Address and stop Program procedure */
    481                    pFlash.Address = 0xFFFFFFFFU;
    482                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    483                  }
    484                }
    485              }
    486            }
    487            
    488          #if defined(FLASH_BANK2_END)
    489            /* Check FLASH End of Operation flag  */
    490            if(__HAL_FLASH_GET_FLAG( FLASH_FLAG_EOP_BANK2))
    491            {
    492              /* Clear FLASH End of Operation pending bit */
    493              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP_BANK2);
    494              
    495              /* Process can continue only if no error detected */
    496              if(pFlash.ProcedureOnGoing != FLASH_PROC_NONE)
    497              {
    498                if(pFlash.ProcedureOnGoing == FLASH_PROC_PAGEERASE)
    499                {
    500                  /* Nb of pages to erased can be decreased */
    501                  pFlash.DataRemaining--;
    502                  
    503                  /* Check if there are still pages to erase*/
    504                  if(pFlash.DataRemaining != 0U)
    505                  {
    506                    /* Indicate user which page address has been erased*/
    507                    HAL_FLASH_EndOfOperationCallback(pFlash.Address);
    508                  
    509                    /* Increment page address to next page */
    510                    pFlash.Address += FLASH_PAGE_SIZE;
    511                    addresstmp = pFlash.Address;
    512          
    513                    /* Operation is completed, disable the PER Bit */
    514                    CLEAR_BIT(FLASH->CR2, FLASH_CR2_PER);
    515          
    516                    FLASH_PageErase(addresstmp);
    517                  }
    518                  else
    519                  {
    520                    /*No more pages to Erase*/
    521                    
    522                    /*Reset Address and stop Erase pages procedure*/
    523                    pFlash.Address = 0xFFFFFFFFU;
    524                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    525          
    526                    /* FLASH EOP interrupt user callback */
    527                    HAL_FLASH_EndOfOperationCallback(pFlash.Address);
    528                  }
    529                }
    530                else if(pFlash.ProcedureOnGoing == FLASH_PROC_MASSERASE)
    531                {
    532                  /* Operation is completed, disable the MER Bit */
    533                  CLEAR_BIT(FLASH->CR2, FLASH_CR2_MER);
    534          
    535                  if (HAL_IS_BIT_CLR(FLASH->CR, FLASH_CR_MER))
    536                  {
    537                    /* MassErase ended. Return the selected bank*/
    538                    /* FLASH EOP interrupt user callback */
    539                    HAL_FLASH_EndOfOperationCallback(0U);
    540                  
    541                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    542                  }
    543                }
    544                else
    545                {
    546                  /* Nb of 16-bit data to program can be decreased */
    547                  pFlash.DataRemaining--;
    548                  
    549                  /* Check if there are still 16-bit data to program */
    550                  if(pFlash.DataRemaining != 0U)
    551                  {
    552                    /* Increment address to 16-bit */
    553                    pFlash.Address += 2U;
    554                    addresstmp = pFlash.Address;
    555                    
    556                    /* Shift to have next 16-bit data */
    557                    pFlash.Data = (pFlash.Data >> 16U);
    558                    
    559                    /* Operation is completed, disable the PG Bit */
    560                    CLEAR_BIT(FLASH->CR2, FLASH_CR2_PG);
    561          
    562                    /*Program halfword (16-bit) at a specified address.*/
    563                    FLASH_Program_HalfWord(addresstmp, (uint16_t)pFlash.Data);
    564                  }
    565                  else
    566                  {
    567                    /*Program ended. Return the selected address*/
    568                    /* FLASH EOP interrupt user callback */
    569                    if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMHALFWORD)
    570                    {
    571                      HAL_FLASH_EndOfOperationCallback(pFlash.Address);
    572                    }
    573                    else if (pFlash.ProcedureOnGoing == FLASH_PROC_PROGRAMWORD)
    574                    {
    575                      HAL_FLASH_EndOfOperationCallback(pFlash.Address-2U);
    576                    }
    577                    else 
    578                    {
    579                      HAL_FLASH_EndOfOperationCallback(pFlash.Address-6U);
    580                    }
    581                    
    582                    /* Reset Address and stop Program procedure*/
    583                    pFlash.Address = 0xFFFFFFFFU;
    584                    pFlash.ProcedureOnGoing = FLASH_PROC_NONE;
    585                  }
    586                }
    587              }
    588            }
    589          #endif 
    590          
    591            if(pFlash.ProcedureOnGoing == FLASH_PROC_NONE)
    592            {
    593          #if defined(FLASH_BANK2_END)
    594              /* Operation is completed, disable the PG, PER and MER Bits for both bank */
    595              CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_PER | FLASH_CR_MER));
    596              CLEAR_BIT(FLASH->CR2, (FLASH_CR2_PG | FLASH_CR2_PER | FLASH_CR2_MER));  
    597            
    598              /* Disable End of FLASH Operation and Error source interrupts for both banks */
    599              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP_BANK1 | FLASH_IT_ERR_BANK1 | FLASH_IT_EOP_BANK2 | FLASH_IT_ERR_BANK2);
    600          #else
    601              /* Operation is completed, disable the PG, PER and MER Bits */
    602              CLEAR_BIT(FLASH->CR, (FLASH_CR_PG | FLASH_CR_PER | FLASH_CR_MER));
    603          
    604              /* Disable End of FLASH Operation and Error source interrupts */
    605              __HAL_FLASH_DISABLE_IT(FLASH_IT_EOP | FLASH_IT_ERR);
    606          #endif /* FLASH_BANK2_END */
    607          
    608              /* Process Unlocked */
    609              __HAL_UNLOCK(&pFlash);
    610            }
    611          }
    612          
    613          /**
    614            * @brief  FLASH end of operation interrupt callback
    615            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    616            *                 - Mass Erase: No return value expected
    617            *                 - Pages Erase: Address of the page which has been erased 
    618            *                    (if 0xFFFFFFFF, it means that all the selected pages have been erased)
    619            *                 - Program: Address which was selected for data program
    620            * @retval none
    621            */
    622          __weak void HAL_FLASH_EndOfOperationCallback(uint32_t ReturnValue)
    623          {
    624            /* Prevent unused argument(s) compilation warning */
    625            UNUSED(ReturnValue);
    626          
    627            /* NOTE : This function Should not be modified, when the callback is needed,
    628                      the HAL_FLASH_EndOfOperationCallback could be implemented in the user file
    629             */ 
    630          }
    631          
    632          /**
    633            * @brief  FLASH operation error interrupt callback
    634            * @param  ReturnValue: The value saved in this parameter depends on the ongoing procedure
    635            *                 - Mass Erase: No return value expected
    636            *                 - Pages Erase: Address of the page which returned an error
    637            *                 - Program: Address which was selected for data program
    638            * @retval none
    639            */
    640          __weak void HAL_FLASH_OperationErrorCallback(uint32_t ReturnValue)
    641          {
    642            /* Prevent unused argument(s) compilation warning */
    643            UNUSED(ReturnValue);
    644          
    645            /* NOTE : This function Should not be modified, when the callback is needed,
    646                      the HAL_FLASH_OperationErrorCallback could be implemented in the user file
    647             */ 
    648          }
    649          
    650          /**
    651            * @}
    652            */
    653          
    654          /** @defgroup FLASH_Exported_Functions_Group2 Peripheral Control functions 
    655           *  @brief   management functions 
    656           *
    657          @verbatim   
    658           ===============================================================================
    659                                ##### Peripheral Control functions #####
    660           ===============================================================================  
    661              [..]
    662              This subsection provides a set of functions allowing to control the FLASH 
    663              memory operations.
    664          
    665          @endverbatim
    666            * @{
    667            */
    668          
    669          /**
    670            * @brief  Unlock the FLASH control register access
    671            * @retval HAL Status
    672            */
    673          HAL_StatusTypeDef HAL_FLASH_Unlock(void)
    674          {
    675            HAL_StatusTypeDef status = HAL_OK;
    676          
    677            if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
    678            {
    679              /* Authorize the FLASH Registers access */
    680              WRITE_REG(FLASH->KEYR, FLASH_KEY1);
    681              WRITE_REG(FLASH->KEYR, FLASH_KEY2);
    682          
    683              /* Verify Flash is unlocked */
    684              if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != RESET)
    685              {
    686                status = HAL_ERROR;
    687              }
    688            }
    689          #if defined(FLASH_BANK2_END)
    690            if(READ_BIT(FLASH->CR2, FLASH_CR2_LOCK) != RESET)
    691            {
    692              /* Authorize the FLASH BANK2 Registers access */
    693              WRITE_REG(FLASH->KEYR2, FLASH_KEY1);
    694              WRITE_REG(FLASH->KEYR2, FLASH_KEY2);
    695              
    696              /* Verify Flash BANK2 is unlocked */
    697              if(READ_BIT(FLASH->CR2, FLASH_CR2_LOCK) != RESET)
    698              {
    699                status = HAL_ERROR;
    700              }
    701            }
    702          #endif /* FLASH_BANK2_END */
    703          
    704            return status;
    705          }
    706          
    707          /**
    708            * @brief  Locks the FLASH control register access
    709            * @retval HAL Status
    710            */
    711          HAL_StatusTypeDef HAL_FLASH_Lock(void)
    712          {
    713            /* Set the LOCK Bit to lock the FLASH Registers access */
    714            SET_BIT(FLASH->CR, FLASH_CR_LOCK);
    715            
    716          #if defined(FLASH_BANK2_END)
    717            /* Set the LOCK Bit to lock the FLASH BANK2 Registers access */
    718            SET_BIT(FLASH->CR2, FLASH_CR2_LOCK);
    719          
    720          #endif /* FLASH_BANK2_END */
    721            return HAL_OK;  
    722          }
    723          
    724          /**
    725            * @brief  Unlock the FLASH Option Control Registers access.
    726            * @retval HAL Status
    727            */
    728          HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
    729          {
    730            if (HAL_IS_BIT_CLR(FLASH->CR, FLASH_CR_OPTWRE))
    731            {
    732              /* Authorizes the Option Byte register programming */
    733              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
    734              WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
    735            }
    736            else
    737            {
    738              return HAL_ERROR;
    739            }  
    740            
    741            return HAL_OK;  
    742          }
    743          
    744          /**
    745            * @brief  Lock the FLASH Option Control Registers access.
    746            * @retval HAL Status 
    747            */
    748          HAL_StatusTypeDef HAL_FLASH_OB_Lock(void)
    749          {
    750            /* Clear the OPTWRE Bit to lock the FLASH Option Byte Registers access */
    751            CLEAR_BIT(FLASH->CR, FLASH_CR_OPTWRE);
    752            
    753            return HAL_OK;  
    754          }
    755            
    756          /**
    757            * @brief  Launch the option byte loading.
    758            * @note   This function will reset automatically the MCU.
    759            * @retval None
    760            */
    761          void HAL_FLASH_OB_Launch(void)
    762          {
    763            /* Initiates a system reset request to launch the option byte loading */
    764            HAL_NVIC_SystemReset();
    765          }
    766          
    767          /**
    768            * @}
    769            */  
    770          
    771          /** @defgroup FLASH_Exported_Functions_Group3 Peripheral errors functions 
    772           *  @brief    Peripheral errors functions 
    773           *
    774          @verbatim   
    775           ===============================================================================
    776                                ##### Peripheral Errors functions #####
    777           ===============================================================================  
    778              [..]
    779              This subsection permit to get in run-time errors of  the FLASH peripheral.
    780          
    781          @endverbatim
    782            * @{
    783            */
    784          
    785          /**
    786            * @brief  Get the specific FLASH error flag.
    787            * @retval FLASH_ErrorCode The returned value can be:
    788            *            @ref FLASH_Error_Codes
    789            */
    790          uint32_t HAL_FLASH_GetError(void)
    791          {
    792             return pFlash.ErrorCode;
    793          }
    794          
    795          /**
    796            * @}
    797            */
    798          
    799          /**
    800            * @}
    801            */
    802          
    803          /** @addtogroup FLASH_Private_Functions
    804           * @{
    805           */
    806          
    807          /**
    808            * @brief  Program a half-word (16-bit) at a specified address.
    809            * @param  Address specify the address to be programmed.
    810            * @param  Data    specify the data to be programmed.
    811            * @retval None
    812            */
    813          static void FLASH_Program_HalfWord(uint32_t Address, uint16_t Data)
    814          {
    815            /* Clean the error context */
    816            pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
    817            
    818          #if defined(FLASH_BANK2_END)
    819            if(Address <= FLASH_BANK1_END)
    820            {
    821          #endif /* FLASH_BANK2_END */
    822              /* Proceed to program the new data */
    823              SET_BIT(FLASH->CR, FLASH_CR_PG);
    824          #if defined(FLASH_BANK2_END)
    825            }
    826            else
    827            {
    828              /* Proceed to program the new data */
    829              SET_BIT(FLASH->CR2, FLASH_CR2_PG);
    830            }
    831          #endif /* FLASH_BANK2_END */
    832          
    833            /* Write data in the address */
    834            *(__IO uint16_t*)Address = Data;
    835          }
    836          
    837          /**
    838            * @brief  Wait for a FLASH operation to complete.
    839            * @param  Timeout  maximum flash operation timeout
    840            * @retval HAL Status
    841            */
    842          HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
    843          {
    844            /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
    845               Even if the FLASH operation fails, the BUSY flag will be reset and an error
    846               flag will be set */
    847               
    848            uint32_t tickstart = HAL_GetTick();
    849               
    850            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY)) 
    851            { 
    852              if (Timeout != HAL_MAX_DELAY)
    853              {
    854                if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
    855                {
    856                  return HAL_TIMEOUT;
    857                }
    858              }
    859            }
    860            
    861            /* Check FLASH End of Operation flag  */
    862            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
    863            {
    864              /* Clear FLASH End of Operation pending bit */
    865              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
    866            }
    867            
    868            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR)  || 
    869               __HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR) || 
    870               __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
    871            {
    872              /*Save the error code*/
    873              FLASH_SetErrorCode();
    874              return HAL_ERROR;
    875            }
    876          
    877            /* There is no error flag set */
    878            return HAL_OK;
    879          }
    880          
    881          #if defined(FLASH_BANK2_END)
    882          /**
    883            * @brief  Wait for a FLASH BANK2 operation to complete.
    884            * @param  Timeout maximum flash operation timeout
    885            * @retval HAL_StatusTypeDef HAL Status
    886            */
    887          HAL_StatusTypeDef FLASH_WaitForLastOperationBank2(uint32_t Timeout)
    888          { 
    889            /* Wait for the FLASH BANK2 operation to complete by polling on BUSY flag to be reset.
    890               Even if the FLASH BANK2 operation fails, the BUSY flag will be reset and an error
    891               flag will be set */
    892               
    893            uint32_t tickstart = HAL_GetTick();
    894               
    895            while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY_BANK2)) 
    896            { 
    897              if (Timeout != HAL_MAX_DELAY)
    898              {
    899                if((Timeout == 0U) || ((HAL_GetTick()-tickstart) > Timeout))
    900                {
    901                  return HAL_TIMEOUT;
    902                }
    903              }
    904            }
    905            
    906            /* Check FLASH End of Operation flag  */
    907            if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP_BANK2))
    908            {
    909              /* Clear FLASH End of Operation pending bit */
    910              __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP_BANK2);
    911            }
    912          
    913            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2))
    914            {
    915              /*Save the error code*/
    916              FLASH_SetErrorCode();
    917              return HAL_ERROR;
    918            }
    919          
    920            /* If there is an error flag set */
    921            return HAL_OK;
    922            
    923          }
    924          #endif /* FLASH_BANK2_END */
    925          
    926          /**
    927            * @brief  Set the specific FLASH error flag.
    928            * @retval None
    929            */
    930          static void FLASH_SetErrorCode(void)
    931          {
    932            uint32_t flags = 0U;
    933            
    934          #if defined(FLASH_BANK2_END)
    935            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR_BANK2))
    936          #else
    937            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_WRPERR))
    938          #endif /* FLASH_BANK2_END */
    939            {
    940              pFlash.ErrorCode |= HAL_FLASH_ERROR_WRP;
    941          #if defined(FLASH_BANK2_END)
    942              flags |= FLASH_FLAG_WRPERR | FLASH_FLAG_WRPERR_BANK2;
    943          #else
    944              flags |= FLASH_FLAG_WRPERR;
    945          #endif /* FLASH_BANK2_END */
    946            }
    947          #if defined(FLASH_BANK2_END)
    948            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR) || __HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR_BANK2))
    949          #else
    950            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_PGERR))
    951          #endif /* FLASH_BANK2_END */
    952            {
    953              pFlash.ErrorCode |= HAL_FLASH_ERROR_PROG;
    954          #if defined(FLASH_BANK2_END)
    955              flags |= FLASH_FLAG_PGERR | FLASH_FLAG_PGERR_BANK2;
    956          #else
    957              flags |= FLASH_FLAG_PGERR;
    958          #endif /* FLASH_BANK2_END */
    959            }
    960            if(__HAL_FLASH_GET_FLAG(FLASH_FLAG_OPTVERR))
    961            {
    962              pFlash.ErrorCode |= HAL_FLASH_ERROR_OPTV;
    963            __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);
    964            }
    965          
    966            /* Clear FLASH error pending bits */
    967            __HAL_FLASH_CLEAR_FLAG(flags);
    968          }  
    969          /**
    970            * @}
    971            */
    972          
    973          /**
    974            * @}
    975            */
    976          
    977          #endif /* HAL_FLASH_MODULE_ENABLED */
    978          
    979          /**
    980            * @}
    981            */
    982          
    983          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   FLASH_Program_HalfWord
       4   FLASH_SetErrorCode
      16   FLASH_WaitForLastOperation
        16   -> FLASH_SetErrorCode
        16   -> HAL_GetTick
       0   HAL_FLASH_EndOfOperationCallback
       0   HAL_FLASH_GetError
      16   HAL_FLASH_IRQHandler
        16   -> FLASH_PageErase
        16   -> FLASH_Program_HalfWord
        16   -> FLASH_SetErrorCode
        16   -> HAL_FLASH_EndOfOperationCallback
        16   -> HAL_FLASH_OperationErrorCallback
       0   HAL_FLASH_Lock
       8   HAL_FLASH_OB_Launch
         8   -> HAL_NVIC_SystemReset
       0   HAL_FLASH_OB_Lock
       0   HAL_FLASH_OB_Unlock
       0   HAL_FLASH_OperationErrorCallback
      48   HAL_FLASH_Program
        48   -> FLASH_Program_HalfWord
        48   -> FLASH_WaitForLastOperation
        48 __aeabi_llsr
      24   HAL_FLASH_Program_IT
        24   -> FLASH_Program_HalfWord
       0   HAL_FLASH_Unlock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
      20  FLASH_Program_HalfWord
      96  FLASH_SetErrorCode
      84  FLASH_WaitForLastOperation
       2  HAL_FLASH_EndOfOperationCallback
       6  HAL_FLASH_GetError
     308  HAL_FLASH_IRQHandler
      14  HAL_FLASH_Lock
       8  HAL_FLASH_OB_Launch
      14  HAL_FLASH_OB_Lock
      26  HAL_FLASH_OB_Unlock
       2  HAL_FLASH_OperationErrorCallback
     174  HAL_FLASH_Program
     102  HAL_FLASH_Program_IT
      34  HAL_FLASH_Unlock
      32  pFlash

 
  32 bytes in section .bss
 922 bytes in section .text
 
 918 bytes of CODE memory (+ 4 bytes shared)
  32 bytes of DATA memory

Errors: none
Warnings: none
