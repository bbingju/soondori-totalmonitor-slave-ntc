###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         06/Sep/2019  23:26:46
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c
#    Command line =
#        -f C:\Users\ilkorea\AppData\Local\Temp\EW8275.tmp
#        (D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c
#        -D USE_HAL_DRIVER -D STM32F103xB -lc
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\List
#        -o
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\Obj
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "C:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 8.3\arm\inc\c\DLib_Config_Full.h"
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Inc\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/portable/IAR/ARM_CM3\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/include\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/Third_Party/FreeRTOS/Source/CMSIS_RTOS\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/SEGGER\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/FreeRTOSV9\
#        -I
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM/../Middlewares/FreeRTOSV9/Config\
#        -On -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\")
#    Locale       =  C
#    List file    =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\List\stm32f1xx_hal_tim.lst
#    Object file  =
#        D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\EWARM\NTCBoard427\Obj\stm32f1xx_hal_tim.o
#
###############################################################################

D:\00_Soondori\07_TotalTempMonitor\11_Firmware\NTCBoard427\Drivers\STM32F1xx_HAL_Driver\Src\stm32f1xx_hal_tim.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f1xx_hal_tim.c
      4            * @author  MCD Application Team
      5            * @brief   TIM HAL module driver
      6            *          This file provides firmware functions to manage the following 
      7            *          functionalities of the Timer (TIM) peripheral:
      8            *           + Time Base Initialization
      9            *           + Time Base Start
     10            *           + Time Base Start Interruption
     11            *           + Time Base Start DMA
     12            *           + Time Output Compare/PWM Initialization
     13            *           + Time Output Compare/PWM Channel Configuration
     14            *           + Time Output Compare/PWM  Start
     15            *           + Time Output Compare/PWM  Start Interruption
     16            *           + Time Output Compare/PWM Start DMA
     17            *           + Time Input Capture Initialization
     18            *           + Time Input Capture Channel Configuration
     19            *           + Time Input Capture Start
     20            *           + Time Input Capture Start Interruption 
     21            *           + Time Input Capture Start DMA
     22            *           + Time One Pulse Initialization
     23            *           + Time One Pulse Channel Configuration
     24            *           + Time One Pulse Start 
     25            *           + Time Encoder Interface Initialization
     26            *           + Time Encoder Interface Start
     27            *           + Time Encoder Interface Start Interruption
     28            *           + Time Encoder Interface Start DMA
     29            *           + Commutation Event configuration with Interruption and DMA
     30            *           + Time OCRef clear configuration
     31            *           + Time External Clock configuration
     32            @verbatim
     33            ==============================================================================
     34                                ##### TIMER Generic features #####
     35            ==============================================================================
     36            [..] The Timer features include:
     37                 (#) 16-bit up, down, up/down auto-reload counter.
     38                 (#) 16-bit programmable prescaler allowing dividing (also on the fly) the 
     39                     counter clock frequency either by any factor between 1 and 65536.
     40                 (#) Up to 4 independent channels for:
     41                     (++) Input Capture
     42                     (++) Output Compare
     43                     (++) PWM generation (Edge and Center-aligned Mode)
     44                     (++) One-pulse mode output 
     45          
     46                      ##### How to use this driver #####
     47            ==============================================================================
     48              [..]
     49               (#) Initialize the TIM low level resources by implementing the following functions 
     50                   depending from feature used :
     51                     (++) Time Base : HAL_TIM_Base_MspInit()
     52                     (++) Input Capture : HAL_TIM_IC_MspInit()
     53                     (++) Output Compare : HAL_TIM_OC_MspInit()
     54                     (++) PWM generation : HAL_TIM_PWM_MspInit()
     55                     (++) One-pulse mode output : HAL_TIM_OnePulse_MspInit()
     56                     (++) Encoder mode output : HAL_TIM_Encoder_MspInit()
     57          
     58               (#) Initialize the TIM low level resources :
     59                  (##) Enable the TIM interface clock using __HAL_RCC_TIMx_CLK_ENABLE();
     60                  (##) TIM pins configuration
     61                      (+++) Enable the clock for the TIM GPIOs using the following function:
     62                       __HAL_RCC_GPIOx_CLK_ENABLE();
     63                      (+++) Configure these TIM pins in Alternate function mode using HAL_GPIO_Init();
     64          
     65               (#) The external Clock can be configured, if needed (the default clock is the 
     66                   internal clock from the APBx), using the following function:
     67                   HAL_TIM_ConfigClockSource, the clock configuration should be done before 
     68                   any start function.
     69          
     70               (#) Configure the TIM in the desired functioning mode using one of the 
     71                 Initialization function of this driver:
     72                 (++) HAL_TIM_Base_Init: to use the Timer to generate a simple time base
     73                 (++) HAL_TIM_OC_Init and HAL_TIM_OC_ConfigChannel: to use the Timer to generate an 
     74                      Output Compare signal.
     75                 (++) HAL_TIM_PWM_Init and HAL_TIM_PWM_ConfigChannel: to use the Timer to generate a 
     76                      PWM signal.
     77                 (++) HAL_TIM_IC_Init and HAL_TIM_IC_ConfigChannel: to use the Timer to measure an 
     78                      external signal.
     79                   (++) HAL_TIM_OnePulse_Init and HAL_TIM_OnePulse_ConfigChannel: to use the Timer 
     80                        in One Pulse Mode.
     81                 (++) HAL_TIM_Encoder_Init: to use the Timer Encoder Interface.
     82          
     83               (#) Activate the TIM peripheral using one of the start functions depending from the feature used:
     84                     (++) Time Base : HAL_TIM_Base_Start(), HAL_TIM_Base_Start_DMA(), HAL_TIM_Base_Start_IT()
     85                     (++) Input Capture :  HAL_TIM_IC_Start(), HAL_TIM_IC_Start_DMA(), HAL_TIM_IC_Start_IT()
     86                     (++) Output Compare : HAL_TIM_OC_Start(), HAL_TIM_OC_Start_DMA(), HAL_TIM_OC_Start_IT()
     87                     (++) PWM generation : HAL_TIM_PWM_Start(), HAL_TIM_PWM_Start_DMA(), HAL_TIM_PWM_Start_IT()
     88                     (++) One-pulse mode output : HAL_TIM_OnePulse_Start(), HAL_TIM_OnePulse_Start_IT()
     89                     (++) Encoder mode output : HAL_TIM_Encoder_Start(), HAL_TIM_Encoder_Start_DMA(), HAL_TIM_Encoder_Start_IT().
     90          
     91               (#) The DMA Burst is managed with the two following functions:
     92                   HAL_TIM_DMABurst_WriteStart()
     93                   HAL_TIM_DMABurst_ReadStart()
     94          
     95            @endverbatim
     96            ******************************************************************************
     97            * @attention
     98            *
     99            * <h2><center>&copy; COPYRIGHT(c) 2016 STMicroelectronics</center></h2>
    100            *
    101            * Redistribution and use in source and binary forms, with or without modification,
    102            * are permitted provided that the following conditions are met:
    103            *   1. Redistributions of source code must retain the above copyright notice,
    104            *      this list of conditions and the following disclaimer.
    105            *   2. Redistributions in binary form must reproduce the above copyright notice,
    106            *      this list of conditions and the following disclaimer in the documentation
    107            *      and/or other materials provided with the distribution.
    108            *   3. Neither the name of STMicroelectronics nor the names of its contributors
    109            *      may be used to endorse or promote products derived from this software
    110            *      without specific prior written permission.
    111            *
    112            * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
    113            * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    114            * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    115            * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
    116            * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    117            * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
    118            * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
    119            * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
    120            * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    121            * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    122            *
    123            ******************************************************************************
    124            */
    125          
    126          /* Includes ------------------------------------------------------------------*/
    127          #include "stm32f1xx_hal.h"
    128          
    129          /** @addtogroup STM32F1xx_HAL_Driver
    130            * @{
    131            */
    132          
    133          /** @defgroup TIM TIM
    134            * @brief TIM HAL module driver
    135            * @{
    136            */
    137          
    138          #ifdef HAL_TIM_MODULE_ENABLED
    139          
    140          /* Private typedef -----------------------------------------------------------*/
    141          /* Private define ------------------------------------------------------------*/
    142          /* Private macro -------------------------------------------------------------*/
    143          /* Private variables ---------------------------------------------------------*/
    144          /* Private function prototypes -----------------------------------------------*/
    145          /** @defgroup TIM_Private_Functions TIM Private Functions
    146            * @{
    147            */
    148          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    149          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    150          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config);
    151          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    152          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    153                                 uint32_t TIM_ICFilter);
    154          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter);
    155          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    156                                 uint32_t TIM_ICFilter);
    157          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
    158                                 uint32_t TIM_ICFilter);
    159          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
    160                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter);
    161          static void TIM_ITRx_SetConfig(TIM_TypeDef* TIMx, uint16_t InputTriggerSource);
    162          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma);
    163          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma);
    164          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
    165                                               TIM_SlaveConfigTypeDef * sSlaveConfig);
    166          
    167          /**
    168            * @}
    169            */
    170          
    171          /* Exported functions ---------------------------------------------------------*/
    172          
    173          /** @defgroup TIM_Exported_Functions TIM Exported Functions
    174            * @{
    175            */
    176          
    177          /** @defgroup TIM_Exported_Functions_Group1 Time Base functions 
    178           *  @brief    Time Base functions 
    179           *
    180          @verbatim 
    181            ==============================================================================
    182                        ##### Time Base functions #####
    183            ==============================================================================
    184            [..]
    185              This section provides functions allowing to:
    186              (+) Initialize and configure the TIM base.
    187              (+) De-initialize the TIM base.
    188              (+) Start the Time Base.
    189              (+) Stop the Time Base.
    190              (+) Start the Time Base and enable interrupt.
    191              (+) Stop the Time Base and disable interrupt.
    192              (+) Start the Time Base and enable DMA transfer.
    193              (+) Stop the Time Base and disable DMA transfer.
    194          
    195          @endverbatim
    196            * @{
    197            */
    198          /**
    199            * @brief  Initializes the TIM Time base Unit according to the specified
    200            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    201            * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    202            *       requires a timer reset to avoid unexpected direction
    203            *       due to DIR bit readonly in center aligned mode.
    204            *       Ex: call @ref HAL_TIM_Base_DeInit() before HAL_TIM_Base_Init()
    205            * @param  htim : TIM Base handle
    206            * @retval HAL status
    207            */
    208          HAL_StatusTypeDef HAL_TIM_Base_Init(TIM_HandleTypeDef *htim)
    209          {
    210            /* Check the TIM handle allocation */
    211            if(htim == NULL)
    212            {
    213              return HAL_ERROR;
    214            }
    215          
    216            /* Check the parameters */
    217            assert_param(IS_TIM_INSTANCE(htim->Instance));
    218            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    219            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    220            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    221          
    222            if(htim->State == HAL_TIM_STATE_RESET)
    223            {
    224              /* Allocate lock resource and initialize it */
    225              htim->Lock = HAL_UNLOCKED;
    226              
    227              /* Init the low level hardware : GPIO, CLOCK, NVIC */
    228              HAL_TIM_Base_MspInit(htim);
    229            }
    230          
    231            /* Set the TIM state */
    232            htim->State= HAL_TIM_STATE_BUSY;
    233          
    234            /* Set the Time Base configuration */
    235            TIM_Base_SetConfig(htim->Instance, &htim->Init);
    236          
    237            /* Initialize the TIM state*/
    238            htim->State= HAL_TIM_STATE_READY;
    239          
    240            return HAL_OK;
    241          }
    242          
    243          /**
    244            * @brief  DeInitializes the TIM Base peripheral 
    245            * @param  htim : TIM Base handle
    246            * @retval HAL status
    247            */
    248          HAL_StatusTypeDef HAL_TIM_Base_DeInit(TIM_HandleTypeDef *htim)
    249          {
    250            /* Check the parameters */
    251            assert_param(IS_TIM_INSTANCE(htim->Instance));
    252          
    253            htim->State = HAL_TIM_STATE_BUSY;
    254          
    255            /* Disable the TIM Peripheral Clock */
    256            __HAL_TIM_DISABLE(htim);
    257          
    258            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
    259            HAL_TIM_Base_MspDeInit(htim);
    260          
    261            /* Change TIM state */
    262            htim->State = HAL_TIM_STATE_RESET;
    263          
    264            /* Release Lock */
    265            __HAL_UNLOCK(htim);
    266          
    267            return HAL_OK;
    268          }
    269          
    270          /**
    271            * @brief  Initializes the TIM Base MSP.
    272            * @param  htim : TIM handle
    273            * @retval None
    274            */
    275          __weak void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
    276          {
    277            /* Prevent unused argument(s) compilation warning */
    278            UNUSED(htim);
    279            /* NOTE : This function Should not be modified, when the callback is needed,
    280                      the HAL_TIM_Base_MspInit could be implemented in the user file
    281             */
    282          }
    283          
    284          /**
    285            * @brief  DeInitializes TIM Base MSP.
    286            * @param  htim : TIM handle
    287            * @retval None
    288            */
    289          __weak void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef *htim)
    290          {
    291            /* Prevent unused argument(s) compilation warning */
    292            UNUSED(htim);
    293            /* NOTE : This function Should not be modified, when the callback is needed,
    294                      the HAL_TIM_Base_MspDeInit could be implemented in the user file
    295             */
    296          }
    297          
    298          
    299          /**
    300            * @brief  Starts the TIM Base generation.
    301            * @param  htim : TIM handle
    302            * @retval HAL status
    303          */
    304          HAL_StatusTypeDef HAL_TIM_Base_Start(TIM_HandleTypeDef *htim)
    305          {
    306            /* Check the parameters */
    307            assert_param(IS_TIM_INSTANCE(htim->Instance));
    308          
    309            /* Set the TIM state */
    310            htim->State= HAL_TIM_STATE_BUSY;
    311          
    312            /* Enable the Peripheral */
    313            __HAL_TIM_ENABLE(htim);
    314          
    315            /* Change the TIM state*/
    316            htim->State= HAL_TIM_STATE_READY;
    317          
    318            /* Return function status */
    319            return HAL_OK;
    320          }
    321          
    322          /**
    323            * @brief  Stops the TIM Base generation.
    324            * @param  htim : TIM handle
    325            * @retval HAL status
    326          */
    327          HAL_StatusTypeDef HAL_TIM_Base_Stop(TIM_HandleTypeDef *htim)
    328          {
    329            /* Check the parameters */
    330            assert_param(IS_TIM_INSTANCE(htim->Instance));
    331          
    332            /* Set the TIM state */
    333            htim->State= HAL_TIM_STATE_BUSY;
    334          
    335            /* Disable the Peripheral */
    336            __HAL_TIM_DISABLE(htim);
    337          
    338            /* Change the TIM state*/
    339            htim->State= HAL_TIM_STATE_READY;
    340          
    341            /* Return function status */
    342            return HAL_OK;
    343          }
    344          
    345          /**
    346            * @brief  Starts the TIM Base generation in interrupt mode.
    347            * @param  htim : TIM handle
    348            * @retval HAL status
    349          */
    350          HAL_StatusTypeDef HAL_TIM_Base_Start_IT(TIM_HandleTypeDef *htim)
    351          {
    352            /* Check the parameters */
    353            assert_param(IS_TIM_INSTANCE(htim->Instance));
    354          
    355             /* Enable the TIM Update interrupt */
    356             __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
    357          
    358             /* Enable the Peripheral */
    359            __HAL_TIM_ENABLE(htim);
    360          
    361            /* Return function status */
    362            return HAL_OK;
    363          }
    364          
    365          /**
    366            * @brief  Stops the TIM Base generation in interrupt mode.
    367            * @param  htim : TIM handle
    368            * @retval HAL status
    369          */
    370          HAL_StatusTypeDef HAL_TIM_Base_Stop_IT(TIM_HandleTypeDef *htim)
    371          {
    372            /* Check the parameters */
    373            assert_param(IS_TIM_INSTANCE(htim->Instance));
    374            /* Disable the TIM Update interrupt */
    375            __HAL_TIM_DISABLE_IT(htim, TIM_IT_UPDATE);
    376          
    377            /* Disable the Peripheral */
    378            __HAL_TIM_DISABLE(htim);
    379          
    380            /* Return function status */
    381            return HAL_OK;
    382          }
    383          
    384          /**
    385            * @brief  Starts the TIM Base generation in DMA mode.
    386            * @param  htim : TIM handle
    387            * @param  pData : The source Buffer address.
    388            * @param  Length : The length of data to be transferred from memory to peripheral.
    389            * @retval HAL status
    390          */
    391          HAL_StatusTypeDef HAL_TIM_Base_Start_DMA(TIM_HandleTypeDef *htim, uint32_t *pData, uint16_t Length)
    392          {
    393            /* Check the parameters */
    394            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    395          
    396            if((htim->State == HAL_TIM_STATE_BUSY))
    397            {
    398               return HAL_BUSY;
    399            }
    400            else if((htim->State == HAL_TIM_STATE_READY))
    401            {
    402              if((pData == 0U) && (Length > 0U))
    403              {
    404                return HAL_ERROR;
    405              }
    406              else
    407              {
    408                htim->State = HAL_TIM_STATE_BUSY;
    409              }
    410            }
    411            /* Set the DMA Period elapsed callback */
    412            htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
    413          
    414            /* Set the DMA error callback */
    415            htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
    416          
    417            /* Enable the DMA channel */
    418            HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)pData, (uint32_t)&htim->Instance->ARR, Length);
    419          
    420            /* Enable the TIM Update DMA request */
    421            __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_UPDATE);
    422          
    423            /* Enable the Peripheral */
    424            __HAL_TIM_ENABLE(htim);
    425          
    426            /* Return function status */
    427            return HAL_OK;
    428          }
    429          
    430          /**
    431            * @brief  Stops the TIM Base generation in DMA mode.
    432            * @param  htim : TIM handle
    433            * @retval HAL status
    434          */
    435          HAL_StatusTypeDef HAL_TIM_Base_Stop_DMA(TIM_HandleTypeDef *htim)
    436          {
    437            /* Check the parameters */
    438            assert_param(IS_TIM_DMA_INSTANCE(htim->Instance));
    439          
    440            /* Disable the TIM Update DMA request */
    441            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_UPDATE);
    442          
    443            /* Disable the Peripheral */
    444            __HAL_TIM_DISABLE(htim);
    445          
    446            /* Change the htim state */
    447            htim->State = HAL_TIM_STATE_READY;
    448          
    449            /* Return function status */
    450            return HAL_OK;
    451          }
    452          
    453          /**
    454            * @}
    455            */
    456          
    457          /** @defgroup TIM_Exported_Functions_Group2 Time Output Compare functions 
    458           *  @brief    Time Output Compare functions 
    459           *
    460          @verbatim 
    461            ==============================================================================
    462                            ##### Time Output Compare functions #####
    463            ==============================================================================
    464            [..]
    465              This section provides functions allowing to:
    466              (+) Initialize and configure the TIM Output Compare.
    467              (+) De-initialize the TIM Output Compare.
    468              (+) Start the Time Output Compare.
    469              (+) Stop the Time Output Compare.
    470              (+) Start the Time Output Compare and enable interrupt.
    471              (+) Stop the Time Output Compare and disable interrupt.
    472              (+) Start the Time Output Compare and enable DMA transfer.
    473              (+) Stop the Time Output Compare and disable DMA transfer.
    474          
    475          @endverbatim
    476            * @{
    477            */
    478          /**
    479            * @brief  Initializes the TIM Output Compare according to the specified
    480            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    481            * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    482            *       requires a timer reset to avoid unexpected direction
    483            *       due to DIR bit readonly in center aligned mode.
    484            *       Ex: call @ref HAL_TIM_OC_DeInit() before HAL_TIM_OC_Init()
    485            * @param  htim : TIM Output Compare handle
    486            * @retval HAL status
    487            */
    488          HAL_StatusTypeDef HAL_TIM_OC_Init(TIM_HandleTypeDef* htim)
    489          {
    490            /* Check the TIM handle allocation */
    491            if(htim == NULL)
    492            {
    493              return HAL_ERROR;
    494            }
    495          
    496            /* Check the parameters */
    497            assert_param(IS_TIM_INSTANCE(htim->Instance));
    498            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
    499            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
    500            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
    501          
    502            if(htim->State == HAL_TIM_STATE_RESET)
    503            {
    504              /* Allocate lock resource and initialize it */
    505              htim->Lock = HAL_UNLOCKED;
    506              
    507              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
    508              HAL_TIM_OC_MspInit(htim);
    509            }
    510          
    511            /* Set the TIM state */
    512            htim->State= HAL_TIM_STATE_BUSY;
    513          
    514            /* Init the base time for the Output Compare */
    515            TIM_Base_SetConfig(htim->Instance,  &htim->Init);
    516          
    517            /* Initialize the TIM state*/
    518            htim->State= HAL_TIM_STATE_READY;
    519          
    520            return HAL_OK;
    521          }
    522          
    523          /**
    524            * @brief  DeInitializes the TIM peripheral 
    525            * @param  htim : TIM Output Compare handle
    526            * @retval HAL status
    527            */
    528          HAL_StatusTypeDef HAL_TIM_OC_DeInit(TIM_HandleTypeDef *htim)
    529          {
    530            /* Check the parameters */
    531            assert_param(IS_TIM_INSTANCE(htim->Instance));
    532          
    533             htim->State = HAL_TIM_STATE_BUSY;
    534          
    535            /* Disable the TIM Peripheral Clock */
    536            __HAL_TIM_DISABLE(htim);
    537          
    538            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
    539            HAL_TIM_OC_MspDeInit(htim);
    540          
    541            /* Change TIM state */
    542            htim->State = HAL_TIM_STATE_RESET;
    543          
    544            /* Release Lock */
    545            __HAL_UNLOCK(htim);
    546          
    547            return HAL_OK;
    548          }
    549          
    550          /**
    551            * @brief  Initializes the TIM Output Compare MSP.
    552            * @param  htim : TIM handle
    553            * @retval None
    554            */
    555          __weak void HAL_TIM_OC_MspInit(TIM_HandleTypeDef *htim)
    556          {
    557            /* Prevent unused argument(s) compilation warning */
    558            UNUSED(htim);
    559            /* NOTE : This function Should not be modified, when the callback is needed,
    560                      the HAL_TIM_OC_MspInit could be implemented in the user file
    561             */
    562          }
    563          
    564          /**
    565            * @brief  DeInitializes TIM Output Compare MSP.
    566            * @param  htim : TIM handle
    567            * @retval None
    568            */
    569          __weak void HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef *htim)
    570          {
    571            /* Prevent unused argument(s) compilation warning */
    572            UNUSED(htim);
    573            /* NOTE : This function Should not be modified, when the callback is needed,
    574                      the HAL_TIM_OC_MspDeInit could be implemented in the user file
    575             */
    576          }
    577          
    578          /**
    579            * @brief  Starts the TIM Output Compare signal generation.
    580            * @param  htim : TIM Output Compare handle 
    581            * @param  Channel : TIM Channel to be enabled
    582            *          This parameter can be one of the following values:
    583            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    584            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    585            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    586            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
    587            * @retval HAL status
    588          */
    589          HAL_StatusTypeDef HAL_TIM_OC_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
    590          {
    591            /* Check the parameters */
    592            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    593          
    594            /* Enable the Output compare channel */
    595            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    596          
    597            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    598            {
    599              /* Enable the main output */
    600              __HAL_TIM_MOE_ENABLE(htim);
    601            }
    602          
    603            /* Enable the Peripheral */
    604            __HAL_TIM_ENABLE(htim);
    605          
    606            /* Return function status */
    607            return HAL_OK;
    608          }
    609          
    610          /**
    611            * @brief  Stops the TIM Output Compare signal generation.
    612            * @param  htim : TIM handle
    613            * @param  Channel : TIM Channel to be disabled
    614            *          This parameter can be one of the following values:
    615            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    616            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    617            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    618            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    619            * @retval HAL status
    620          */
    621          HAL_StatusTypeDef HAL_TIM_OC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
    622          {
    623            /* Check the parameters */
    624            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    625          
    626            /* Disable the Output compare channel */
    627            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    628          
    629            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    630            {
    631              /* Disable the Main Ouput */
    632              __HAL_TIM_MOE_DISABLE(htim);
    633            }
    634          
    635            /* Disable the Peripheral */
    636            __HAL_TIM_DISABLE(htim);
    637          
    638            /* Return function status */
    639            return HAL_OK;
    640          }
    641          
    642          /**
    643            * @brief  Starts the TIM Output Compare signal generation in interrupt mode.
    644            * @param  htim : TIM OC handle
    645            * @param  Channel : TIM Channel to be enabled
    646            *          This parameter can be one of the following values:
    647            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    648            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    649            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    650            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    651            * @retval HAL status
    652          */
    653          HAL_StatusTypeDef HAL_TIM_OC_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    654          {
    655            /* Check the parameters */
    656            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    657          
    658            switch (Channel)
    659            {
    660              case TIM_CHANNEL_1:
    661              {
    662                /* Enable the TIM Capture/Compare 1 interrupt */
    663                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
    664              }
    665              break;
    666          
    667              case TIM_CHANNEL_2:
    668              {
    669                /* Enable the TIM Capture/Compare 2 interrupt */
    670                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
    671              }
    672              break;
    673          
    674              case TIM_CHANNEL_3:
    675              {
    676                /* Enable the TIM Capture/Compare 3 interrupt */
    677                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
    678              }
    679              break;
    680          
    681              case TIM_CHANNEL_4:
    682              {
    683                /* Enable the TIM Capture/Compare 4 interrupt */
    684                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
    685              }
    686              break;
    687          
    688              default:
    689              break;
    690            }
    691          
    692            /* Enable the Output compare channel */
    693            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    694          
    695            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    696            {
    697              /* Enable the main output */
    698              __HAL_TIM_MOE_ENABLE(htim);
    699            }
    700          
    701            /* Enable the Peripheral */
    702            __HAL_TIM_ENABLE(htim);
    703          
    704            /* Return function status */
    705            return HAL_OK;
    706          }
    707          
    708          /**
    709            * @brief  Stops the TIM Output Compare signal generation in interrupt mode.
    710            * @param  htim : TIM Output Compare handle
    711            * @param  Channel : TIM Channel to be disabled
    712            *          This parameter can be one of the following values:
    713            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    714            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    715            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    716            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    717            * @retval HAL status
    718          */
    719          HAL_StatusTypeDef HAL_TIM_OC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
    720          {
    721            /* Check the parameters */
    722            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    723          
    724            switch (Channel)
    725            {
    726              case TIM_CHANNEL_1:
    727              {
    728                /* Disable the TIM Capture/Compare 1 interrupt */
    729                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
    730              }
    731              break;
    732          
    733              case TIM_CHANNEL_2:
    734              {
    735                /* Disable the TIM Capture/Compare 2 interrupt */
    736                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
    737              }
    738              break;
    739          
    740              case TIM_CHANNEL_3:
    741              {
    742                /* Disable the TIM Capture/Compare 3 interrupt */
    743                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
    744              }
    745              break;
    746          
    747              case TIM_CHANNEL_4:
    748              {
    749                /* Disable the TIM Capture/Compare 4 interrupt */
    750                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
    751              }
    752              break;
    753          
    754              default:
    755              break;
    756            }
    757          
    758            /* Disable the Output compare channel */
    759            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    760          
    761            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    762            {
    763              /* Disable the Main Ouput */
    764              __HAL_TIM_MOE_DISABLE(htim);
    765            }
    766          
    767            /* Disable the Peripheral */
    768            __HAL_TIM_DISABLE(htim);
    769          
    770            /* Return function status */
    771            return HAL_OK;
    772          }
    773          
    774          /**
    775            * @brief  Starts the TIM Output Compare signal generation in DMA mode.
    776            * @param  htim : TIM Output Compare handle
    777            * @param  Channel : TIM Channel to be enabled
    778            *          This parameter can be one of the following values:
    779            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    780            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    781            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    782            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    783            * @param  pData : The source Buffer address.
    784            * @param  Length : The length of data to be transferred from memory to TIM peripheral
    785            * @retval HAL status
    786          */
    787          HAL_StatusTypeDef HAL_TIM_OC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
    788          {
    789            /* Check the parameters */
    790            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    791          
    792            if((htim->State == HAL_TIM_STATE_BUSY))
    793            {
    794               return HAL_BUSY;
    795            }
    796            else if((htim->State == HAL_TIM_STATE_READY))
    797            {
    798              if(((uint32_t)pData == 0U) && (Length > 0U))
    799              {
    800                return HAL_ERROR;
    801              }
    802              else
    803              {
    804                htim->State = HAL_TIM_STATE_BUSY;
    805              }
    806            }
    807            switch (Channel)
    808            {
    809              case TIM_CHANNEL_1:
    810              {
    811                /* Set the DMA Period elapsed callback */
    812                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
    813          
    814                /* Set the DMA error callback */
    815                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
    816          
    817                /* Enable the DMA channel */
    818                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
    819          
    820                /* Enable the TIM Capture/Compare 1 DMA request */
    821                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
    822              }
    823              break;
    824          
    825              case TIM_CHANNEL_2:
    826              {
    827                /* Set the DMA Period elapsed callback */
    828                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
    829          
    830                /* Set the DMA error callback */
    831                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
    832          
    833                /* Enable the DMA channel */
    834                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
    835          
    836                /* Enable the TIM Capture/Compare 2 DMA request */
    837                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
    838              }
    839              break;
    840          
    841              case TIM_CHANNEL_3:
    842              {
    843                /* Set the DMA Period elapsed callback */
    844                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
    845          
    846                /* Set the DMA error callback */
    847                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
    848          
    849                /* Enable the DMA channel */
    850                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
    851          
    852                /* Enable the TIM Capture/Compare 3 DMA request */
    853                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
    854              }
    855              break;
    856          
    857              case TIM_CHANNEL_4:
    858              {
    859               /* Set the DMA Period elapsed callback */
    860                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
    861          
    862                /* Set the DMA error callback */
    863                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
    864          
    865                /* Enable the DMA channel */
    866                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
    867          
    868                /* Enable the TIM Capture/Compare 4 DMA request */
    869                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
    870              }
    871              break;
    872          
    873              default:
    874              break;
    875            }
    876          
    877            /* Enable the Output compare channel */
    878            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
    879          
    880            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    881            {
    882              /* Enable the main output */
    883              __HAL_TIM_MOE_ENABLE(htim);
    884            }
    885          
    886            /* Enable the Peripheral */
    887            __HAL_TIM_ENABLE(htim);
    888          
    889            /* Return function status */
    890            return HAL_OK;
    891          }
    892          
    893          /**
    894            * @brief  Stops the TIM Output Compare signal generation in DMA mode.
    895            * @param  htim : TIM Output Compare handle
    896            * @param  Channel : TIM Channel to be disabled
    897            *          This parameter can be one of the following values:
    898            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
    899            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
    900            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
    901            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
    902            * @retval HAL status
    903          */
    904          HAL_StatusTypeDef HAL_TIM_OC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
    905          {
    906            /* Check the parameters */
    907            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
    908          
    909            switch (Channel)
    910            {
    911              case TIM_CHANNEL_1:
    912              {
    913                /* Disable the TIM Capture/Compare 1 DMA request */
    914                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
    915              }
    916              break;
    917          
    918              case TIM_CHANNEL_2:
    919              {
    920                /* Disable the TIM Capture/Compare 2 DMA request */
    921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
    922              }
    923              break;
    924          
    925              case TIM_CHANNEL_3:
    926              {
    927                /* Disable the TIM Capture/Compare 3 DMA request */
    928                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
    929              }
    930              break;
    931          
    932              case TIM_CHANNEL_4:
    933              {
    934                /* Disable the TIM Capture/Compare 4 interrupt */
    935                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
    936              }
    937              break;
    938          
    939              default:
    940              break;
    941            }
    942          
    943            /* Disable the Output compare channel */
    944            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
    945          
    946            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
    947            {
    948              /* Disable the Main Ouput */
    949              __HAL_TIM_MOE_DISABLE(htim);
    950            }
    951          
    952            /* Disable the Peripheral */
    953            __HAL_TIM_DISABLE(htim);
    954          
    955            /* Change the htim state */
    956            htim->State = HAL_TIM_STATE_READY;
    957          
    958            /* Return function status */
    959            return HAL_OK;
    960          }
    961          
    962          /**
    963            * @}
    964            */
    965          
    966          /** @defgroup TIM_Exported_Functions_Group3 Time PWM functions 
    967           *  @brief    Time PWM functions 
    968           *
    969          @verbatim 
    970            ==============================================================================
    971                                    ##### Time PWM functions #####
    972            ==============================================================================
    973            [..]
    974              This section provides functions allowing to:
    975              (+) Initialize and configure the TIM PWM.
    976              (+) De-initialize the TIM PWM.
    977              (+) Start the Time PWM.
    978              (+) Stop the Time PWM.
    979              (+) Start the Time PWM and enable interrupt.
    980              (+) Stop the Time PWM and disable interrupt.
    981              (+) Start the Time PWM and enable DMA transfer.
    982              (+) Stop the Time PWM and disable DMA transfer.
    983          
    984          @endverbatim
    985            * @{
    986            */
    987          /**
    988            * @brief  Initializes the TIM PWM Time Base according to the specified
    989            *         parameters in the TIM_HandleTypeDef and create the associated handle.
    990            * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
    991            *       requires a timer reset to avoid unexpected direction
    992            *       due to DIR bit readonly in center aligned mode.
    993            *       Ex: call @ref HAL_TIM_PWM_DeInit() before HAL_TIM_PWM_Init()
    994            * @param  htim : TIM handle
    995            * @retval HAL status
    996            */
    997          HAL_StatusTypeDef HAL_TIM_PWM_Init(TIM_HandleTypeDef *htim)
    998          {
    999            /* Check the TIM handle allocation */
   1000            if(htim == NULL)
   1001            {
   1002              return HAL_ERROR;
   1003            }
   1004          
   1005            /* Check the parameters */
   1006            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1007            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1008            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1009            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1010          
   1011            if(htim->State == HAL_TIM_STATE_RESET)
   1012            {
   1013              /* Allocate lock resource and initialize it */
   1014              htim->Lock = HAL_UNLOCKED;
   1015              
   1016              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1017              HAL_TIM_PWM_MspInit(htim);
   1018            }
   1019          
   1020            /* Set the TIM state */
   1021            htim->State= HAL_TIM_STATE_BUSY;
   1022          
   1023            /* Init the base time for the PWM */
   1024            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1025          
   1026            /* Initialize the TIM state*/
   1027            htim->State= HAL_TIM_STATE_READY;
   1028          
   1029            return HAL_OK;
   1030          }
   1031          
   1032          /**
   1033            * @brief  DeInitializes the TIM peripheral 
   1034            * @param  htim : TIM handle
   1035            * @retval HAL status
   1036            */
   1037          HAL_StatusTypeDef HAL_TIM_PWM_DeInit(TIM_HandleTypeDef *htim)
   1038          {
   1039            /* Check the parameters */
   1040            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1041          
   1042            htim->State = HAL_TIM_STATE_BUSY;
   1043          
   1044            /* Disable the TIM Peripheral Clock */
   1045            __HAL_TIM_DISABLE(htim);
   1046          
   1047            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1048            HAL_TIM_PWM_MspDeInit(htim);
   1049          
   1050            /* Change TIM state */
   1051            htim->State = HAL_TIM_STATE_RESET;
   1052          
   1053            /* Release Lock */
   1054            __HAL_UNLOCK(htim);
   1055          
   1056            return HAL_OK;
   1057          }
   1058          
   1059          /**
   1060            * @brief  Initializes the TIM PWM MSP.
   1061            * @param  htim : TIM handle
   1062            * @retval None
   1063            */
   1064          __weak void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim)
   1065          {
   1066            /* Prevent unused argument(s) compilation warning */
   1067            UNUSED(htim);
   1068            /* NOTE : This function Should not be modified, when the callback is needed,
   1069                      the HAL_TIM_PWM_MspInit could be implemented in the user file
   1070             */
   1071          }
   1072          
   1073          /**
   1074            * @brief  DeInitializes TIM PWM MSP.
   1075            * @param  htim : TIM handle
   1076            * @retval None
   1077            */
   1078          __weak void HAL_TIM_PWM_MspDeInit(TIM_HandleTypeDef *htim)
   1079          {
   1080            /* Prevent unused argument(s) compilation warning */
   1081            UNUSED(htim);
   1082            /* NOTE : This function Should not be modified, when the callback is needed,
   1083                      the HAL_TIM_PWM_MspDeInit could be implemented in the user file
   1084             */
   1085          }
   1086          
   1087          /**
   1088            * @brief  Starts the PWM signal generation.
   1089            * @param  htim : TIM handle
   1090            * @param  Channel : TIM Channels to be enabled
   1091            *          This parameter can be one of the following values:
   1092            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1093            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1094            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1095            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1096            * @retval HAL status
   1097          */
   1098          HAL_StatusTypeDef HAL_TIM_PWM_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   1099          {
   1100            /* Check the parameters */
   1101            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1102          
   1103            /* Enable the Capture compare channel */
   1104            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1105          
   1106            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1107            {
   1108              /* Enable the main output */
   1109              __HAL_TIM_MOE_ENABLE(htim);
   1110            }
   1111          
   1112            /* Enable the Peripheral */
   1113            __HAL_TIM_ENABLE(htim);
   1114          
   1115            /* Return function status */
   1116            return HAL_OK;
   1117          }
   1118          
   1119          /**
   1120            * @brief  Stops the PWM signal generation.
   1121            * @param  htim : TIM handle
   1122            * @param  Channel : TIM Channels to be disabled
   1123            *          This parameter can be one of the following values:
   1124            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1125            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1126            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1127            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1128            * @retval HAL status
   1129          */
   1130          HAL_StatusTypeDef HAL_TIM_PWM_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1131          {
   1132            /* Check the parameters */
   1133            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1134          
   1135            /* Disable the Capture compare channel */
   1136            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1137          
   1138            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1139            {
   1140              /* Disable the Main Ouput */
   1141              __HAL_TIM_MOE_DISABLE(htim);
   1142            }
   1143          
   1144            /* Disable the Peripheral */
   1145            __HAL_TIM_DISABLE(htim);
   1146          
   1147            /* Change the htim state */
   1148            htim->State = HAL_TIM_STATE_READY;
   1149          
   1150            /* Return function status */
   1151            return HAL_OK;
   1152          }
   1153          
   1154          /**
   1155            * @brief  Starts the PWM signal generation in interrupt mode.
   1156            * @param  htim : TIM handle
   1157            * @param  Channel : TIM Channel to be enabled
   1158            *          This parameter can be one of the following values:
   1159            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1160            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1161            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1162            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1163            * @retval HAL status
   1164          */
   1165          HAL_StatusTypeDef HAL_TIM_PWM_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1166          {
   1167            /* Check the parameters */
   1168            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1169          
   1170            switch (Channel)
   1171            {
   1172              case TIM_CHANNEL_1:
   1173              {
   1174                /* Enable the TIM Capture/Compare 1 interrupt */
   1175                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1176              }
   1177              break;
   1178          
   1179              case TIM_CHANNEL_2:
   1180              {
   1181                /* Enable the TIM Capture/Compare 2 interrupt */
   1182                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1183              }
   1184              break;
   1185          
   1186              case TIM_CHANNEL_3:
   1187              {
   1188                /* Enable the TIM Capture/Compare 3 interrupt */
   1189                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1190              }
   1191              break;
   1192          
   1193              case TIM_CHANNEL_4:
   1194              {
   1195                /* Enable the TIM Capture/Compare 4 interrupt */
   1196                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1197              }
   1198              break;
   1199          
   1200              default:
   1201              break;
   1202            }
   1203          
   1204            /* Enable the Capture compare channel */
   1205            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1206          
   1207            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1208            {
   1209              /* Enable the main output */
   1210              __HAL_TIM_MOE_ENABLE(htim);
   1211            }
   1212          
   1213            /* Enable the Peripheral */
   1214            __HAL_TIM_ENABLE(htim);
   1215          
   1216            /* Return function status */
   1217            return HAL_OK;
   1218          }
   1219          
   1220          /**
   1221            * @brief  Stops the PWM signal generation in interrupt mode.
   1222            * @param  htim : TIM handle
   1223            * @param  Channel : TIM Channels to be disabled
   1224            *          This parameter can be one of the following values:
   1225            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1226            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1227            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1228            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1229            * @retval HAL status
   1230          */
   1231          HAL_StatusTypeDef HAL_TIM_PWM_Stop_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1232          {
   1233            /* Check the parameters */
   1234            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1235          
   1236            switch (Channel)
   1237            {
   1238              case TIM_CHANNEL_1:
   1239              {
   1240                /* Disable the TIM Capture/Compare 1 interrupt */
   1241                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1242              }
   1243              break;
   1244          
   1245              case TIM_CHANNEL_2:
   1246              {
   1247                /* Disable the TIM Capture/Compare 2 interrupt */
   1248                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1249              }
   1250              break;
   1251          
   1252              case TIM_CHANNEL_3:
   1253              {
   1254                /* Disable the TIM Capture/Compare 3 interrupt */
   1255                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1256              }
   1257              break;
   1258          
   1259              case TIM_CHANNEL_4:
   1260              {
   1261                /* Disable the TIM Capture/Compare 4 interrupt */
   1262                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1263              }
   1264              break;
   1265          
   1266              default:
   1267              break;
   1268            }
   1269          
   1270            /* Disable the Capture compare channel */
   1271            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1272          
   1273            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1274            {
   1275              /* Disable the Main Ouput */
   1276              __HAL_TIM_MOE_DISABLE(htim);
   1277            }
   1278          
   1279            /* Disable the Peripheral */
   1280            __HAL_TIM_DISABLE(htim);
   1281          
   1282            /* Return function status */
   1283            return HAL_OK;
   1284          }
   1285          
   1286          /**
   1287            * @brief  Starts the TIM PWM signal generation in DMA mode.
   1288            * @param  htim : TIM handle
   1289            * @param  Channel : TIM Channels to be enabled
   1290            *          This parameter can be one of the following values:
   1291            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1292            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1293            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1294            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1295            * @param  pData : The source Buffer address.
   1296            * @param  Length : The length of data to be transferred from memory to TIM peripheral
   1297            * @retval HAL status
   1298          */
   1299          HAL_StatusTypeDef HAL_TIM_PWM_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1300          {
   1301            /* Check the parameters */
   1302            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1303          
   1304            if((htim->State == HAL_TIM_STATE_BUSY))
   1305            {
   1306               return HAL_BUSY;
   1307            }
   1308            else if((htim->State == HAL_TIM_STATE_READY))
   1309            {
   1310              if(((uint32_t)pData == 0U) && (Length > 0U))
   1311              {
   1312                return HAL_ERROR;
   1313              }
   1314              else
   1315              {
   1316                htim->State = HAL_TIM_STATE_BUSY;
   1317              }
   1318            }
   1319            switch (Channel)
   1320            {
   1321              case TIM_CHANNEL_1:
   1322              {
   1323                /* Set the DMA Period elapsed callback */
   1324                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1325          
   1326                /* Set the DMA error callback */
   1327                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1328          
   1329                /* Enable the DMA channel */
   1330                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)pData, (uint32_t)&htim->Instance->CCR1, Length);
   1331          
   1332                /* Enable the TIM Capture/Compare 1 DMA request */
   1333                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1334              }
   1335              break;
   1336          
   1337              case TIM_CHANNEL_2:
   1338              {
   1339                /* Set the DMA Period elapsed callback */
   1340                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1341          
   1342                /* Set the DMA error callback */
   1343                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1344          
   1345                /* Enable the DMA channel */
   1346                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)pData, (uint32_t)&htim->Instance->CCR2, Length);
   1347          
   1348                /* Enable the TIM Capture/Compare 2 DMA request */
   1349                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1350              }
   1351              break;
   1352          
   1353              case TIM_CHANNEL_3:
   1354              {
   1355                /* Set the DMA Period elapsed callback */
   1356                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1357          
   1358                /* Set the DMA error callback */
   1359                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1360          
   1361                /* Enable the DMA channel */
   1362                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)pData, (uint32_t)&htim->Instance->CCR3,Length);
   1363          
   1364                /* Enable the TIM Output Capture/Compare 3 request */
   1365                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1366              }
   1367              break;
   1368          
   1369              case TIM_CHANNEL_4:
   1370              {
   1371               /* Set the DMA Period elapsed callback */
   1372                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMADelayPulseCplt;
   1373          
   1374                /* Set the DMA error callback */
   1375                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1376          
   1377                /* Enable the DMA channel */
   1378                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)pData, (uint32_t)&htim->Instance->CCR4, Length);
   1379          
   1380                /* Enable the TIM Capture/Compare 4 DMA request */
   1381                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1382              }
   1383              break;
   1384          
   1385              default:
   1386              break;
   1387            }
   1388          
   1389            /* Enable the Capture compare channel */
   1390            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1391          
   1392            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1393            {
   1394              /* Enable the main output */
   1395              __HAL_TIM_MOE_ENABLE(htim);
   1396            }
   1397          
   1398            /* Enable the Peripheral */
   1399            __HAL_TIM_ENABLE(htim);
   1400          
   1401            /* Return function status */
   1402            return HAL_OK;
   1403          }
   1404          
   1405          /**
   1406            * @brief  Stops the TIM PWM signal generation in DMA mode.
   1407            * @param  htim : TIM handle
   1408            * @param  Channel : TIM Channels to be disabled
   1409            *          This parameter can be one of the following values:
   1410            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1411            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1412            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1413            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1414            * @retval HAL status
   1415          */
   1416          HAL_StatusTypeDef HAL_TIM_PWM_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1417          {
   1418            /* Check the parameters */
   1419            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1420          
   1421            switch (Channel)
   1422            {
   1423              case TIM_CHANNEL_1:
   1424              {
   1425                /* Disable the TIM Capture/Compare 1 DMA request */
   1426                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1427              }
   1428              break;
   1429          
   1430              case TIM_CHANNEL_2:
   1431              {
   1432                /* Disable the TIM Capture/Compare 2 DMA request */
   1433                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1434              }
   1435              break;
   1436          
   1437              case TIM_CHANNEL_3:
   1438              {
   1439                /* Disable the TIM Capture/Compare 3 DMA request */
   1440                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1441              }
   1442              break;
   1443          
   1444              case TIM_CHANNEL_4:
   1445              {
   1446                /* Disable the TIM Capture/Compare 4 interrupt */
   1447                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1448              }
   1449              break;
   1450          
   1451              default:
   1452              break;
   1453            }
   1454          
   1455            /* Disable the Capture compare channel */
   1456            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1457          
   1458            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   1459            {
   1460              /* Disable the Main Ouput */
   1461              __HAL_TIM_MOE_DISABLE(htim);
   1462            }
   1463          
   1464            /* Disable the Peripheral */
   1465            __HAL_TIM_DISABLE(htim);
   1466          
   1467            /* Change the htim state */
   1468            htim->State = HAL_TIM_STATE_READY;
   1469          
   1470            /* Return function status */
   1471            return HAL_OK;
   1472          }
   1473          
   1474          /**
   1475            * @}
   1476            */
   1477          
   1478          /** @defgroup TIM_Exported_Functions_Group4 Time Input Capture functions 
   1479           *  @brief    Time Input Capture functions 
   1480           *
   1481          @verbatim 
   1482            ==============================================================================
   1483                        ##### Time Input Capture functions #####
   1484            ==============================================================================
   1485           [..]
   1486             This section provides functions allowing to:
   1487             (+) Initialize and configure the TIM Input Capture.
   1488             (+) De-initialize the TIM Input Capture.
   1489             (+) Start the Time Input Capture.
   1490             (+) Stop the Time Input Capture.
   1491             (+) Start the Time Input Capture and enable interrupt.
   1492             (+) Stop the Time Input Capture and disable interrupt.
   1493             (+) Start the Time Input Capture and enable DMA transfer.
   1494             (+) Stop the Time Input Capture and disable DMA transfer.
   1495          
   1496          @endverbatim
   1497            * @{
   1498            */
   1499          /**
   1500            * @brief  Initializes the TIM Input Capture Time base according to the specified
   1501            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1502            * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1503            *       requires a timer reset to avoid unexpected direction
   1504            *       due to DIR bit readonly in center aligned mode.
   1505            *       Ex: call @ref HAL_TIM_IC_DeInit() before HAL_TIM_IC_Init()
   1506            * @param  htim : TIM Input Capture handle
   1507            * @retval HAL status
   1508            */
   1509          HAL_StatusTypeDef HAL_TIM_IC_Init(TIM_HandleTypeDef *htim)
   1510          {
   1511            /* Check the TIM handle allocation */
   1512            if(htim == NULL)
   1513            {
   1514              return HAL_ERROR;
   1515            }
   1516          
   1517            /* Check the parameters */
   1518            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1519            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1520            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1521            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   1522          
   1523            if(htim->State == HAL_TIM_STATE_RESET)
   1524            {
   1525              /* Allocate lock resource and initialize it */
   1526              htim->Lock = HAL_UNLOCKED;
   1527              
   1528              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   1529              HAL_TIM_IC_MspInit(htim);
   1530            }
   1531          
   1532            /* Set the TIM state */
   1533            htim->State= HAL_TIM_STATE_BUSY;
   1534          
   1535            /* Init the base time for the input capture */
   1536            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   1537          
   1538            /* Initialize the TIM state*/
   1539            htim->State= HAL_TIM_STATE_READY;
   1540          
   1541            return HAL_OK;
   1542          }
   1543          
   1544          /**
   1545            * @brief  DeInitializes the TIM peripheral 
   1546            * @param  htim : TIM Input Capture handle
   1547            * @retval HAL status
   1548            */
   1549          HAL_StatusTypeDef HAL_TIM_IC_DeInit(TIM_HandleTypeDef *htim)
   1550          {
   1551            /* Check the parameters */
   1552            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1553          
   1554            htim->State = HAL_TIM_STATE_BUSY;
   1555          
   1556            /* Disable the TIM Peripheral Clock */
   1557            __HAL_TIM_DISABLE(htim);
   1558          
   1559            /* DeInit the low level hardware: GPIO, CLOCK, NVIC and DMA */
   1560            HAL_TIM_IC_MspDeInit(htim);
   1561          
   1562            /* Change TIM state */
   1563            htim->State = HAL_TIM_STATE_RESET;
   1564          
   1565            /* Release Lock */
   1566            __HAL_UNLOCK(htim);
   1567          
   1568            return HAL_OK;
   1569          }
   1570          
   1571          /**
   1572            * @brief  Initializes the TIM Input Capture MSP.
   1573            * @param  htim : TIM handle
   1574            * @retval None
   1575            */
   1576          __weak void HAL_TIM_IC_MspInit(TIM_HandleTypeDef *htim)
   1577          {
   1578            /* Prevent unused argument(s) compilation warning */
   1579            UNUSED(htim);
   1580            /* NOTE : This function Should not be modified, when the callback is needed,
   1581                      the HAL_TIM_IC_MspInit could be implemented in the user file
   1582             */
   1583          }
   1584          
   1585          /**
   1586            * @brief  DeInitializes TIM Input Capture MSP.
   1587            * @param  htim : TIM handle
   1588            * @retval None
   1589            */
   1590          __weak void HAL_TIM_IC_MspDeInit(TIM_HandleTypeDef *htim)
   1591          {
   1592            /* Prevent unused argument(s) compilation warning */
   1593            UNUSED(htim);
   1594            /* NOTE : This function Should not be modified, when the callback is needed,
   1595                      the HAL_TIM_IC_MspDeInit could be implemented in the user file
   1596             */
   1597          }
   1598          
   1599          /**
   1600            * @brief  Starts the TIM Input Capture measurement.
   1601            * @param  htim : TIM Input Capture handle
   1602            * @param  Channel : TIM Channels to be enabled
   1603            *          This parameter can be one of the following values:
   1604            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1605            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1606            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1607            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1608            * @retval HAL status
   1609          */
   1610          HAL_StatusTypeDef HAL_TIM_IC_Start (TIM_HandleTypeDef *htim, uint32_t Channel)
   1611          {
   1612            /* Check the parameters */
   1613            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1614          
   1615            /* Enable the Input Capture channel */
   1616            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1617          
   1618            /* Enable the Peripheral */
   1619            __HAL_TIM_ENABLE(htim);
   1620          
   1621            /* Return function status */
   1622            return HAL_OK;
   1623          }
   1624          
   1625          /**
   1626            * @brief  Stops the TIM Input Capture measurement.
   1627            * @param  htim : TIM handle
   1628            * @param  Channel : TIM Channels to be disabled
   1629            *          This parameter can be one of the following values:
   1630            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1631            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1632            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1633            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1634            * @retval HAL status
   1635          */
   1636          HAL_StatusTypeDef HAL_TIM_IC_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   1637          {
   1638            /* Check the parameters */
   1639            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1640          
   1641            /* Disable the Input Capture channel */
   1642            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1643          
   1644            /* Disable the Peripheral */
   1645            __HAL_TIM_DISABLE(htim);
   1646          
   1647            /* Return function status */
   1648            return HAL_OK;
   1649          }
   1650          
   1651          /**
   1652            * @brief  Starts the TIM Input Capture measurement in interrupt mode.
   1653            * @param  htim : TIM Input Capture handle
   1654            * @param  Channel : TIM Channels to be enabled
   1655            *          This parameter can be one of the following values:
   1656            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1657            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1658            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1659            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1660            * @retval HAL status
   1661          */
   1662          HAL_StatusTypeDef HAL_TIM_IC_Start_IT (TIM_HandleTypeDef *htim, uint32_t Channel)
   1663          {
   1664            /* Check the parameters */
   1665            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1666          
   1667            switch (Channel)
   1668            {
   1669              case TIM_CHANNEL_1:
   1670              {
   1671                /* Enable the TIM Capture/Compare 1 interrupt */
   1672                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   1673              }
   1674              break;
   1675          
   1676              case TIM_CHANNEL_2:
   1677              {
   1678                /* Enable the TIM Capture/Compare 2 interrupt */
   1679                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   1680              }
   1681              break;
   1682          
   1683              case TIM_CHANNEL_3:
   1684              {
   1685                /* Enable the TIM Capture/Compare 3 interrupt */
   1686                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC3);
   1687              }
   1688              break;
   1689          
   1690              case TIM_CHANNEL_4:
   1691              {
   1692                /* Enable the TIM Capture/Compare 4 interrupt */
   1693                __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC4);
   1694              }
   1695              break;
   1696          
   1697              default:
   1698              break;
   1699            }
   1700            /* Enable the Input Capture channel */
   1701            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1702          
   1703            /* Enable the Peripheral */
   1704            __HAL_TIM_ENABLE(htim);
   1705          
   1706            /* Return function status */
   1707            return HAL_OK;
   1708          }
   1709          
   1710          /**
   1711            * @brief  Stops the TIM Input Capture measurement in interrupt mode.
   1712            * @param  htim : TIM handle
   1713            * @param  Channel : TIM Channels to be disabled
   1714            *          This parameter can be one of the following values:
   1715            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1716            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1717            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1718            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1719            * @retval HAL status
   1720          */
   1721          HAL_StatusTypeDef HAL_TIM_IC_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   1722          {
   1723            /* Check the parameters */
   1724            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1725          
   1726            switch (Channel)
   1727            {
   1728              case TIM_CHANNEL_1:
   1729              {
   1730                /* Disable the TIM Capture/Compare 1 interrupt */
   1731                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   1732              }
   1733              break;
   1734          
   1735              case TIM_CHANNEL_2:
   1736              {
   1737                /* Disable the TIM Capture/Compare 2 interrupt */
   1738                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   1739              }
   1740              break;
   1741          
   1742              case TIM_CHANNEL_3:
   1743              {
   1744                /* Disable the TIM Capture/Compare 3 interrupt */
   1745                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC3);
   1746              }
   1747              break;
   1748          
   1749              case TIM_CHANNEL_4:
   1750              {
   1751                /* Disable the TIM Capture/Compare 4 interrupt */
   1752                __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC4);
   1753              }
   1754              break;
   1755          
   1756              default:
   1757              break;
   1758            }
   1759          
   1760            /* Disable the Input Capture channel */
   1761            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1762          
   1763            /* Disable the Peripheral */
   1764            __HAL_TIM_DISABLE(htim);
   1765          
   1766            /* Return function status */
   1767            return HAL_OK;
   1768          }
   1769          
   1770          /**
   1771            * @brief  Starts the TIM Input Capture measurement in DMA mode.
   1772            * @param  htim : TIM Input Capture handle
   1773            * @param  Channel : TIM Channels to be enabled
   1774            *          This parameter can be one of the following values:
   1775            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1776            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1777            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1778            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1779            * @param  pData : The destination Buffer address.
   1780            * @param  Length : The length of data to be transferred from TIM peripheral to memory.
   1781            * @retval HAL status
   1782          */
   1783          HAL_StatusTypeDef HAL_TIM_IC_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData, uint16_t Length)
   1784          {
   1785            /* Check the parameters */
   1786            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1787            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1788          
   1789            if((htim->State == HAL_TIM_STATE_BUSY))
   1790            {
   1791               return HAL_BUSY;
   1792            }
   1793            else if((htim->State == HAL_TIM_STATE_READY))
   1794            {
   1795              if((pData == 0U) && (Length > 0U))
   1796              {
   1797                return HAL_ERROR;
   1798              }
   1799              else
   1800              {
   1801                htim->State = HAL_TIM_STATE_BUSY;
   1802              }
   1803            }
   1804          
   1805            switch (Channel)
   1806            {
   1807              case TIM_CHANNEL_1:
   1808              {
   1809                /* Set the DMA Period elapsed callback */
   1810                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   1811          
   1812                /* Set the DMA error callback */
   1813                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   1814          
   1815                /* Enable the DMA channel */
   1816                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData, Length);
   1817          
   1818                /* Enable the TIM Capture/Compare 1 DMA request */
   1819                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   1820              }
   1821              break;
   1822          
   1823              case TIM_CHANNEL_2:
   1824              {
   1825                /* Set the DMA Period elapsed callback */
   1826                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   1827          
   1828                /* Set the DMA error callback */
   1829                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   1830          
   1831                /* Enable the DMA channel */
   1832                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData, Length);
   1833          
   1834                /* Enable the TIM Capture/Compare 2  DMA request */
   1835                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   1836              }
   1837              break;
   1838          
   1839              case TIM_CHANNEL_3:
   1840              {
   1841                /* Set the DMA Period elapsed callback */
   1842                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback = TIM_DMACaptureCplt;
   1843          
   1844                /* Set the DMA error callback */
   1845                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   1846          
   1847                /* Enable the DMA channel */
   1848                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->CCR3, (uint32_t)pData, Length);
   1849          
   1850                /* Enable the TIM Capture/Compare 3  DMA request */
   1851                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC3);
   1852              }
   1853              break;
   1854          
   1855              case TIM_CHANNEL_4:
   1856              {
   1857                /* Set the DMA Period elapsed callback */
   1858                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback = TIM_DMACaptureCplt;
   1859          
   1860                /* Set the DMA error callback */
   1861                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   1862          
   1863                /* Enable the DMA channel */
   1864                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->CCR4, (uint32_t)pData, Length);
   1865          
   1866                /* Enable the TIM Capture/Compare 4  DMA request */
   1867                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC4);
   1868              }
   1869              break;
   1870          
   1871              default:
   1872              break;
   1873            }
   1874          
   1875            /* Enable the Input Capture channel */
   1876            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_ENABLE);
   1877          
   1878            /* Enable the Peripheral */
   1879            __HAL_TIM_ENABLE(htim);
   1880          
   1881            /* Return function status */
   1882            return HAL_OK;
   1883          }
   1884          
   1885          /**
   1886            * @brief  Stops the TIM Input Capture measurement in DMA mode.
   1887            * @param  htim : TIM Input Capture handle
   1888            * @param  Channel : TIM Channels to be disabled
   1889            *          This parameter can be one of the following values:
   1890            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   1891            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   1892            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   1893            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   1894            * @retval HAL status
   1895          */
   1896          HAL_StatusTypeDef HAL_TIM_IC_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   1897          {
   1898            /* Check the parameters */
   1899            assert_param(IS_TIM_CCX_INSTANCE(htim->Instance, Channel));
   1900            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   1901          
   1902            switch (Channel)
   1903            {
   1904              case TIM_CHANNEL_1:
   1905              {
   1906                /* Disable the TIM Capture/Compare 1 DMA request */
   1907                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   1908              }
   1909              break;
   1910          
   1911              case TIM_CHANNEL_2:
   1912              {
   1913                /* Disable the TIM Capture/Compare 2 DMA request */
   1914                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   1915              }
   1916              break;
   1917          
   1918              case TIM_CHANNEL_3:
   1919              {
   1920                /* Disable the TIM Capture/Compare 3  DMA request */
   1921                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC3);
   1922              }
   1923              break;
   1924          
   1925              case TIM_CHANNEL_4:
   1926              {
   1927                /* Disable the TIM Capture/Compare 4  DMA request */
   1928                __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC4);
   1929              }
   1930              break;
   1931          
   1932              default:
   1933              break;
   1934            }
   1935          
   1936            /* Disable the Input Capture channel */
   1937            TIM_CCxChannelCmd(htim->Instance, Channel, TIM_CCx_DISABLE);
   1938          
   1939            /* Disable the Peripheral */
   1940            __HAL_TIM_DISABLE(htim);
   1941          
   1942            /* Change the htim state */
   1943            htim->State = HAL_TIM_STATE_READY;
   1944          
   1945            /* Return function status */
   1946            return HAL_OK;
   1947          }
   1948          /**
   1949            * @}
   1950            */
   1951          
   1952          /** @defgroup TIM_Exported_Functions_Group5 Time One Pulse functions 
   1953           *  @brief    Time One Pulse functions 
   1954           *
   1955          @verbatim 
   1956            ==============================================================================
   1957                                  ##### Time One Pulse functions #####
   1958            ==============================================================================
   1959            [..]
   1960              This section provides functions allowing to:
   1961              (+) Initialize and configure the TIM One Pulse.
   1962              (+) De-initialize the TIM One Pulse.
   1963              (+) Start the Time One Pulse.
   1964              (+) Stop the Time One Pulse.
   1965              (+) Start the Time One Pulse and enable interrupt.
   1966              (+) Stop the Time One Pulse and disable interrupt.
   1967              (+) Start the Time One Pulse and enable DMA transfer.
   1968              (+) Stop the Time One Pulse and disable DMA transfer.
   1969          
   1970          @endverbatim
   1971            * @{
   1972            */
   1973          /**
   1974            * @brief  Initializes the TIM One Pulse Time Base according to the specified
   1975            *         parameters in the TIM_HandleTypeDef and create the associated handle.
   1976            * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   1977            *       requires a timer reset to avoid unexpected direction
   1978            *       due to DIR bit readonly in center aligned mode.
   1979            *       Ex: call @ref HAL_TIM_OnePulse_DeInit() before HAL_TIM_OnePulse_Init()
   1980            * @param  htim : TIM OnePulse handle
   1981            * @param  OnePulseMode : Select the One pulse mode.
   1982            *         This parameter can be one of the following values:
   1983            *            @arg TIM_OPMODE_SINGLE: Only one pulse will be generated.
   1984            *            @arg TIM_OPMODE_REPETITIVE: Repetitive pulses wil be generated.
   1985            * @retval HAL status
   1986            */
   1987          HAL_StatusTypeDef HAL_TIM_OnePulse_Init(TIM_HandleTypeDef *htim, uint32_t OnePulseMode)
   1988          {
   1989            /* Check the TIM handle allocation */
   1990            if(htim == NULL)
   1991            {
   1992              return HAL_ERROR;
   1993            }
   1994          
   1995            /* Check the parameters */
   1996            assert_param(IS_TIM_INSTANCE(htim->Instance));
   1997            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   1998            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   1999            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2000            assert_param(IS_TIM_OPM_MODE(OnePulseMode));
   2001          
   2002            if(htim->State == HAL_TIM_STATE_RESET)
   2003            {
   2004              /* Allocate lock resource and initialize it */
   2005              htim->Lock = HAL_UNLOCKED;
   2006              
   2007              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2008              HAL_TIM_OnePulse_MspInit(htim);
   2009            }
   2010          
   2011            /* Set the TIM state */
   2012            htim->State= HAL_TIM_STATE_BUSY;
   2013          
   2014            /* Configure the Time base in the One Pulse Mode */
   2015            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2016          
   2017            /* Reset the OPM Bit */
   2018            htim->Instance->CR1 &= ~TIM_CR1_OPM;
   2019          
   2020            /* Configure the OPM Mode */
   2021            htim->Instance->CR1 |= OnePulseMode;
   2022          
   2023            /* Initialize the TIM state*/
   2024            htim->State= HAL_TIM_STATE_READY;
   2025          
   2026            return HAL_OK;
   2027          }
   2028          
   2029          /**
   2030            * @brief  DeInitializes the TIM One Pulse 
   2031            * @param  htim : TIM One Pulse handle
   2032            * @retval HAL status
   2033            */
   2034          HAL_StatusTypeDef HAL_TIM_OnePulse_DeInit(TIM_HandleTypeDef *htim)
   2035          {
   2036            /* Check the parameters */
   2037            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2038          
   2039            htim->State = HAL_TIM_STATE_BUSY;
   2040          
   2041            /* Disable the TIM Peripheral Clock */
   2042            __HAL_TIM_DISABLE(htim);
   2043          
   2044            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2045            HAL_TIM_OnePulse_MspDeInit(htim);
   2046          
   2047            /* Change TIM state */
   2048            htim->State = HAL_TIM_STATE_RESET;
   2049          
   2050            /* Release Lock */
   2051            __HAL_UNLOCK(htim);
   2052          
   2053            return HAL_OK;
   2054          }
   2055          
   2056          /**
   2057            * @brief  Initializes the TIM One Pulse MSP.
   2058            * @param  htim : TIM handle
   2059            * @retval None
   2060            */
   2061          __weak void HAL_TIM_OnePulse_MspInit(TIM_HandleTypeDef *htim)
   2062          {
   2063            /* Prevent unused argument(s) compilation warning */
   2064            UNUSED(htim);
   2065            /* NOTE : This function Should not be modified, when the callback is needed,
   2066                      the HAL_TIM_OnePulse_MspInit could be implemented in the user file
   2067             */
   2068          }
   2069          
   2070          /**
   2071            * @brief  DeInitializes TIM One Pulse MSP.
   2072            * @param  htim : TIM handle
   2073            * @retval None
   2074            */
   2075          __weak void HAL_TIM_OnePulse_MspDeInit(TIM_HandleTypeDef *htim)
   2076          {
   2077            /* Prevent unused argument(s) compilation warning */
   2078            UNUSED(htim);
   2079            /* NOTE : This function Should not be modified, when the callback is needed,
   2080                      the HAL_TIM_OnePulse_MspDeInit could be implemented in the user file
   2081             */
   2082          }
   2083          
   2084          /**
   2085            * @brief  Starts the TIM One Pulse signal generation.
   2086            * @param  htim : TIM One Pulse handle
   2087            * @param  OutputChannel : TIM Channels to be enabled
   2088            *          This parameter can be one of the following values:
   2089            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2090            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2091            * @retval HAL status
   2092          */
   2093          HAL_StatusTypeDef HAL_TIM_OnePulse_Start(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2094          {
   2095            /* Prevent unused argument(s) compilation warning */
   2096            UNUSED(OutputChannel);
   2097          
   2098            /* Enable the Capture compare and the Input Capture channels 
   2099              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2100              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2101              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2102              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2103          
   2104              No need to enable the counter, it's enabled automatically by hardware 
   2105              (the counter starts in response to a stimulus and generate a pulse */
   2106          
   2107            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2108            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2109          
   2110            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2111            {
   2112              /* Enable the main output */
   2113              __HAL_TIM_MOE_ENABLE(htim);
   2114            }
   2115          
   2116            /* Return function status */
   2117            return HAL_OK;
   2118          }
   2119          
   2120          /**
   2121            * @brief  Stops the TIM One Pulse signal generation.
   2122            * @param  htim : TIM One Pulse handle
   2123            * @param  OutputChannel : TIM Channels to be disable
   2124            *          This parameter can be one of the following values:
   2125            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2126            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2127            * @retval HAL status
   2128          */
   2129          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2130          {
   2131            /* Prevent unused argument(s) compilation warning */
   2132            UNUSED(OutputChannel);
   2133          
   2134            /* Disable the Capture compare and the Input Capture channels
   2135            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2136            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2137            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2138            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2139          
   2140            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2141            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2142          
   2143            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2144            {
   2145              /* Disable the Main Ouput */
   2146              __HAL_TIM_MOE_DISABLE(htim);
   2147            }
   2148          
   2149            /* Disable the Peripheral */
   2150            __HAL_TIM_DISABLE(htim);
   2151          
   2152            /* Return function status */
   2153            return HAL_OK;
   2154          }
   2155          
   2156          /**
   2157            * @brief  Starts the TIM One Pulse signal generation in interrupt mode.
   2158            * @param  htim : TIM One Pulse handle
   2159            * @param  OutputChannel : TIM Channels to be enabled
   2160            *          This parameter can be one of the following values:
   2161            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2162            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2163            * @retval HAL status
   2164          */
   2165          HAL_StatusTypeDef HAL_TIM_OnePulse_Start_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2166          {
   2167            /* Prevent unused argument(s) compilation warning */
   2168            UNUSED(OutputChannel);
   2169          
   2170            /* Enable the Capture compare and the Input Capture channels 
   2171              (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2172              if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2173              if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2174              in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be enabled together 
   2175          
   2176              No need to enable the counter, it's enabled automatically by hardware 
   2177              (the counter starts in response to a stimulus and generate a pulse */
   2178          
   2179            /* Enable the TIM Capture/Compare 1 interrupt */
   2180            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2181          
   2182            /* Enable the TIM Capture/Compare 2 interrupt */
   2183            __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2184          
   2185            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2186            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2187          
   2188            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2189            {
   2190              /* Enable the main output */
   2191              __HAL_TIM_MOE_ENABLE(htim);
   2192            }
   2193          
   2194            /* Return function status */
   2195            return HAL_OK;
   2196          }
   2197          
   2198          /**
   2199            * @brief  Stops the TIM One Pulse signal generation in interrupt mode.
   2200            * @param  htim : TIM One Pulse handle
   2201            * @param  OutputChannel : TIM Channels to be enabled
   2202            *          This parameter can be one of the following values:
   2203            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2204            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2205            * @retval HAL status
   2206          */
   2207          HAL_StatusTypeDef HAL_TIM_OnePulse_Stop_IT(TIM_HandleTypeDef *htim, uint32_t OutputChannel)
   2208          {
   2209            /* Prevent unused argument(s) compilation warning */
   2210            UNUSED(OutputChannel);
   2211          
   2212            /* Disable the TIM Capture/Compare 1 interrupt */
   2213            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2214          
   2215            /* Disable the TIM Capture/Compare 2 interrupt */
   2216            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2217          
   2218            /* Disable the Capture compare and the Input Capture channels 
   2219            (in the OPM Mode the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2)
   2220            if TIM_CHANNEL_1 is used as output, the TIM_CHANNEL_2 will be used as input and
   2221            if TIM_CHANNEL_1 is used as input, the TIM_CHANNEL_2 will be used as output 
   2222            in all combinations, the TIM_CHANNEL_1 and TIM_CHANNEL_2 should be disabled together */
   2223            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2224            TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2225          
   2226            if(IS_TIM_BREAK_INSTANCE(htim->Instance) != RESET)
   2227            {
   2228              /* Disable the Main Ouput */
   2229              __HAL_TIM_MOE_DISABLE(htim);
   2230            }
   2231          
   2232            /* Disable the Peripheral */
   2233             __HAL_TIM_DISABLE(htim);
   2234          
   2235            /* Return function status */
   2236            return HAL_OK;
   2237          }
   2238          
   2239          /**
   2240            * @}
   2241            */
   2242          
   2243          /** @defgroup TIM_Exported_Functions_Group6 Time Encoder functions 
   2244           *  @brief    Time Encoder functions 
   2245           *
   2246          @verbatim 
   2247            ==============================================================================
   2248                                    ##### Time Encoder functions #####
   2249            ==============================================================================
   2250            [..]
   2251              This section provides functions allowing to:
   2252              (+) Initialize and configure the TIM Encoder.
   2253              (+) De-initialize the TIM Encoder.
   2254              (+) Start the Time Encoder.
   2255              (+) Stop the Time Encoder.
   2256              (+) Start the Time Encoder and enable interrupt.
   2257              (+) Stop the Time Encoder and disable interrupt.
   2258              (+) Start the Time Encoder and enable DMA transfer.
   2259              (+) Stop the Time Encoder and disable DMA transfer.
   2260          
   2261          @endverbatim
   2262            * @{
   2263            */
   2264          /**
   2265            * @brief  Initializes the TIM Encoder Interface and create the associated handle.
   2266            * @note Switching from Center Aligned counter mode to Edge counter mode (or reverse)
   2267            *       requires a timer reset to avoid unexpected direction
   2268            *       due to DIR bit readonly in center aligned mode.
   2269            *       Ex: call @ref HAL_TIM_Encoder_DeInit() before HAL_TIM_Encoder_Init()
   2270            * @param  htim : TIM Encoder Interface handle
   2271            * @param  sConfig : TIM Encoder Interface configuration structure
   2272            * @retval HAL status
   2273            */
   2274          HAL_StatusTypeDef HAL_TIM_Encoder_Init(TIM_HandleTypeDef *htim,  TIM_Encoder_InitTypeDef* sConfig)
   2275          {
   2276            uint32_t tmpsmcr = 0U;
   2277            uint32_t tmpccmr1 = 0U;
   2278            uint32_t tmpccer = 0U;
   2279          
   2280            /* Check the TIM handle allocation */
   2281            if(htim == NULL)
   2282            {
   2283              return HAL_ERROR;
   2284            }
   2285          
   2286            /* Check the parameters */
   2287            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2288            assert_param(IS_TIM_COUNTER_MODE(htim->Init.CounterMode));
   2289            assert_param(IS_TIM_CLOCKDIVISION_DIV(htim->Init.ClockDivision));
   2290            assert_param(IS_TIM_AUTORELOAD_PRELOAD(htim->Init.AutoReloadPreload));
   2291            assert_param(IS_TIM_ENCODER_MODE(sConfig->EncoderMode));
   2292            assert_param(IS_TIM_IC_SELECTION(sConfig->IC1Selection));
   2293            assert_param(IS_TIM_IC_SELECTION(sConfig->IC2Selection));
   2294            assert_param(IS_TIM_IC_POLARITY(sConfig->IC1Polarity));
   2295            assert_param(IS_TIM_IC_POLARITY(sConfig->IC2Polarity));
   2296            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC1Prescaler));
   2297            assert_param(IS_TIM_IC_PRESCALER(sConfig->IC2Prescaler));
   2298            assert_param(IS_TIM_IC_FILTER(sConfig->IC1Filter));
   2299            assert_param(IS_TIM_IC_FILTER(sConfig->IC2Filter));
   2300          
   2301            if(htim->State == HAL_TIM_STATE_RESET)
   2302            {
   2303              /* Allocate lock resource and initialize it */
   2304              htim->Lock = HAL_UNLOCKED;
   2305              
   2306              /* Init the low level hardware : GPIO, CLOCK, NVIC and DMA */
   2307              HAL_TIM_Encoder_MspInit(htim);
   2308            }
   2309          
   2310            /* Set the TIM state */
   2311            htim->State= HAL_TIM_STATE_BUSY;
   2312          
   2313            /* Reset the SMS bits */
   2314            htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   2315          
   2316            /* Configure the Time base in the Encoder Mode */
   2317            TIM_Base_SetConfig(htim->Instance, &htim->Init);
   2318          
   2319            /* Get the TIMx SMCR register value */
   2320            tmpsmcr = htim->Instance->SMCR;
   2321          
   2322            /* Get the TIMx CCMR1 register value */
   2323            tmpccmr1 = htim->Instance->CCMR1;
   2324          
   2325            /* Get the TIMx CCER register value */
   2326            tmpccer = htim->Instance->CCER;
   2327          
   2328            /* Set the encoder Mode */
   2329            tmpsmcr |= sConfig->EncoderMode;
   2330          
   2331            /* Select the Capture Compare 1 and the Capture Compare 2 as input */
   2332            tmpccmr1 &= ~(TIM_CCMR1_CC1S | TIM_CCMR1_CC2S);
   2333            tmpccmr1 |= (sConfig->IC1Selection | (sConfig->IC2Selection << 8U));
   2334          
   2335            /* Set the the Capture Compare 1 and the Capture Compare 2 prescalers and filters */
   2336            tmpccmr1 &= ~(TIM_CCMR1_IC1PSC | TIM_CCMR1_IC2PSC);
   2337            tmpccmr1 &= ~(TIM_CCMR1_IC1F | TIM_CCMR1_IC2F);
   2338            tmpccmr1 |= sConfig->IC1Prescaler | (sConfig->IC2Prescaler << 8U);
   2339            tmpccmr1 |= (sConfig->IC1Filter << 4U) | (sConfig->IC2Filter << 12U);
   2340          
   2341            /* Set the TI1 and the TI2 Polarities */
   2342            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC2P);
   2343            tmpccer &= ~(TIM_CCER_CC1NP | TIM_CCER_CC2NP);
   2344            tmpccer |= sConfig->IC1Polarity | (sConfig->IC2Polarity << 4U);
   2345          
   2346            /* Write to TIMx SMCR */
   2347            htim->Instance->SMCR = tmpsmcr;
   2348          
   2349            /* Write to TIMx CCMR1 */
   2350            htim->Instance->CCMR1 = tmpccmr1;
   2351          
   2352            /* Write to TIMx CCER */
   2353            htim->Instance->CCER = tmpccer;
   2354          
   2355            /* Initialize the TIM state*/
   2356            htim->State= HAL_TIM_STATE_READY;
   2357          
   2358            return HAL_OK;
   2359          }
   2360          
   2361          
   2362          /**
   2363            * @brief  DeInitializes the TIM Encoder interface 
   2364            * @param  htim : TIM Encoder handle
   2365            * @retval HAL status
   2366            */
   2367          HAL_StatusTypeDef HAL_TIM_Encoder_DeInit(TIM_HandleTypeDef *htim)
   2368          {
   2369            /* Check the parameters */
   2370            assert_param(IS_TIM_INSTANCE(htim->Instance));
   2371          
   2372            htim->State = HAL_TIM_STATE_BUSY;
   2373          
   2374            /* Disable the TIM Peripheral Clock */
   2375            __HAL_TIM_DISABLE(htim);
   2376          
   2377            /* DeInit the low level hardware: GPIO, CLOCK, NVIC */
   2378            HAL_TIM_Encoder_MspDeInit(htim);
   2379          
   2380            /* Change TIM state */
   2381            htim->State = HAL_TIM_STATE_RESET;
   2382          
   2383            /* Release Lock */
   2384            __HAL_UNLOCK(htim);
   2385          
   2386            return HAL_OK;
   2387          }
   2388          
   2389          /**
   2390            * @brief  Initializes the TIM Encoder Interface MSP.
   2391            * @param  htim : TIM handle
   2392            * @retval None
   2393            */
   2394          __weak void HAL_TIM_Encoder_MspInit(TIM_HandleTypeDef *htim)
   2395          {
   2396            /* Prevent unused argument(s) compilation warning */
   2397            UNUSED(htim);
   2398            /* NOTE : This function Should not be modified, when the callback is needed,
   2399                      the HAL_TIM_Encoder_MspInit could be implemented in the user file
   2400             */
   2401          }
   2402          
   2403          /**
   2404            * @brief  DeInitializes TIM Encoder Interface MSP.
   2405            * @param  htim : TIM handle
   2406            * @retval None
   2407            */
   2408          __weak void HAL_TIM_Encoder_MspDeInit(TIM_HandleTypeDef *htim)
   2409          {
   2410            /* Prevent unused argument(s) compilation warning */
   2411            UNUSED(htim);
   2412            /* NOTE : This function Should not be modified, when the callback is needed,
   2413                      the HAL_TIM_Encoder_MspDeInit could be implemented in the user file
   2414             */
   2415          }
   2416          
   2417          /**
   2418            * @brief  Starts the TIM Encoder Interface.
   2419            * @param  htim : TIM Encoder Interface handle
   2420            * @param  Channel : TIM Channels to be enabled
   2421            *          This parameter can be one of the following values:
   2422            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2423            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2424            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2425            * @retval HAL status
   2426          */
   2427          HAL_StatusTypeDef HAL_TIM_Encoder_Start(TIM_HandleTypeDef *htim, uint32_t Channel)
   2428          {
   2429            /* Check the parameters */
   2430            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2431          
   2432            /* Enable the encoder interface channels */
   2433            switch (Channel)
   2434            {
   2435              case TIM_CHANNEL_1:
   2436            {
   2437              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2438                break;
   2439            }
   2440              case TIM_CHANNEL_2:
   2441            {
   2442              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2443                break;
   2444            }
   2445              default :
   2446            {
   2447               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2448               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2449               break;
   2450              }
   2451            }
   2452            /* Enable the Peripheral */
   2453            __HAL_TIM_ENABLE(htim);
   2454          
   2455            /* Return function status */
   2456            return HAL_OK;
   2457          }
   2458          
   2459          /**
   2460            * @brief  Stops the TIM Encoder Interface.
   2461            * @param  htim : TIM Encoder Interface handle
   2462            * @param  Channel : TIM Channels to be disabled
   2463            *          This parameter can be one of the following values:
   2464            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2465            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2466            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2467            * @retval HAL status
   2468          */
   2469          HAL_StatusTypeDef HAL_TIM_Encoder_Stop(TIM_HandleTypeDef *htim, uint32_t Channel)
   2470          {
   2471            /* Check the parameters */
   2472              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2473          
   2474             /* Disable the Input Capture channels 1 and 2
   2475              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2476            switch (Channel)
   2477            {
   2478              case TIM_CHANNEL_1:
   2479            {
   2480               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2481                break;
   2482            }
   2483              case TIM_CHANNEL_2:
   2484            {
   2485              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2486                break;
   2487            }
   2488              default :
   2489            {
   2490              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2491              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2492               break;
   2493              }
   2494            }
   2495          
   2496            /* Disable the Peripheral */
   2497            __HAL_TIM_DISABLE(htim);
   2498          
   2499            /* Return function status */
   2500            return HAL_OK;
   2501          }
   2502          
   2503          /**
   2504            * @brief  Starts the TIM Encoder Interface in interrupt mode.
   2505            * @param  htim : TIM Encoder Interface handle
   2506            * @param  Channel : TIM Channels to be enabled
   2507            *          This parameter can be one of the following values:
   2508            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2509            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2510            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2511            * @retval HAL status
   2512          */
   2513          HAL_StatusTypeDef HAL_TIM_Encoder_Start_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2514          {
   2515            /* Check the parameters */
   2516            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2517          
   2518            /* Enable the encoder interface channels */
   2519            /* Enable the capture compare Interrupts 1 and/or 2 */
   2520            switch (Channel)
   2521            {
   2522              case TIM_CHANNEL_1:
   2523            {
   2524              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2525              __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2526                break;
   2527            }
   2528              case TIM_CHANNEL_2:
   2529            {
   2530              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2531              __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2532                break;
   2533            }
   2534              default :
   2535            {
   2536               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2537               TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2538               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC1);
   2539               __HAL_TIM_ENABLE_IT(htim, TIM_IT_CC2);
   2540               break;
   2541              }
   2542            }
   2543          
   2544            /* Enable the Peripheral */
   2545            __HAL_TIM_ENABLE(htim);
   2546          
   2547            /* Return function status */
   2548            return HAL_OK;
   2549          }
   2550          
   2551          /**
   2552            * @brief  Stops the TIM Encoder Interface in interrupt mode.
   2553            * @param  htim : TIM Encoder Interface handle
   2554            * @param  Channel : TIM Channels to be disabled
   2555            *          This parameter can be one of the following values:
   2556            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2557            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2558            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2559            * @retval HAL status
   2560          */
   2561          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_IT(TIM_HandleTypeDef *htim, uint32_t Channel)
   2562          {
   2563            /* Check the parameters */
   2564            assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2565          
   2566            /* Disable the Input Capture channels 1 and 2
   2567              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2568            if(Channel == TIM_CHANNEL_1)
   2569            {
   2570              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2571          
   2572              /* Disable the capture compare Interrupts 1 */
   2573            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2574            }
   2575            else if(Channel == TIM_CHANNEL_2)
   2576            {
   2577              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2578          
   2579              /* Disable the capture compare Interrupts 2 */
   2580            __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2581            }
   2582            else
   2583            {
   2584              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2585              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2586          
   2587              /* Disable the capture compare Interrupts 1 and 2 */
   2588              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC1);
   2589              __HAL_TIM_DISABLE_IT(htim, TIM_IT_CC2);
   2590            }
   2591          
   2592            /* Disable the Peripheral */
   2593            __HAL_TIM_DISABLE(htim);
   2594          
   2595            /* Change the htim state */
   2596            htim->State = HAL_TIM_STATE_READY;
   2597          
   2598            /* Return function status */
   2599            return HAL_OK;
   2600          }
   2601          
   2602          /**
   2603            * @brief  Starts the TIM Encoder Interface in DMA mode.
   2604            * @param  htim : TIM Encoder Interface handle
   2605            * @param  Channel : TIM Channels to be enabled
   2606            *          This parameter can be one of the following values:
   2607            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2608            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2609            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2610            * @param  pData1 : The destination Buffer address for IC1.
   2611            * @param  pData2 : The destination Buffer address for IC2.
   2612            * @param  Length : The length of data to be transferred from TIM peripheral to memory.
   2613            * @retval HAL status
   2614          */
   2615          HAL_StatusTypeDef HAL_TIM_Encoder_Start_DMA(TIM_HandleTypeDef *htim, uint32_t Channel, uint32_t *pData1, uint32_t *pData2, uint16_t Length)
   2616          {
   2617            /* Check the parameters */
   2618            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2619          
   2620            if((htim->State == HAL_TIM_STATE_BUSY))
   2621            {
   2622               return HAL_BUSY;
   2623            }
   2624            else if((htim->State == HAL_TIM_STATE_READY))
   2625            {
   2626              if((((pData1 == 0U) || (pData2 == 0U) )) && (Length > 0U))
   2627              {
   2628                return HAL_ERROR;
   2629              }
   2630              else
   2631              {
   2632                htim->State = HAL_TIM_STATE_BUSY;
   2633              }
   2634            }
   2635          
   2636            switch (Channel)
   2637            {
   2638              case TIM_CHANNEL_1:
   2639              {
   2640                /* Set the DMA Period elapsed callback */
   2641                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   2642          
   2643                /* Set the DMA error callback */
   2644                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   2645          
   2646                /* Enable the DMA channel */
   2647                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t )pData1, Length);
   2648          
   2649                /* Enable the TIM Input Capture DMA request */
   2650                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2651          
   2652                /* Enable the Peripheral */
   2653                __HAL_TIM_ENABLE(htim);
   2654          
   2655                /* Enable the Capture compare channel */
   2656                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2657              }
   2658              break;
   2659          
   2660              case TIM_CHANNEL_2:
   2661              {
   2662                /* Set the DMA Period elapsed callback */
   2663                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   2664          
   2665                /* Set the DMA error callback */
   2666                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError;
   2667                /* Enable the DMA channel */
   2668                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2669          
   2670                /* Enable the TIM Input Capture  DMA request */
   2671                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2672          
   2673                /* Enable the Peripheral */
   2674                __HAL_TIM_ENABLE(htim);
   2675          
   2676                /* Enable the Capture compare channel */
   2677                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2678              }
   2679              break;
   2680          
   2681              case TIM_CHANNEL_ALL:
   2682              {
   2683                /* Set the DMA Period elapsed callback */
   2684                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback = TIM_DMACaptureCplt;
   2685          
   2686                /* Set the DMA error callback */
   2687                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   2688          
   2689                /* Enable the DMA channel */
   2690                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->CCR1, (uint32_t)pData1, Length);
   2691          
   2692                /* Set the DMA Period elapsed callback */
   2693                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback = TIM_DMACaptureCplt;
   2694          
   2695                /* Set the DMA error callback */
   2696                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   2697          
   2698                /* Enable the DMA channel */
   2699                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->CCR2, (uint32_t)pData2, Length);
   2700          
   2701               /* Enable the Peripheral */
   2702                __HAL_TIM_ENABLE(htim);
   2703          
   2704                /* Enable the Capture compare channel */
   2705                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_ENABLE);
   2706                TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_ENABLE);
   2707          
   2708                /* Enable the TIM Input Capture  DMA request */
   2709                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC1);
   2710                /* Enable the TIM Input Capture  DMA request */
   2711                __HAL_TIM_ENABLE_DMA(htim, TIM_DMA_CC2);
   2712              }
   2713              break;
   2714          
   2715              default:
   2716              break;
   2717            }
   2718            /* Return function status */
   2719            return HAL_OK;
   2720          }
   2721          
   2722          /**
   2723            * @brief  Stops the TIM Encoder Interface in DMA mode.
   2724            * @param  htim : TIM Encoder Interface handle
   2725            * @param  Channel : TIM Channels to be enabled
   2726            *          This parameter can be one of the following values:
   2727            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2728            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2729            *            @arg TIM_CHANNEL_ALL: TIM Channel 1 and TIM Channel 2 are selected
   2730            * @retval HAL status
   2731          */
   2732          HAL_StatusTypeDef HAL_TIM_Encoder_Stop_DMA(TIM_HandleTypeDef *htim, uint32_t Channel)
   2733          {
   2734            /* Check the parameters */
   2735            assert_param(IS_TIM_DMA_CC_INSTANCE(htim->Instance));
   2736          
   2737            /* Disable the Input Capture channels 1 and 2
   2738              (in the EncoderInterface the two possible channels that can be used are TIM_CHANNEL_1 and TIM_CHANNEL_2) */
   2739            if(Channel == TIM_CHANNEL_1)
   2740            {
   2741              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2742          
   2743              /* Disable the capture compare DMA Request 1 */
   2744              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2745            }
   2746            else if(Channel == TIM_CHANNEL_2)
   2747            {
   2748              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2749          
   2750              /* Disable the capture compare DMA Request 2 */
   2751              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2752            }
   2753            else
   2754            {
   2755              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_1, TIM_CCx_DISABLE);
   2756              TIM_CCxChannelCmd(htim->Instance, TIM_CHANNEL_2, TIM_CCx_DISABLE);
   2757          
   2758              /* Disable the capture compare DMA Request 1 and 2 */
   2759              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC1);
   2760              __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_CC2);
   2761            }
   2762          
   2763            /* Disable the Peripheral */
   2764            __HAL_TIM_DISABLE(htim);
   2765          
   2766            /* Change the htim state */
   2767            htim->State = HAL_TIM_STATE_READY;
   2768          
   2769            /* Return function status */
   2770            return HAL_OK;
   2771          }
   2772          
   2773          /**
   2774            * @}
   2775            */
   2776          /** @defgroup TIM_Exported_Functions_Group7 TIM IRQ handler management 
   2777           *  @brief    IRQ handler management 
   2778           *
   2779          @verbatim 
   2780            ==============================================================================
   2781                                  ##### IRQ handler management #####
   2782            ==============================================================================
   2783            [..]
   2784              This section provides Timer IRQ handler function.
   2785          
   2786          @endverbatim
   2787            * @{
   2788            */
   2789          /**
   2790            * @brief  This function handles TIM interrupts requests.
   2791            * @param  htim : TIM  handle
   2792            * @retval None
   2793            */
   2794          void HAL_TIM_IRQHandler(TIM_HandleTypeDef *htim)
   2795          {
   2796            /* Capture compare 1 event */
   2797            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET)
   2798            {
   2799              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) !=RESET)
   2800              {
   2801                {
   2802                  __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC1);
   2803                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   2804          
   2805                  /* Input capture event */
   2806                  if((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U)
   2807                  {
   2808                    HAL_TIM_IC_CaptureCallback(htim);
   2809                  }
   2810                  /* Output compare event */
   2811                  else
   2812                  {
   2813                    HAL_TIM_OC_DelayElapsedCallback(htim);
   2814                    HAL_TIM_PWM_PulseFinishedCallback(htim);
   2815                  }
   2816                  htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   2817                }
   2818              }
   2819            }
   2820            /* Capture compare 2 event */
   2821            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET)
   2822            {
   2823              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) !=RESET)
   2824              {
   2825                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC2);
   2826                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   2827                /* Input capture event */
   2828                if((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U)
   2829                {
   2830                  HAL_TIM_IC_CaptureCallback(htim);
   2831                }
   2832                /* Output compare event */
   2833                else
   2834                {
   2835                  HAL_TIM_OC_DelayElapsedCallback(htim);
   2836                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   2837                }
   2838                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   2839              }
   2840            }
   2841            /* Capture compare 3 event */
   2842            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC3) != RESET)
   2843            {
   2844              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC3) !=RESET)
   2845              {
   2846                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC3);
   2847                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   2848                /* Input capture event */
   2849                if((htim->Instance->CCMR2 & TIM_CCMR2_CC3S) != 0x00U)
   2850                {
   2851                  HAL_TIM_IC_CaptureCallback(htim);
   2852                }
   2853                /* Output compare event */
   2854                else
   2855                {
   2856                  HAL_TIM_OC_DelayElapsedCallback(htim);
   2857                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   2858                }
   2859                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   2860              }
   2861            }
   2862            /* Capture compare 4 event */
   2863            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC4) != RESET)
   2864            {
   2865              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC4) !=RESET)
   2866              {
   2867                __HAL_TIM_CLEAR_IT(htim, TIM_IT_CC4);
   2868                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   2869                /* Input capture event */
   2870                if((htim->Instance->CCMR2 & TIM_CCMR2_CC4S) != 0x00U)
   2871                {
   2872                  HAL_TIM_IC_CaptureCallback(htim);
   2873                }
   2874                /* Output compare event */
   2875                else
   2876                {
   2877                  HAL_TIM_OC_DelayElapsedCallback(htim);
   2878                  HAL_TIM_PWM_PulseFinishedCallback(htim);
   2879                }
   2880                htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   2881              }
   2882            }
   2883            /* TIM Update event */
   2884            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET)
   2885            {
   2886              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) !=RESET)
   2887              {
   2888                __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
   2889                HAL_TIM_PeriodElapsedCallback(htim);
   2890              }
   2891            }
   2892            /* TIM Break input event */
   2893            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_BREAK) != RESET)
   2894            {
   2895              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_BREAK) !=RESET)
   2896              {
   2897                __HAL_TIM_CLEAR_IT(htim, TIM_IT_BREAK);
   2898                HAL_TIMEx_BreakCallback(htim);
   2899              }
   2900            }
   2901            /* TIM Trigger detection event */
   2902            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_TRIGGER) != RESET)
   2903            {
   2904              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_TRIGGER) !=RESET)
   2905              {
   2906                __HAL_TIM_CLEAR_IT(htim, TIM_IT_TRIGGER);
   2907                HAL_TIM_TriggerCallback(htim);
   2908              }
   2909            }
   2910            /* TIM commutation event */
   2911            if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_COM) != RESET)
   2912            {
   2913              if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_COM) !=RESET)
   2914              {
   2915                __HAL_TIM_CLEAR_IT(htim, TIM_FLAG_COM);
   2916                HAL_TIMEx_CommutationCallback(htim);
   2917              }
   2918            }
   2919          }
   2920          
   2921          /**
   2922            * @}
   2923            */
   2924          
   2925          /** @defgroup TIM_Exported_Functions_Group8 Peripheral Control functions
   2926           *  @brief   	Peripheral Control functions 
   2927           *
   2928          @verbatim 
   2929            ==============================================================================
   2930                             ##### Peripheral Control functions #####
   2931            ==============================================================================
   2932           [..]
   2933             This section provides functions allowing to:
   2934                (+) Configure The Input Output channels for OC, PWM, IC or One Pulse mode.
   2935                (+) Configure External Clock source.
   2936                (+) Configure Complementary channels, break features and dead time.
   2937                (+) Configure Master and the Slave synchronization.
   2938                (+) Configure the DMA Burst Mode.
   2939          
   2940          @endverbatim
   2941            * @{
   2942            */
   2943          
   2944          /**
   2945            * @brief  Initializes the TIM Output Compare Channels according to the specified
   2946            *         parameters in the TIM_OC_InitTypeDef.
   2947            * @param  htim : TIM Output Compare handle
   2948            * @param  sConfig : TIM Output Compare configuration structure
   2949            * @param  Channel : TIM Channels to be enabled
   2950            *          This parameter can be one of the following values:
   2951            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   2952            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   2953            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   2954            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   2955            * @retval HAL status
   2956            */
   2957          HAL_StatusTypeDef HAL_TIM_OC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   2958          {
   2959            /* Check the parameters */
   2960            assert_param(IS_TIM_CHANNELS(Channel));
   2961            assert_param(IS_TIM_OC_MODE(sConfig->OCMode));
   2962            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   2963          
   2964            /* Check input state */
   2965            __HAL_LOCK(htim);
   2966          
   2967            htim->State = HAL_TIM_STATE_BUSY;
   2968          
   2969            switch (Channel)
   2970            {
   2971              case TIM_CHANNEL_1:
   2972              {
   2973                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   2974                /* Configure the TIM Channel 1 in Output Compare */
   2975                TIM_OC1_SetConfig(htim->Instance, sConfig);
   2976              }
   2977              break;
   2978          
   2979              case TIM_CHANNEL_2:
   2980              {
   2981                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   2982                /* Configure the TIM Channel 2 in Output Compare */
   2983                TIM_OC2_SetConfig(htim->Instance, sConfig);
   2984              }
   2985              break;
   2986          
   2987              case TIM_CHANNEL_3:
   2988              {
   2989                 assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   2990                /* Configure the TIM Channel 3 in Output Compare */
   2991                TIM_OC3_SetConfig(htim->Instance, sConfig);
   2992              }
   2993              break;
   2994          
   2995              case TIM_CHANNEL_4:
   2996              {
   2997                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   2998                 /* Configure the TIM Channel 4 in Output Compare */
   2999                 TIM_OC4_SetConfig(htim->Instance, sConfig);
   3000              }
   3001              break;
   3002          
   3003              default:
   3004              break;
   3005            }
   3006            htim->State = HAL_TIM_STATE_READY;
   3007          
   3008            __HAL_UNLOCK(htim);
   3009          
   3010            return HAL_OK;
   3011          }
   3012          
   3013          /**
   3014            * @brief  Initializes the TIM Input Capture Channels according to the specified
   3015            *         parameters in the TIM_IC_InitTypeDef.
   3016            * @param  htim : TIM IC handle
   3017            * @param  sConfig : TIM Input Capture configuration structure
   3018            * @param  Channel : TIM Channels to be enabled
   3019            *          This parameter can be one of the following values:
   3020            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3021            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3022            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3023            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected 
   3024            * @retval HAL status
   3025            */
   3026          HAL_StatusTypeDef HAL_TIM_IC_ConfigChannel(TIM_HandleTypeDef *htim, TIM_IC_InitTypeDef* sConfig, uint32_t Channel)
   3027          {
   3028            /* Check the parameters */
   3029            assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3030            assert_param(IS_TIM_IC_POLARITY(sConfig->ICPolarity));
   3031            assert_param(IS_TIM_IC_SELECTION(sConfig->ICSelection));
   3032            assert_param(IS_TIM_IC_PRESCALER(sConfig->ICPrescaler));
   3033            assert_param(IS_TIM_IC_FILTER(sConfig->ICFilter));
   3034          
   3035            __HAL_LOCK(htim);
   3036          
   3037            htim->State = HAL_TIM_STATE_BUSY;
   3038          
   3039            if (Channel == TIM_CHANNEL_1)
   3040            {
   3041              /* TI1 Configuration */
   3042              TIM_TI1_SetConfig(htim->Instance,
   3043                         sConfig->ICPolarity,
   3044                         sConfig->ICSelection,
   3045                         sConfig->ICFilter);
   3046          
   3047              /* Reset the IC1PSC Bits */
   3048              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   3049          
   3050              /* Set the IC1PSC value */
   3051              htim->Instance->CCMR1 |= sConfig->ICPrescaler;
   3052            }
   3053            else if (Channel == TIM_CHANNEL_2)
   3054            {
   3055              /* TI2 Configuration */
   3056              assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3057          
   3058              TIM_TI2_SetConfig(htim->Instance,
   3059                                sConfig->ICPolarity,
   3060                                sConfig->ICSelection,
   3061                                sConfig->ICFilter);
   3062          
   3063              /* Reset the IC2PSC Bits */
   3064              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   3065          
   3066              /* Set the IC2PSC value */
   3067              htim->Instance->CCMR1 |= (sConfig->ICPrescaler << 8U);
   3068            }
   3069            else if (Channel == TIM_CHANNEL_3)
   3070            {
   3071              /* TI3 Configuration */
   3072              assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3073          
   3074              TIM_TI3_SetConfig(htim->Instance,
   3075                         sConfig->ICPolarity,
   3076                         sConfig->ICSelection,
   3077                         sConfig->ICFilter);
   3078          
   3079              /* Reset the IC3PSC Bits */
   3080              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC3PSC;
   3081          
   3082              /* Set the IC3PSC value */
   3083              htim->Instance->CCMR2 |= sConfig->ICPrescaler;
   3084            }
   3085            else
   3086            {
   3087              /* TI4 Configuration */
   3088              assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3089          
   3090              TIM_TI4_SetConfig(htim->Instance,
   3091                         sConfig->ICPolarity,
   3092                         sConfig->ICSelection,
   3093                         sConfig->ICFilter);
   3094          
   3095              /* Reset the IC4PSC Bits */
   3096              htim->Instance->CCMR2 &= ~TIM_CCMR2_IC4PSC;
   3097          
   3098              /* Set the IC4PSC value */
   3099              htim->Instance->CCMR2 |= (sConfig->ICPrescaler << 8U);
   3100            }
   3101          
   3102            htim->State = HAL_TIM_STATE_READY;
   3103          
   3104            __HAL_UNLOCK(htim);
   3105          
   3106            return HAL_OK;
   3107          }
   3108          
   3109          /**
   3110            * @brief  Initializes the TIM PWM  channels according to the specified
   3111            *         parameters in the TIM_OC_InitTypeDef.
   3112            * @param  htim : TIM handle
   3113            * @param  sConfig : TIM PWM configuration structure
   3114            * @param  Channel : TIM Channels to be enabled
   3115            *          This parameter can be one of the following values:
   3116            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3117            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3118            *            @arg TIM_CHANNEL_3: TIM Channel 3 selected
   3119            *            @arg TIM_CHANNEL_4: TIM Channel 4 selected
   3120            * @retval HAL status
   3121            */
   3122          HAL_StatusTypeDef HAL_TIM_PWM_ConfigChannel(TIM_HandleTypeDef *htim, TIM_OC_InitTypeDef* sConfig, uint32_t Channel)
   3123          {
   3124            __HAL_LOCK(htim);
   3125          
   3126            /* Check the parameters */
   3127            assert_param(IS_TIM_CHANNELS(Channel));
   3128            assert_param(IS_TIM_PWM_MODE(sConfig->OCMode));
   3129            assert_param(IS_TIM_OC_POLARITY(sConfig->OCPolarity));
   3130            assert_param(IS_TIM_FAST_STATE(sConfig->OCFastMode));
   3131          
   3132            htim->State = HAL_TIM_STATE_BUSY;
   3133          
   3134            switch (Channel)
   3135            {
   3136              case TIM_CHANNEL_1:
   3137              {
   3138                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3139                /* Configure the Channel 1 in PWM mode */
   3140                TIM_OC1_SetConfig(htim->Instance, sConfig);
   3141          
   3142                /* Set the Preload enable bit for channel1 */
   3143                htim->Instance->CCMR1 |= TIM_CCMR1_OC1PE;
   3144          
   3145                /* Configure the Output Fast mode */
   3146                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1FE;
   3147                htim->Instance->CCMR1 |= sConfig->OCFastMode;
   3148              }
   3149              break;
   3150          
   3151              case TIM_CHANNEL_2:
   3152              {
   3153                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3154                /* Configure the Channel 2 in PWM mode */
   3155                TIM_OC2_SetConfig(htim->Instance, sConfig);
   3156          
   3157                /* Set the Preload enable bit for channel2 */
   3158                htim->Instance->CCMR1 |= TIM_CCMR1_OC2PE;
   3159          
   3160                /* Configure the Output Fast mode */
   3161                htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2FE;
   3162                htim->Instance->CCMR1 |= sConfig->OCFastMode << 8;
   3163              }
   3164              break;
   3165          
   3166              case TIM_CHANNEL_3:
   3167              {
   3168                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3169                /* Configure the Channel 3 in PWM mode */
   3170                TIM_OC3_SetConfig(htim->Instance, sConfig);
   3171          
   3172                /* Set the Preload enable bit for channel3 */
   3173                htim->Instance->CCMR2 |= TIM_CCMR2_OC3PE;
   3174          
   3175               /* Configure the Output Fast mode */
   3176                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3FE;
   3177                htim->Instance->CCMR2 |= sConfig->OCFastMode;
   3178              }
   3179              break;
   3180          
   3181              case TIM_CHANNEL_4:
   3182              {
   3183                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3184                /* Configure the Channel 4 in PWM mode */
   3185                TIM_OC4_SetConfig(htim->Instance, sConfig);
   3186          
   3187                /* Set the Preload enable bit for channel4 */
   3188                htim->Instance->CCMR2 |= TIM_CCMR2_OC4PE;
   3189          
   3190               /* Configure the Output Fast mode */
   3191                htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4FE;
   3192                htim->Instance->CCMR2 |= sConfig->OCFastMode << 8;
   3193              }
   3194              break;
   3195          
   3196              default:
   3197              break;
   3198            }
   3199          
   3200            htim->State = HAL_TIM_STATE_READY;
   3201          
   3202            __HAL_UNLOCK(htim);
   3203          
   3204            return HAL_OK;
   3205          }
   3206          
   3207          /**
   3208            * @brief  Initializes the TIM One Pulse Channels according to the specified
   3209            *         parameters in the TIM_OnePulse_InitTypeDef.
   3210            * @param  htim : TIM One Pulse handle
   3211            * @param  sConfig : TIM One Pulse configuration structure
   3212            * @param  OutputChannel : TIM Channels to be enabled
   3213            *          This parameter can be one of the following values:
   3214            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3215            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3216            * @param  InputChannel : TIM Channels to be enabled
   3217            *          This parameter can be one of the following values:
   3218            *            @arg TIM_CHANNEL_1: TIM Channel 1 selected
   3219            *            @arg TIM_CHANNEL_2: TIM Channel 2 selected
   3220            * @retval HAL status
   3221            */
   3222          HAL_StatusTypeDef HAL_TIM_OnePulse_ConfigChannel(TIM_HandleTypeDef *htim,  TIM_OnePulse_InitTypeDef* sConfig, uint32_t OutputChannel,  uint32_t InputChannel)
   3223          {
   3224            TIM_OC_InitTypeDef temp1;
   3225          
   3226            /* Check the parameters */
   3227            assert_param(IS_TIM_OPM_CHANNELS(OutputChannel));
   3228            assert_param(IS_TIM_OPM_CHANNELS(InputChannel));
   3229          
   3230            if(OutputChannel != InputChannel)
   3231            {
   3232            __HAL_LOCK(htim);
   3233          
   3234            htim->State = HAL_TIM_STATE_BUSY;
   3235          
   3236            /* Extract the Ouput compare configuration from sConfig structure */
   3237            temp1.OCMode = sConfig->OCMode;
   3238            temp1.Pulse = sConfig->Pulse;
   3239            temp1.OCPolarity = sConfig->OCPolarity;
   3240            temp1.OCNPolarity = sConfig->OCNPolarity;
   3241            temp1.OCIdleState = sConfig->OCIdleState;
   3242            temp1.OCNIdleState = sConfig->OCNIdleState;
   3243          
   3244              switch (OutputChannel)
   3245            {
   3246              case TIM_CHANNEL_1:
   3247              {
   3248                  assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3249          
   3250                TIM_OC1_SetConfig(htim->Instance, &temp1);
   3251              }
   3252              break;
   3253              case TIM_CHANNEL_2:
   3254              {
   3255                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3256          
   3257                TIM_OC2_SetConfig(htim->Instance, &temp1);
   3258              }
   3259              break;
   3260              default:
   3261              break;
   3262            }
   3263            switch (InputChannel)
   3264            {
   3265              case TIM_CHANNEL_1:
   3266              {
   3267                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   3268          
   3269                TIM_TI1_SetConfig(htim->Instance, sConfig->ICPolarity,
   3270                                  sConfig->ICSelection, sConfig->ICFilter);
   3271          
   3272                /* Reset the IC1PSC Bits */
   3273              htim->Instance->CCMR1 &= ~TIM_CCMR1_IC1PSC;
   3274          
   3275                /* Select the Trigger source */
   3276                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3277                htim->Instance->SMCR |= TIM_TS_TI1FP1;
   3278          
   3279                /* Select the Slave Mode */
   3280                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3281                htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3282              }
   3283              break;
   3284              case TIM_CHANNEL_2:
   3285              {
   3286                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3287          
   3288                TIM_TI2_SetConfig(htim->Instance, sConfig->ICPolarity,
   3289                           sConfig->ICSelection, sConfig->ICFilter);
   3290          
   3291                /* Reset the IC2PSC Bits */
   3292                  htim->Instance->CCMR1 &= ~TIM_CCMR1_IC2PSC;
   3293          
   3294                /* Select the Trigger source */
   3295                  htim->Instance->SMCR &= ~TIM_SMCR_TS;
   3296                htim->Instance->SMCR |= TIM_TS_TI2FP2;
   3297          
   3298                /* Select the Slave Mode */
   3299                  htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3300                htim->Instance->SMCR |= TIM_SLAVEMODE_TRIGGER;
   3301              }
   3302              break;
   3303          
   3304              default:
   3305              break;
   3306            }
   3307          
   3308            htim->State = HAL_TIM_STATE_READY;
   3309          
   3310            __HAL_UNLOCK(htim);
   3311          
   3312            return HAL_OK;
   3313          }
   3314            else
   3315            {
   3316              return HAL_ERROR;
   3317            }
   3318          }
   3319          
   3320          /**
   3321            * @brief  Configure the DMA Burst to transfer Data from the memory to the TIM peripheral 
   3322            * @param  htim : TIM handle
   3323            * @param  BurstBaseAddress : TIM Base address from where the DMA will start the Data write
   3324            *         This parameter can be one of the following values:
   3325            *            @arg TIM_DMABASE_CR1 
   3326            *            @arg TIM_DMABASE_CR2
   3327            *            @arg TIM_DMABASE_SMCR
   3328            *            @arg TIM_DMABASE_DIER
   3329            *            @arg TIM_DMABASE_SR
   3330            *            @arg TIM_DMABASE_EGR
   3331            *            @arg TIM_DMABASE_CCMR1
   3332            *            @arg TIM_DMABASE_CCMR2
   3333            *            @arg TIM_DMABASE_CCER
   3334            *            @arg TIM_DMABASE_CNT 
   3335            *            @arg TIM_DMABASE_PSC 
   3336            *            @arg TIM_DMABASE_ARR
   3337            *            @arg TIM_DMABASE_RCR
   3338            *            @arg TIM_DMABASE_CCR1
   3339            *            @arg TIM_DMABASE_CCR2
   3340            *            @arg TIM_DMABASE_CCR3 
   3341            *            @arg TIM_DMABASE_CCR4
   3342            *            @arg TIM_DMABASE_BDTR
   3343            *            @arg TIM_DMABASE_DCR
   3344            * @param  BurstRequestSrc : TIM DMA Request sources
   3345            *         This parameter can be one of the following values:
   3346            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3347            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3348            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3349            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3350            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3351            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3352            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3353            * @param  BurstBuffer : The Buffer address.
   3354            * @param  BurstLength : DMA Burst length. This parameter can be one value
   3355            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3356            * @retval HAL status
   3357            */
   3358          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3359                                                        uint32_t* BurstBuffer, uint32_t  BurstLength)
   3360          {
   3361            /* Check the parameters */
   3362            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3363            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3364            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3365            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3366          
   3367            if((htim->State == HAL_TIM_STATE_BUSY))
   3368            {
   3369               return HAL_BUSY;
   3370            }
   3371            else if((htim->State == HAL_TIM_STATE_READY))
   3372            {
   3373              if((BurstBuffer == 0U) && (BurstLength > 0U))
   3374              {
   3375                return HAL_ERROR;
   3376              }
   3377              else
   3378              {
   3379                htim->State = HAL_TIM_STATE_BUSY;
   3380              }
   3381            }
   3382            switch(BurstRequestSrc)
   3383            {
   3384              case TIM_DMA_UPDATE:
   3385              {
   3386                /* Set the DMA Period elapsed callback */
   3387                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   3388          
   3389                /* Set the DMA error callback */
   3390                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   3391          
   3392                /* Enable the DMA channel */
   3393                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   3394              }
   3395              break;
   3396              case TIM_DMA_CC1:
   3397              {
   3398                /* Set the DMA Period elapsed callback */
   3399                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   3400          
   3401                /* Set the DMA error callback */
   3402                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3403          
   3404                /* Enable the DMA channel */
   3405                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   3406              }
   3407              break;
   3408              case TIM_DMA_CC2:
   3409              {
   3410                /* Set the DMA Period elapsed callback */
   3411                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   3412          
   3413                /* Set the DMA error callback */
   3414                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3415          
   3416                /* Enable the DMA channel */
   3417                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   3418              }
   3419              break;
   3420              case TIM_DMA_CC3:
   3421              {
   3422                /* Set the DMA Period elapsed callback */
   3423                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   3424          
   3425                /* Set the DMA error callback */
   3426                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   3427          
   3428                /* Enable the DMA channel */
   3429                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   3430              }
   3431              break;
   3432              case TIM_DMA_CC4:
   3433              {
   3434                /* Set the DMA Period elapsed callback */
   3435                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMADelayPulseCplt;
   3436          
   3437                /* Set the DMA error callback */
   3438                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   3439          
   3440                /* Enable the DMA channel */
   3441                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   3442              }
   3443              break;
   3444              case TIM_DMA_COM:
   3445              {
   3446                /* Set the DMA Period elapsed callback */
   3447                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   3448          
   3449                /* Set the DMA error callback */
   3450                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   3451          
   3452                /* Enable the DMA channel */
   3453                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   3454              }
   3455              break;
   3456              case TIM_DMA_TRIGGER:
   3457              {
   3458                /* Set the DMA Period elapsed callback */
   3459                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3460          
   3461                /* Set the DMA error callback */
   3462                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   3463          
   3464                /* Enable the DMA channel */
   3465                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)BurstBuffer, (uint32_t)&htim->Instance->DMAR, ((BurstLength) >> 8U) + 1U);
   3466              }
   3467              break;
   3468              default:
   3469              break;
   3470            }
   3471             /* configure the DMA Burst Mode */
   3472             htim->Instance->DCR = BurstBaseAddress | BurstLength;
   3473          
   3474             /* Enable the TIM DMA Request */
   3475             __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   3476          
   3477             htim->State = HAL_TIM_STATE_READY;
   3478          
   3479            /* Return function status */
   3480            return HAL_OK;
   3481          }
   3482          
   3483          /**
   3484            * @brief  Stops the TIM DMA Burst mode 
   3485            * @param  htim : TIM handle
   3486            * @param  BurstRequestSrc : TIM DMA Request sources to disable
   3487            * @retval HAL status
   3488            */
   3489          HAL_StatusTypeDef HAL_TIM_DMABurst_WriteStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3490          {
   3491            /* Check the parameters */
   3492            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3493          
   3494            /* Abort the DMA transfer (at least disable the DMA channel) */
   3495            switch(BurstRequestSrc)
   3496            {
   3497              case TIM_DMA_UPDATE:
   3498              {
   3499                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   3500              }
   3501              break;
   3502              case TIM_DMA_CC1:
   3503              {
   3504                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   3505              }
   3506              break;
   3507              case TIM_DMA_CC2:
   3508              {
   3509                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   3510              }
   3511              break;
   3512              case TIM_DMA_CC3:
   3513              {
   3514                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   3515              }
   3516              break;
   3517              case TIM_DMA_CC4:
   3518              {
   3519                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   3520              }
   3521              break;
   3522              case TIM_DMA_COM:
   3523              {
   3524                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   3525              }
   3526              break;
   3527              case TIM_DMA_TRIGGER:
   3528              {
   3529                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   3530              }
   3531              break;
   3532              default:
   3533              break;
   3534            }
   3535          
   3536            /* Disable the TIM Update DMA request */
   3537            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   3538          
   3539            /* Return function status */
   3540            return HAL_OK;
   3541          }
   3542          
   3543          /**
   3544            * @brief  Configure the DMA Burst to transfer Data from the TIM peripheral to the memory 
   3545            * @param  htim : TIM handle
   3546            * @param  BurstBaseAddress : TIM Base address from where the DMA will starts the Data read
   3547            *         This parameter can be one of the following values:
   3548            *            @arg TIM_DMABASE_CR1 
   3549            *            @arg TIM_DMABASE_CR2
   3550            *            @arg TIM_DMABASE_SMCR
   3551            *            @arg TIM_DMABASE_DIER
   3552            *            @arg TIM_DMABASE_SR
   3553            *            @arg TIM_DMABASE_EGR
   3554            *            @arg TIM_DMABASE_CCMR1
   3555            *            @arg TIM_DMABASE_CCMR2
   3556            *            @arg TIM_DMABASE_CCER
   3557            *            @arg TIM_DMABASE_CNT 
   3558            *            @arg TIM_DMABASE_PSC 
   3559            *            @arg TIM_DMABASE_ARR
   3560            *            @arg TIM_DMABASE_RCR
   3561            *            @arg TIM_DMABASE_CCR1
   3562            *            @arg TIM_DMABASE_CCR2
   3563            *            @arg TIM_DMABASE_CCR3 
   3564            *            @arg TIM_DMABASE_CCR4
   3565            *            @arg TIM_DMABASE_BDTR
   3566            *            @arg TIM_DMABASE_DCR
   3567            * @param  BurstRequestSrc : TIM DMA Request sources
   3568            *         This parameter can be one of the following values:
   3569            *            @arg TIM_DMA_UPDATE: TIM update Interrupt source
   3570            *            @arg TIM_DMA_CC1: TIM Capture Compare 1 DMA source
   3571            *            @arg TIM_DMA_CC2: TIM Capture Compare 2 DMA source
   3572            *            @arg TIM_DMA_CC3: TIM Capture Compare 3 DMA source
   3573            *            @arg TIM_DMA_CC4: TIM Capture Compare 4 DMA source
   3574            *            @arg TIM_DMA_COM: TIM Commutation DMA source
   3575            *            @arg TIM_DMA_TRIGGER: TIM Trigger DMA source
   3576            * @param  BurstBuffer : The Buffer address.
   3577            * @param  BurstLength : DMA Burst length. This parameter can be one value
   3578            *         between: TIM_DMABURSTLENGTH_1TRANSFER and TIM_DMABURSTLENGTH_18TRANSFERS.
   3579            * @retval HAL status
   3580            */
   3581          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStart(TIM_HandleTypeDef *htim, uint32_t BurstBaseAddress, uint32_t BurstRequestSrc,
   3582                                                       uint32_t  *BurstBuffer, uint32_t  BurstLength)
   3583          {
   3584            /* Check the parameters */
   3585            assert_param(IS_TIM_DMABURST_INSTANCE(htim->Instance));
   3586            assert_param(IS_TIM_DMA_BASE(BurstBaseAddress));
   3587            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3588            assert_param(IS_TIM_DMA_LENGTH(BurstLength));
   3589          
   3590            if((htim->State == HAL_TIM_STATE_BUSY))
   3591            {
   3592               return HAL_BUSY;
   3593            }
   3594            else if((htim->State == HAL_TIM_STATE_READY))
   3595            {
   3596              if((BurstBuffer == 0U) && (BurstLength > 0U))
   3597              {
   3598                return HAL_ERROR;
   3599              }
   3600              else
   3601              {
   3602                htim->State = HAL_TIM_STATE_BUSY;
   3603              }
   3604            }
   3605            switch(BurstRequestSrc)
   3606            {
   3607              case TIM_DMA_UPDATE:
   3608              {
   3609                /* Set the DMA Period elapsed callback */
   3610                htim->hdma[TIM_DMA_ID_UPDATE]->XferCpltCallback = TIM_DMAPeriodElapsedCplt;
   3611          
   3612                /* Set the DMA error callback */
   3613                htim->hdma[TIM_DMA_ID_UPDATE]->XferErrorCallback = TIM_DMAError ;
   3614          
   3615                /* Enable the DMA channel */
   3616                 HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_UPDATE], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   3617              }
   3618              break;
   3619              case TIM_DMA_CC1:
   3620              {
   3621                /* Set the DMA Period elapsed callback */
   3622                htim->hdma[TIM_DMA_ID_CC1]->XferCpltCallback =  TIM_DMACaptureCplt;
   3623          
   3624                /* Set the DMA error callback */
   3625                htim->hdma[TIM_DMA_ID_CC1]->XferErrorCallback = TIM_DMAError ;
   3626          
   3627                /* Enable the DMA channel */
   3628                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC1], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   3629              }
   3630              break;
   3631              case TIM_DMA_CC2:
   3632              {
   3633                /* Set the DMA Period elapsed callback */
   3634                htim->hdma[TIM_DMA_ID_CC2]->XferCpltCallback =  TIM_DMACaptureCplt;
   3635          
   3636                /* Set the DMA error callback */
   3637                htim->hdma[TIM_DMA_ID_CC2]->XferErrorCallback = TIM_DMAError ;
   3638          
   3639                /* Enable the DMA channel */
   3640                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC2], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   3641              }
   3642              break;
   3643              case TIM_DMA_CC3:
   3644              {
   3645                /* Set the DMA Period elapsed callback */
   3646                htim->hdma[TIM_DMA_ID_CC3]->XferCpltCallback =  TIM_DMACaptureCplt;
   3647          
   3648                /* Set the DMA error callback */
   3649                htim->hdma[TIM_DMA_ID_CC3]->XferErrorCallback = TIM_DMAError ;
   3650          
   3651                /* Enable the DMA channel */
   3652                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC3], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   3653              }
   3654              break;
   3655              case TIM_DMA_CC4:
   3656              {
   3657                /* Set the DMA Period elapsed callback */
   3658                htim->hdma[TIM_DMA_ID_CC4]->XferCpltCallback =  TIM_DMACaptureCplt;
   3659          
   3660                /* Set the DMA error callback */
   3661                htim->hdma[TIM_DMA_ID_CC4]->XferErrorCallback = TIM_DMAError ;
   3662          
   3663                /* Enable the DMA channel */
   3664                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_CC4], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   3665              }
   3666              break;
   3667              case TIM_DMA_COM:
   3668              {
   3669                /* Set the DMA Period elapsed callback */
   3670                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferCpltCallback =  TIMEx_DMACommutationCplt;
   3671          
   3672                /* Set the DMA error callback */
   3673                htim->hdma[TIM_DMA_ID_COMMUTATION]->XferErrorCallback = TIM_DMAError ;
   3674          
   3675                /* Enable the DMA channel */
   3676                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_COMMUTATION], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   3677              }
   3678              break;
   3679              case TIM_DMA_TRIGGER:
   3680              {
   3681                /* Set the DMA Period elapsed callback */
   3682                htim->hdma[TIM_DMA_ID_TRIGGER]->XferCpltCallback = TIM_DMATriggerCplt;
   3683          
   3684                /* Set the DMA error callback */
   3685                htim->hdma[TIM_DMA_ID_TRIGGER]->XferErrorCallback = TIM_DMAError ;
   3686          
   3687                /* Enable the DMA channel */
   3688                HAL_DMA_Start_IT(htim->hdma[TIM_DMA_ID_TRIGGER], (uint32_t)&htim->Instance->DMAR, (uint32_t)BurstBuffer, ((BurstLength) >> 8U) + 1U);
   3689              }
   3690              break;
   3691              default:
   3692              break;
   3693            }
   3694          
   3695            /* configure the DMA Burst Mode */
   3696            htim->Instance->DCR = BurstBaseAddress | BurstLength;
   3697          
   3698            /* Enable the TIM DMA Request */
   3699            __HAL_TIM_ENABLE_DMA(htim, BurstRequestSrc);
   3700          
   3701            htim->State = HAL_TIM_STATE_READY;
   3702          
   3703            /* Return function status */
   3704            return HAL_OK;
   3705          }
   3706          
   3707          /**
   3708            * @brief  Stop the DMA burst reading 
   3709            * @param  htim : TIM handle
   3710            * @param  BurstRequestSrc : TIM DMA Request sources to disable.
   3711            * @retval HAL status
   3712            */
   3713          HAL_StatusTypeDef HAL_TIM_DMABurst_ReadStop(TIM_HandleTypeDef *htim, uint32_t BurstRequestSrc)
   3714          {
   3715            /* Check the parameters */
   3716            assert_param(IS_TIM_DMA_SOURCE(BurstRequestSrc));
   3717          
   3718            /* Abort the DMA transfer (at least disable the DMA channel) */
   3719            switch(BurstRequestSrc)
   3720            {
   3721              case TIM_DMA_UPDATE:
   3722              {
   3723                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_UPDATE]);
   3724              }
   3725              break;
   3726              case TIM_DMA_CC1:
   3727              {
   3728                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC1]);
   3729              }
   3730              break;
   3731              case TIM_DMA_CC2:
   3732              {
   3733                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC2]);
   3734              }
   3735              break;
   3736              case TIM_DMA_CC3:
   3737              {
   3738                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC3]);
   3739              }
   3740              break;
   3741              case TIM_DMA_CC4:
   3742              {
   3743                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_CC4]);
   3744              }
   3745              break;
   3746              case TIM_DMA_COM:
   3747              {
   3748                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_COMMUTATION]);
   3749              }
   3750              break;
   3751              case TIM_DMA_TRIGGER:
   3752              {
   3753                HAL_DMA_Abort(htim->hdma[TIM_DMA_ID_TRIGGER]);
   3754              }
   3755              break;
   3756              default:
   3757              break;
   3758            }
   3759          
   3760            /* Disable the TIM Update DMA request */
   3761            __HAL_TIM_DISABLE_DMA(htim, BurstRequestSrc);
   3762          
   3763            /* Return function status */
   3764            return HAL_OK;
   3765          }
   3766          
   3767          /**
   3768            * @brief  Generate a software event
   3769            * @param  htim : TIM handle
   3770            * @param  EventSource : specifies the event source.
   3771            *          This parameter can be one of the following values:
   3772            *            @arg TIM_EVENTSOURCE_UPDATE: Timer update Event source
   3773            *            @arg TIM_EVENTSOURCE_CC1: Timer Capture Compare 1 Event source
   3774            *            @arg TIM_EVENTSOURCE_CC2: Timer Capture Compare 2 Event source
   3775            *            @arg TIM_EVENTSOURCE_CC3: Timer Capture Compare 3 Event source
   3776            *            @arg TIM_EVENTSOURCE_CC4: Timer Capture Compare 4 Event source
   3777            *            @arg TIM_EVENTSOURCE_COM: Timer COM event source 
   3778            *            @arg TIM_EVENTSOURCE_TRIGGER: Timer Trigger Event source
   3779            *            @arg TIM_EVENTSOURCE_BREAK: Timer Break event source
   3780            * @note TIM6 and TIM7 can only generate an update event.
   3781            * @note TIM_EVENTSOURCE_COM and TIM_EVENTSOURCE_BREAK are used only with TIM1, TIM15, TIM16 and TIM17.
   3782            * @retval HAL status
   3783            */
   3784          
   3785          HAL_StatusTypeDef HAL_TIM_GenerateEvent(TIM_HandleTypeDef *htim, uint32_t EventSource)
   3786          {
   3787            /* Check the parameters */
   3788            assert_param(IS_TIM_INSTANCE(htim->Instance));
   3789            assert_param(IS_TIM_EVENT_SOURCE(EventSource));
   3790          
   3791            /* Process Locked */
   3792            __HAL_LOCK(htim);
   3793          
   3794            /* Change the TIM state */
   3795            htim->State = HAL_TIM_STATE_BUSY;
   3796          
   3797            /* Set the event sources */
   3798            htim->Instance->EGR = EventSource;
   3799          
   3800            /* Change the TIM state */
   3801            htim->State = HAL_TIM_STATE_READY;
   3802          
   3803            __HAL_UNLOCK(htim);
   3804          
   3805            /* Return function status */
   3806            return HAL_OK;
   3807          }
   3808          
   3809          /**
   3810            * @brief  Configures the OCRef clear feature
   3811            * @param  htim : TIM handle
   3812            * @param  sClearInputConfig : pointer to a TIM_ClearInputConfigTypeDef structure that
   3813            *         contains the OCREF clear feature and parameters for the TIM peripheral.
   3814            * @param  Channel : specifies the TIM Channel
   3815            *          This parameter can be one of the following values:
   3816            *            @arg TIM_CHANNEL_1: TIM Channel 1
   3817            *            @arg TIM_CHANNEL_2: TIM Channel 2
   3818            *            @arg TIM_CHANNEL_3: TIM Channel 3
   3819            *            @arg TIM_CHANNEL_4: TIM Channel 4
   3820            * @retval HAL status
   3821            */ 
   3822          HAL_StatusTypeDef HAL_TIM_ConfigOCrefClear(TIM_HandleTypeDef *htim, TIM_ClearInputConfigTypeDef * sClearInputConfig, uint32_t Channel)
   3823          {
   3824            uint32_t tmpsmcr = 0U;
   3825          
   3826            /* Check the parameters */
   3827            assert_param(IS_TIM_OCXREF_CLEAR_INSTANCE(htim->Instance));
   3828            assert_param(IS_TIM_CLEARINPUT_SOURCE(sClearInputConfig->ClearInputSource));
   3829            assert_param(IS_TIM_CLEARINPUT_POLARITY(sClearInputConfig->ClearInputPolarity));
   3830            assert_param(IS_TIM_CLEARINPUT_PRESCALER(sClearInputConfig->ClearInputPrescaler));
   3831            assert_param(IS_TIM_CLEARINPUT_FILTER(sClearInputConfig->ClearInputFilter));
   3832          
   3833            /* Process Locked */
   3834            __HAL_LOCK(htim);
   3835          
   3836            htim->State = HAL_TIM_STATE_BUSY;
   3837          
   3838            switch (sClearInputConfig->ClearInputSource)
   3839            {
   3840              case TIM_CLEARINPUTSOURCE_NONE:
   3841              {
   3842          
   3843                /* Clear the ETR Bits */
   3844                tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3845          
   3846                /* Set TIMx_SMCR */
   3847                htim->Instance->SMCR = tmpsmcr;
   3848             }
   3849              break;
   3850          
   3851              case TIM_CLEARINPUTSOURCE_ETR:
   3852              {
   3853                TIM_ETR_SetConfig(htim->Instance,
   3854                                  sClearInputConfig->ClearInputPrescaler,
   3855                                  sClearInputConfig->ClearInputPolarity,
   3856                                  sClearInputConfig->ClearInputFilter);
   3857          
   3858              }
   3859              break;
   3860              default:
   3861              break;
   3862            }
   3863          
   3864            switch (Channel)
   3865            {
   3866              case TIM_CHANNEL_1:
   3867                {
   3868                  if(sClearInputConfig->ClearInputState != RESET)
   3869                  {
   3870                    /* Enable the Ocref clear feature for Channel 1 */
   3871                    htim->Instance->CCMR1 |= TIM_CCMR1_OC1CE;
   3872                  }
   3873                  else
   3874                  {
   3875                    /* Disable the Ocref clear feature for Channel 1 */
   3876                  htim->Instance->CCMR1 &= ~TIM_CCMR1_OC1CE;
   3877                  }
   3878                }
   3879                break;
   3880              case TIM_CHANNEL_2:
   3881                {
   3882                  assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   3883                  if(sClearInputConfig->ClearInputState != RESET)
   3884                  {
   3885                    /* Enable the Ocref clear feature for Channel 2 */
   3886                    htim->Instance->CCMR1 |= TIM_CCMR1_OC2CE;
   3887                  }
   3888                  else
   3889                  {
   3890                    /* Disable the Ocref clear feature for Channel 2 */
   3891                    htim->Instance->CCMR1 &= ~TIM_CCMR1_OC2CE;
   3892                  }
   3893                }
   3894              break;
   3895              case TIM_CHANNEL_3:
   3896                {
   3897                  assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   3898                  if(sClearInputConfig->ClearInputState != RESET)
   3899                  {
   3900                    /* Enable the Ocref clear feature for Channel 3 */
   3901                    htim->Instance->CCMR2 |= TIM_CCMR2_OC3CE;
   3902                  }
   3903                  else
   3904                  {
   3905                    /* Disable the Ocref clear feature for Channel 3 */
   3906                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC3CE;
   3907                  }
   3908                }
   3909              break;
   3910              case TIM_CHANNEL_4:
   3911                {
   3912                  assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   3913                  if(sClearInputConfig->ClearInputState != RESET)
   3914                  {
   3915                    /* Enable the Ocref clear feature for Channel 4 */
   3916                    htim->Instance->CCMR2 |= TIM_CCMR2_OC4CE;
   3917                  }
   3918                  else
   3919                  {
   3920                    /* Disable the Ocref clear feature for Channel 4 */
   3921                  htim->Instance->CCMR2 &= ~TIM_CCMR2_OC4CE;
   3922                  }
   3923                }
   3924              break;
   3925              default:
   3926              break;
   3927            }
   3928          
   3929            htim->State = HAL_TIM_STATE_READY;
   3930          
   3931            __HAL_UNLOCK(htim);
   3932          
   3933            return HAL_OK;
   3934          }
   3935          
   3936          /**
   3937            * @brief   Configures the clock source to be used
   3938            * @param  htim : TIM handle
   3939            * @param  sClockSourceConfig : pointer to a TIM_ClockConfigTypeDef structure that
   3940            *         contains the clock source information for the TIM peripheral.
   3941            * @retval HAL status
   3942            */ 
   3943          HAL_StatusTypeDef HAL_TIM_ConfigClockSource(TIM_HandleTypeDef *htim, TIM_ClockConfigTypeDef * sClockSourceConfig)
   3944          {
   3945            uint32_t tmpsmcr = 0U;
   3946          
   3947            /* Process Locked */
   3948            __HAL_LOCK(htim);
   3949          
   3950            htim->State = HAL_TIM_STATE_BUSY;
   3951          
   3952            /* Check the parameters */
   3953            assert_param(IS_TIM_CLOCKSOURCE(sClockSourceConfig->ClockSource));
   3954          
   3955            /* Reset the SMS, TS, ECE, ETPS and ETRF bits */
   3956            tmpsmcr = htim->Instance->SMCR;
   3957            tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3958            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   3959            htim->Instance->SMCR = tmpsmcr;
   3960          
   3961            switch (sClockSourceConfig->ClockSource)
   3962            {
   3963            case TIM_CLOCKSOURCE_INTERNAL:
   3964              {
   3965                assert_param(IS_TIM_INSTANCE(htim->Instance));
   3966                /* Disable slave mode to clock the prescaler directly with the internal clock */
   3967                htim->Instance->SMCR &= ~TIM_SMCR_SMS;
   3968              }
   3969              break;
   3970          
   3971            case TIM_CLOCKSOURCE_ETRMODE1:
   3972              {
   3973                /* Check whether or not the timer instance supports external trigger input mode 1 (ETRF)*/
   3974                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   3975          
   3976                /* Check ETR input conditioning related parameters */
   3977                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   3978                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   3979                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   3980                
   3981                /* Configure the ETR Clock source */
   3982                TIM_ETR_SetConfig(htim->Instance,
   3983                                  sClockSourceConfig->ClockPrescaler,
   3984                                  sClockSourceConfig->ClockPolarity,
   3985                                  sClockSourceConfig->ClockFilter);
   3986                /* Get the TIMx SMCR register value */
   3987                tmpsmcr = htim->Instance->SMCR;
   3988                /* Reset the SMS and TS Bits */
   3989                tmpsmcr &= ~(TIM_SMCR_SMS | TIM_SMCR_TS);
   3990                /* Select the External clock mode1 and the ETRF trigger */
   3991                tmpsmcr |= (TIM_SLAVEMODE_EXTERNAL1 | TIM_CLOCKSOURCE_ETRMODE1);
   3992                /* Write to TIMx SMCR */
   3993                htim->Instance->SMCR = tmpsmcr;
   3994              }
   3995              break;
   3996          
   3997            case TIM_CLOCKSOURCE_ETRMODE2:
   3998              {
   3999                /* Check whether or not the timer instance supports external trigger input mode 2 (ETRF)*/
   4000                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE2_INSTANCE(htim->Instance));
   4001          
   4002                /* Check ETR input conditioning related parameters */
   4003                assert_param(IS_TIM_CLOCKPRESCALER(sClockSourceConfig->ClockPrescaler));
   4004                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4005                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4006                
   4007                /* Configure the ETR Clock source */
   4008                TIM_ETR_SetConfig(htim->Instance,
   4009                                  sClockSourceConfig->ClockPrescaler,
   4010                                  sClockSourceConfig->ClockPolarity,
   4011                                  sClockSourceConfig->ClockFilter);
   4012                /* Enable the External clock mode2 */
   4013                htim->Instance->SMCR |= TIM_SMCR_ECE;
   4014              }
   4015              break;
   4016          
   4017            case TIM_CLOCKSOURCE_TI1:
   4018              {
   4019                /* Check whether or not the timer instance supports external clock mode 1 */
   4020                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4021          
   4022                /* Check TI1 input conditioning related parameters */
   4023                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4024                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4025                
   4026                TIM_TI1_ConfigInputStage(htim->Instance,
   4027                                         sClockSourceConfig->ClockPolarity,
   4028                                         sClockSourceConfig->ClockFilter);
   4029                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1);
   4030              }
   4031              break;
   4032            case TIM_CLOCKSOURCE_TI2:
   4033              {
   4034                /* Check whether or not the timer instance supports external clock mode 1 (ETRF)*/
   4035                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4036          
   4037                 /* Check TI2 input conditioning related parameters */
   4038                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4039                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4040          
   4041                TIM_TI2_ConfigInputStage(htim->Instance,
   4042                                         sClockSourceConfig->ClockPolarity,
   4043                                         sClockSourceConfig->ClockFilter);
   4044                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI2);
   4045              }
   4046              break;
   4047            case TIM_CLOCKSOURCE_TI1ED:
   4048              {
   4049                /* Check whether or not the timer instance supports external clock mode 1 */
   4050                assert_param(IS_TIM_CLOCKSOURCE_TIX_INSTANCE(htim->Instance));
   4051          
   4052                /* Check TI1 input conditioning related parameters */
   4053                assert_param(IS_TIM_CLOCKPOLARITY(sClockSourceConfig->ClockPolarity));
   4054                assert_param(IS_TIM_CLOCKFILTER(sClockSourceConfig->ClockFilter));
   4055          
   4056                TIM_TI1_ConfigInputStage(htim->Instance,
   4057                                         sClockSourceConfig->ClockPolarity,
   4058                                         sClockSourceConfig->ClockFilter);
   4059                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_TI1ED);
   4060              }
   4061              break;
   4062            case TIM_CLOCKSOURCE_ITR0:
   4063              {
   4064                /* Check whether or not the timer instance supports external clock mode 1 */
   4065                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4066          
   4067                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR0);
   4068              }
   4069              break;
   4070            case TIM_CLOCKSOURCE_ITR1:
   4071              {
   4072                /* Check whether or not the timer instance supports external clock mode 1 */
   4073                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4074          
   4075                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR1);
   4076              }
   4077              break;
   4078            case TIM_CLOCKSOURCE_ITR2:
   4079              {
   4080                /* Check whether or not the timer instance supports external clock mode 1 */
   4081                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4082          
   4083                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR2);
   4084              }
   4085              break;
   4086            case TIM_CLOCKSOURCE_ITR3:
   4087              {
   4088                /* Check whether or not the timer instance supports external clock mode 1 */
   4089                assert_param(IS_TIM_CLOCKSOURCE_ITRX_INSTANCE(htim->Instance));
   4090          
   4091                TIM_ITRx_SetConfig(htim->Instance, TIM_CLOCKSOURCE_ITR3);
   4092              }
   4093              break;
   4094          
   4095            default:
   4096              break;
   4097            }
   4098            htim->State = HAL_TIM_STATE_READY;
   4099          
   4100            __HAL_UNLOCK(htim);
   4101          
   4102            return HAL_OK;
   4103          }
   4104          
   4105          /**
   4106            * @brief  Selects the signal connected to the TI1 input: direct from CH1_input
   4107            *         or a XOR combination between CH1_input, CH2_input & CH3_input
   4108            * @param  htim : TIM handle.
   4109            * @param  TI1_Selection : Indicate whether or not channel 1 is connected to the
   4110            *         output of a XOR gate.
   4111            *          This parameter can be one of the following values:
   4112            *            @arg TIM_TI1SELECTION_CH1: The TIMx_CH1 pin is connected to TI1 input
   4113            *            @arg TIM_TI1SELECTION_XORCOMBINATION: The TIMx_CH1, CH2 and CH3
   4114            *            pins are connected to the TI1 input (XOR combination)
   4115            * @retval HAL status
   4116            */
   4117          HAL_StatusTypeDef HAL_TIM_ConfigTI1Input(TIM_HandleTypeDef *htim, uint32_t TI1_Selection)
   4118          {
   4119            uint32_t tmpcr2 = 0U;
   4120          
   4121            /* Check the parameters */
   4122            assert_param(IS_TIM_XOR_INSTANCE(htim->Instance));
   4123            assert_param(IS_TIM_TI1SELECTION(TI1_Selection));
   4124          
   4125            /* Get the TIMx CR2 register value */
   4126            tmpcr2 = htim->Instance->CR2;
   4127          
   4128            /* Reset the TI1 selection */
   4129            tmpcr2 &= ~TIM_CR2_TI1S;
   4130          
   4131            /* Set the the TI1 selection */
   4132            tmpcr2 |= TI1_Selection;
   4133          
   4134            /* Write to TIMxCR2 */
   4135            htim->Instance->CR2 = tmpcr2;
   4136          
   4137            return HAL_OK;
   4138          }
   4139          
   4140          /**
   4141            * @brief  Configures the TIM in Slave mode
   4142            * @param  htim : TIM handle.
   4143            * @param  sSlaveConfig : pointer to a TIM_SlaveConfigTypeDef structure that
   4144            *         contains the selected trigger (internal trigger input, filtered
   4145            *         timer input or external trigger input) and the ) and the Slave 
   4146            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1).
   4147            * @retval HAL status
   4148            */
   4149          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization(TIM_HandleTypeDef *htim, TIM_SlaveConfigTypeDef * sSlaveConfig)
   4150          {
   4151            /* Check the parameters */
   4152            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4153            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4154            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4155          
   4156            __HAL_LOCK(htim);
   4157          
   4158            htim->State = HAL_TIM_STATE_BUSY;
   4159          
   4160            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   4161          
   4162            /* Disable Trigger Interrupt */
   4163            __HAL_TIM_DISABLE_IT(htim, TIM_IT_TRIGGER);
   4164          
   4165            /* Disable Trigger DMA request */
   4166            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4167          
   4168            htim->State = HAL_TIM_STATE_READY;
   4169          
   4170            __HAL_UNLOCK(htim);
   4171          
   4172            return HAL_OK;
   4173              }
   4174          
   4175          /**
   4176            * @brief  Configures the TIM in Slave mode in interrupt mode
   4177            * @param  htim: TIM handle.
   4178            * @param  sSlaveConfig: pointer to a TIM_SlaveConfigTypeDef structure that
   4179            *         contains the selected trigger (internal trigger input, filtered
   4180            *         timer input or external trigger input) and the ) and the Slave 
   4181            *         mode (Disable, Reset, Gated, Trigger, External clock mode 1).
   4182            * @retval HAL status
   4183            */
   4184          HAL_StatusTypeDef HAL_TIM_SlaveConfigSynchronization_IT(TIM_HandleTypeDef *htim,
   4185                                                                  TIM_SlaveConfigTypeDef * sSlaveConfig)
   4186              {
   4187                /* Check the parameters */
   4188            assert_param(IS_TIM_SLAVE_INSTANCE(htim->Instance));
   4189            assert_param(IS_TIM_SLAVE_MODE(sSlaveConfig->SlaveMode));
   4190            assert_param(IS_TIM_TRIGGER_SELECTION(sSlaveConfig->InputTrigger));
   4191          
   4192            __HAL_LOCK(htim);
   4193          
   4194            htim->State = HAL_TIM_STATE_BUSY;
   4195          
   4196            TIM_SlaveTimer_SetConfig(htim, sSlaveConfig);
   4197          
   4198            /* Enable Trigger Interrupt */
   4199            __HAL_TIM_ENABLE_IT(htim, TIM_IT_TRIGGER);
   4200          
   4201            /* Disable Trigger DMA request */
   4202            __HAL_TIM_DISABLE_DMA(htim, TIM_DMA_TRIGGER);
   4203          
   4204            htim->State = HAL_TIM_STATE_READY;
   4205          
   4206            __HAL_UNLOCK(htim);
   4207          
   4208            return HAL_OK;
   4209          }
   4210          
   4211          /**
   4212            * @brief  Read the captured value from Capture Compare unit
   4213            * @param  htim : TIM handle.
   4214            * @param  Channel : TIM Channels to be enabled
   4215            *          This parameter can be one of the following values:
   4216            *            @arg TIM_CHANNEL_1 : TIM Channel 1 selected
   4217            *            @arg TIM_CHANNEL_2 : TIM Channel 2 selected
   4218            *            @arg TIM_CHANNEL_3 : TIM Channel 3 selected
   4219            *            @arg TIM_CHANNEL_4 : TIM Channel 4 selected
   4220            * @retval Captured value
   4221            */
   4222          uint32_t HAL_TIM_ReadCapturedValue(TIM_HandleTypeDef *htim, uint32_t Channel)
   4223          {
   4224            uint32_t tmpreg = 0U;
   4225          
   4226            __HAL_LOCK(htim);
   4227          
   4228            switch (Channel)
   4229            {
   4230            case TIM_CHANNEL_1:
   4231              {
   4232                /* Check the parameters */
   4233                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4234          
   4235                /* Return the capture 1 value */
   4236                tmpreg =  htim->Instance->CCR1;
   4237          
   4238                break;
   4239              }
   4240            case TIM_CHANNEL_2:
   4241              {
   4242                /* Check the parameters */
   4243                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   4244          
   4245                /* Return the capture 2 value */
   4246                tmpreg =   htim->Instance->CCR2;
   4247          
   4248                break;
   4249              }
   4250          
   4251            case TIM_CHANNEL_3:
   4252              {
   4253                /* Check the parameters */
   4254                assert_param(IS_TIM_CC3_INSTANCE(htim->Instance));
   4255          
   4256                /* Return the capture 3 value */
   4257                tmpreg =   htim->Instance->CCR3;
   4258          
   4259                break;
   4260              }
   4261          
   4262            case TIM_CHANNEL_4:
   4263              {
   4264                /* Check the parameters */
   4265                assert_param(IS_TIM_CC4_INSTANCE(htim->Instance));
   4266          
   4267                /* Return the capture 4 value */
   4268                tmpreg =   htim->Instance->CCR4;
   4269          
   4270                break;
   4271              }
   4272          
   4273            default:
   4274              break;
   4275            }
   4276          
   4277            __HAL_UNLOCK(htim);
   4278            return tmpreg;
   4279          }
   4280          
   4281          /**
   4282            * @}
   4283            */
   4284          
   4285          /** @defgroup TIM_Exported_Functions_Group9 TIM Callbacks functions
   4286           *  @brief    TIM Callbacks functions 
   4287           *
   4288          @verbatim 
   4289            ==============================================================================
   4290                                  ##### TIM Callbacks functions #####
   4291            ==============================================================================
   4292           [..]
   4293             This section provides TIM callback functions:
   4294             (+) Timer Period elapsed callback
   4295             (+) Timer Output Compare callback
   4296             (+) Timer Input capture callback
   4297             (+) Timer Trigger callback
   4298             (+) Timer Error callback
   4299          
   4300          @endverbatim
   4301            * @{
   4302            */
   4303          
   4304          /**
   4305            * @brief  Period elapsed callback in non blocking mode 
   4306            * @param  htim : TIM handle
   4307            * @retval None
   4308            */
   4309          __weak void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
   4310          {
   4311            /* Prevent unused argument(s) compilation warning */
   4312            UNUSED(htim);
   4313            /* NOTE : This function Should not be modified, when the callback is needed,
   4314                      the __HAL_TIM_PeriodElapsedCallback could be implemented in the user file
   4315             */
   4316          
   4317          }
   4318          /**
   4319            * @brief  Output Compare callback in non blocking mode 
   4320            * @param  htim : TIM OC handle
   4321            * @retval None
   4322            */
   4323          __weak void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
   4324          {
   4325            /* Prevent unused argument(s) compilation warning */
   4326            UNUSED(htim);
   4327            /* NOTE : This function Should not be modified, when the callback is needed,
   4328                      the __HAL_TIM_OC_DelayElapsedCallback could be implemented in the user file
   4329             */
   4330          }
   4331          /**
   4332            * @brief  Input Capture callback in non blocking mode 
   4333            * @param  htim : TIM IC handle
   4334            * @retval None
   4335            */
   4336          __weak void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
   4337          {
   4338            /* Prevent unused argument(s) compilation warning */
   4339            UNUSED(htim);
   4340            /* NOTE : This function Should not be modified, when the callback is needed,
   4341                      the __HAL_TIM_IC_CaptureCallback could be implemented in the user file
   4342             */
   4343          }
   4344          
   4345          /**
   4346            * @brief  PWM Pulse finished callback in non blocking mode 
   4347            * @param  htim : TIM handle
   4348            * @retval None
   4349            */
   4350          __weak void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
   4351          {
   4352            /* Prevent unused argument(s) compilation warning */
   4353            UNUSED(htim);
   4354            /* NOTE : This function Should not be modified, when the callback is needed,
   4355                      the __HAL_TIM_PWM_PulseFinishedCallback could be implemented in the user file
   4356             */
   4357          }
   4358          
   4359          /**
   4360            * @brief  Hall Trigger detection callback in non blocking mode 
   4361            * @param  htim : TIM handle
   4362            * @retval None
   4363            */
   4364          __weak void HAL_TIM_TriggerCallback(TIM_HandleTypeDef *htim)
   4365          {
   4366            /* Prevent unused argument(s) compilation warning */
   4367            UNUSED(htim);
   4368            /* NOTE : This function Should not be modified, when the callback is needed,
   4369                      the HAL_TIM_TriggerCallback could be implemented in the user file
   4370             */
   4371          }
   4372          
   4373          /**
   4374            * @brief  Timer error callback in non blocking mode 
   4375            * @param  htim : TIM handle
   4376            * @retval None
   4377            */
   4378          __weak void HAL_TIM_ErrorCallback(TIM_HandleTypeDef *htim)
   4379          {
   4380            /* Prevent unused argument(s) compilation warning */
   4381            UNUSED(htim);
   4382            /* NOTE : This function Should not be modified, when the callback is needed,
   4383                      the HAL_TIM_ErrorCallback could be implemented in the user file
   4384             */
   4385          }
   4386          
   4387          /**
   4388            * @}
   4389            */
   4390          
   4391          /** @defgroup TIM_Exported_Functions_Group10 Peripheral State functions 
   4392           *  @brief   Peripheral State functions 
   4393           *
   4394          @verbatim 
   4395            ==============================================================================
   4396                                  ##### Peripheral State functions #####
   4397            ==============================================================================
   4398              [..]
   4399              This subsection permit to get in run-time the status of the peripheral 
   4400              and the data flow.
   4401          
   4402          @endverbatim
   4403            * @{
   4404            */
   4405          
   4406          /**
   4407            * @brief  Return the TIM Base state
   4408            * @param  htim : TIM Base handle
   4409            * @retval HAL state
   4410            */
   4411          HAL_TIM_StateTypeDef HAL_TIM_Base_GetState(TIM_HandleTypeDef *htim)
   4412          {
   4413            return htim->State;
   4414          }
   4415          
   4416          /**
   4417            * @brief  Return the TIM OC state
   4418            * @param  htim : TIM Ouput Compare handle
   4419            * @retval HAL state
   4420            */
   4421          HAL_TIM_StateTypeDef HAL_TIM_OC_GetState(TIM_HandleTypeDef *htim)
   4422          {
   4423            return htim->State;
   4424          }
   4425          
   4426          /**
   4427            * @brief  Return the TIM PWM state
   4428            * @param  htim : TIM handle
   4429            * @retval HAL state
   4430            */
   4431          HAL_TIM_StateTypeDef HAL_TIM_PWM_GetState(TIM_HandleTypeDef *htim)
   4432          {
   4433            return htim->State;
   4434          }
   4435          
   4436          /**
   4437            * @brief  Return the TIM Input Capture state
   4438            * @param  htim : TIM IC handle
   4439            * @retval HAL state
   4440            */
   4441          HAL_TIM_StateTypeDef HAL_TIM_IC_GetState(TIM_HandleTypeDef *htim)
   4442          {
   4443            return htim->State;
   4444          }
   4445          
   4446          /**
   4447            * @brief  Return the TIM One Pulse Mode state
   4448            * @param  htim : TIM OPM handle
   4449            * @retval HAL state
   4450            */
   4451          HAL_TIM_StateTypeDef HAL_TIM_OnePulse_GetState(TIM_HandleTypeDef *htim)
   4452          {
   4453            return htim->State;
   4454          }
   4455          
   4456          /**
   4457            * @brief  Return the TIM Encoder Mode state
   4458            * @param  htim : TIM Encoder handle
   4459            * @retval HAL state
   4460            */
   4461          HAL_TIM_StateTypeDef HAL_TIM_Encoder_GetState(TIM_HandleTypeDef *htim)
   4462          {
   4463            return htim->State;
   4464          }
   4465          
   4466          /**
   4467            * @}
   4468            */
   4469          
   4470          /**
   4471            * @}
   4472            */
   4473          
   4474          /** @addtogroup TIM_Private_Functions
   4475            * @{
   4476            */
   4477          
   4478          /**
   4479            * @brief  TIM DMA error callback 
   4480            * @param  hdma : pointer to DMA handle.
   4481            * @retval None
   4482            */
   4483          void TIM_DMAError(DMA_HandleTypeDef *hdma)
   4484          {
   4485            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4486          
   4487            htim->State= HAL_TIM_STATE_READY;
   4488          
   4489            HAL_TIM_ErrorCallback(htim);
   4490          }
   4491          
   4492          /**
   4493            * @brief  TIM DMA Delay Pulse complete callback.
   4494            * @param  hdma : pointer to DMA handle.
   4495            * @retval None
   4496            */
   4497          void TIM_DMADelayPulseCplt(DMA_HandleTypeDef *hdma)
   4498          {
   4499            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4500          
   4501            htim->State= HAL_TIM_STATE_READY;
   4502          
   4503            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   4504            {
   4505              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   4506            }
   4507            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   4508            {
   4509              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   4510            }
   4511            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   4512            {
   4513              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   4514            }
   4515            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   4516            {
   4517              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   4518            }
   4519          
   4520            HAL_TIM_PWM_PulseFinishedCallback(htim);
   4521          
   4522            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   4523          }
   4524          /**
   4525            * @brief  TIM DMA Capture complete callback.
   4526            * @param  hdma : pointer to DMA handle.
   4527            * @retval None
   4528            */
   4529          void TIM_DMACaptureCplt(DMA_HandleTypeDef *hdma)
   4530          {
   4531            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4532          
   4533            htim->State= HAL_TIM_STATE_READY;
   4534          
   4535            if (hdma == htim->hdma[TIM_DMA_ID_CC1])
   4536            {
   4537              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;
   4538            }
   4539            else if (hdma == htim->hdma[TIM_DMA_ID_CC2])
   4540            {
   4541              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
   4542            }
   4543            else if (hdma == htim->hdma[TIM_DMA_ID_CC3])
   4544            {
   4545              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_3;
   4546            }
   4547            else if (hdma == htim->hdma[TIM_DMA_ID_CC4])
   4548            {
   4549              htim->Channel = HAL_TIM_ACTIVE_CHANNEL_4;
   4550            }
   4551          
   4552            HAL_TIM_IC_CaptureCallback(htim);
   4553          
   4554            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
   4555          }
   4556          
   4557          /**
   4558            * @brief  TIM DMA Period Elapse complete callback.
   4559            * @param  hdma : pointer to DMA handle.
   4560            * @retval None
   4561            */
   4562          static void TIM_DMAPeriodElapsedCplt(DMA_HandleTypeDef *hdma)
   4563          {
   4564            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4565          
   4566            htim->State= HAL_TIM_STATE_READY;
   4567          
   4568            HAL_TIM_PeriodElapsedCallback(htim);
   4569          }
   4570          
   4571          /**
   4572            * @brief  TIM DMA Trigger callback.
   4573            * @param  hdma : pointer to DMA handle.
   4574            * @retval None
   4575            */
   4576          static void TIM_DMATriggerCplt(DMA_HandleTypeDef *hdma)
   4577          {
   4578            TIM_HandleTypeDef* htim = ( TIM_HandleTypeDef* )((DMA_HandleTypeDef* )hdma)->Parent;
   4579          
   4580            htim->State= HAL_TIM_STATE_READY;
   4581          
   4582            HAL_TIM_TriggerCallback(htim);
   4583          }
   4584          
   4585          /**
   4586            * @brief  Time Base configuration
   4587            * @param  TIMx : TIM periheral
   4588            * @param  Structure : TIM Base configuration structure
   4589            * @retval None
   4590            */
   4591          void TIM_Base_SetConfig(TIM_TypeDef *TIMx, TIM_Base_InitTypeDef *Structure)
   4592          {
   4593            uint32_t tmpcr1 = 0U;
   4594            tmpcr1 = TIMx->CR1;
   4595          
   4596            /* Set TIM Time Base Unit parameters ---------------------------------------*/
   4597            if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
   4598            {
   4599              /* Select the Counter Mode */
   4600              tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
   4601              tmpcr1 |= Structure->CounterMode;
   4602            }
   4603          
   4604            if(IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
   4605            {
   4606              /* Set the clock division */
   4607              tmpcr1 &= ~TIM_CR1_CKD;
   4608              tmpcr1 |= (uint32_t)Structure->ClockDivision;
   4609            }
   4610          
   4611            /* Set the auto-reload preload */
   4612            tmpcr1 &= ~TIM_CR1_ARPE;
   4613            tmpcr1 |= (uint32_t)Structure->AutoReloadPreload;
   4614          
   4615            TIMx->CR1 = tmpcr1;
   4616          
   4617            /* Set the Autoreload value */
   4618            TIMx->ARR = (uint32_t)Structure->Period ;
   4619          
   4620            /* Set the Prescaler value */
   4621            TIMx->PSC = (uint32_t)Structure->Prescaler;
   4622          
   4623            if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
   4624            {
   4625              /* Set the Repetition Counter value */
   4626              TIMx->RCR = Structure->RepetitionCounter;
   4627            }
   4628          
   4629            /* Generate an update event to reload the Prescaler 
   4630               and the repetition counter(only for TIM1 and TIM8) value immediatly */
   4631            TIMx->EGR = TIM_EGR_UG;
   4632          }
   4633          
   4634          /**
   4635            * @brief  Time Ouput Compare 1 configuration
   4636            * @param  TIMx to select the TIM peripheral
   4637            * @param  OC_Config : The ouput configuration structure
   4638            * @retval None
   4639            */
   4640          static void TIM_OC1_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4641          {
   4642            uint32_t tmpccmrx = 0U;
   4643            uint32_t tmpccer = 0U;
   4644            uint32_t tmpcr2 = 0U;
   4645          
   4646             /* Disable the Channel 1: Reset the CC1E Bit */
   4647            TIMx->CCER &= ~TIM_CCER_CC1E;
   4648          
   4649            /* Get the TIMx CCER register value */
   4650            tmpccer = TIMx->CCER;
   4651            /* Get the TIMx CR2 register value */
   4652            tmpcr2 =  TIMx->CR2;
   4653          
   4654            /* Get the TIMx CCMR1 register value */
   4655            tmpccmrx = TIMx->CCMR1;
   4656          
   4657            /* Reset the Output Compare Mode Bits */
   4658            tmpccmrx &= ~TIM_CCMR1_OC1M;
   4659            tmpccmrx &= ~TIM_CCMR1_CC1S;
   4660            /* Select the Output Compare Mode */
   4661            tmpccmrx |= OC_Config->OCMode;
   4662          
   4663            /* Reset the Output Polarity level */
   4664            tmpccer &= ~TIM_CCER_CC1P;
   4665            /* Set the Output Compare Polarity */
   4666            tmpccer |= OC_Config->OCPolarity;
   4667          
   4668            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_1))
   4669            {
   4670              /* Check parameters */
   4671              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4672          
   4673              /* Reset the Output N Polarity level */
   4674              tmpccer &= ~TIM_CCER_CC1NP;
   4675              /* Set the Output N Polarity */
   4676              tmpccer |= OC_Config->OCNPolarity;
   4677              /* Reset the Output N State */
   4678              tmpccer &= ~TIM_CCER_CC1NE;
   4679            }
   4680          
   4681            if(IS_TIM_BREAK_INSTANCE(TIMx))
   4682            {
   4683              /* Check parameters */
   4684              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4685              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4686          
   4687              /* Reset the Output Compare and Output Compare N IDLE State */
   4688              tmpcr2 &= ~TIM_CR2_OIS1;
   4689              tmpcr2 &= ~TIM_CR2_OIS1N;
   4690              /* Set the Output Idle state */
   4691              tmpcr2 |= OC_Config->OCIdleState;
   4692              /* Set the Output N Idle state */
   4693              tmpcr2 |= OC_Config->OCNIdleState;
   4694            }
   4695            /* Write to TIMx CR2 */
   4696            TIMx->CR2 = tmpcr2;
   4697          
   4698            /* Write to TIMx CCMR1 */
   4699            TIMx->CCMR1 = tmpccmrx;
   4700          
   4701            /* Set the Capture Compare Register value */
   4702            TIMx->CCR1 = OC_Config->Pulse;
   4703          
   4704            /* Write to TIMx CCER */
   4705            TIMx->CCER = tmpccer;
   4706          }
   4707          
   4708          /**
   4709            * @brief  Time Ouput Compare 2 configuration
   4710            * @param  TIMx  to select the TIM peripheral
   4711            * @param  OC_Config : The ouput configuration structure
   4712            * @retval None
   4713            */
   4714          void TIM_OC2_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4715          {
   4716            uint32_t tmpccmrx = 0U;
   4717            uint32_t tmpccer = 0U;
   4718            uint32_t tmpcr2 = 0U;
   4719          
   4720            /* Disable the Channel 2: Reset the CC2E Bit */
   4721            TIMx->CCER &= ~TIM_CCER_CC2E;
   4722          
   4723            /* Get the TIMx CCER register value */
   4724            tmpccer = TIMx->CCER;
   4725            /* Get the TIMx CR2 register value */
   4726            tmpcr2 =  TIMx->CR2;
   4727          
   4728            /* Get the TIMx CCMR1 register value */
   4729            tmpccmrx = TIMx->CCMR1;
   4730          
   4731            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4732            tmpccmrx &= ~TIM_CCMR1_OC2M;
   4733            tmpccmrx &= ~TIM_CCMR1_CC2S;
   4734          
   4735            /* Select the Output Compare Mode */
   4736            tmpccmrx |= (OC_Config->OCMode << 8U);
   4737          
   4738            /* Reset the Output Polarity level */
   4739            tmpccer &= ~TIM_CCER_CC2P;
   4740            /* Set the Output Compare Polarity */
   4741            tmpccer |= (OC_Config->OCPolarity << 4U);
   4742          
   4743            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_2))
   4744            {
   4745              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4746          
   4747              /* Reset the Output N Polarity level */
   4748              tmpccer &= ~TIM_CCER_CC2NP;
   4749              /* Set the Output N Polarity */
   4750              tmpccer |= (OC_Config->OCNPolarity << 4U);
   4751              /* Reset the Output N State */
   4752              tmpccer &= ~TIM_CCER_CC2NE;
   4753          
   4754            }
   4755          
   4756            if(IS_TIM_BREAK_INSTANCE(TIMx))
   4757            {
   4758              /* Check parameters */
   4759              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4760              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4761          
   4762              /* Reset the Output Compare and Output Compare N IDLE State */
   4763              tmpcr2 &= ~TIM_CR2_OIS2;
   4764              tmpcr2 &= ~TIM_CR2_OIS2N;
   4765              /* Set the Output Idle state */
   4766              tmpcr2 |= (OC_Config->OCIdleState << 2);
   4767              /* Set the Output N Idle state */
   4768              tmpcr2 |= (OC_Config->OCNIdleState << 2);
   4769            }
   4770          
   4771            /* Write to TIMx CR2 */
   4772            TIMx->CR2 = tmpcr2;
   4773          
   4774            /* Write to TIMx CCMR1 */
   4775            TIMx->CCMR1 = tmpccmrx;
   4776          
   4777            /* Set the Capture Compare Register value */
   4778            TIMx->CCR2 = OC_Config->Pulse;
   4779          
   4780            /* Write to TIMx CCER */
   4781            TIMx->CCER = tmpccer;
   4782          }
   4783          
   4784          /**
   4785            * @brief  Time Ouput Compare 3 configuration
   4786            * @param  TIMx  to select the TIM peripheral
   4787            * @param  OC_Config : The ouput configuration structure
   4788            * @retval None
   4789            */
   4790          static void TIM_OC3_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4791          {
   4792            uint32_t tmpccmrx = 0U;
   4793            uint32_t tmpccer = 0U;
   4794            uint32_t tmpcr2 = 0U;
   4795          
   4796            /* Disable the Channel 3: Reset the CC2E Bit */
   4797            TIMx->CCER &= ~TIM_CCER_CC3E;
   4798          
   4799            /* Get the TIMx CCER register value */
   4800            tmpccer = TIMx->CCER;
   4801            /* Get the TIMx CR2 register value */
   4802            tmpcr2 =  TIMx->CR2;
   4803          
   4804            /* Get the TIMx CCMR2 register value */
   4805            tmpccmrx = TIMx->CCMR2;
   4806          
   4807            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4808            tmpccmrx &= ~TIM_CCMR2_OC3M;
   4809            tmpccmrx &= ~TIM_CCMR2_CC3S;
   4810            /* Select the Output Compare Mode */
   4811            tmpccmrx |= OC_Config->OCMode;
   4812          
   4813            /* Reset the Output Polarity level */
   4814            tmpccer &= ~TIM_CCER_CC3P;
   4815            /* Set the Output Compare Polarity */
   4816            tmpccer |= (OC_Config->OCPolarity << 8U);
   4817          
   4818            if(IS_TIM_CCXN_INSTANCE(TIMx, TIM_CHANNEL_3))
   4819            {
   4820              assert_param(IS_TIM_OCN_POLARITY(OC_Config->OCNPolarity));
   4821          
   4822              /* Reset the Output N Polarity level */
   4823              tmpccer &= ~TIM_CCER_CC3NP;
   4824              /* Set the Output N Polarity */
   4825              tmpccer |= (OC_Config->OCNPolarity << 8U);
   4826              /* Reset the Output N State */
   4827              tmpccer &= ~TIM_CCER_CC3NE;
   4828            }
   4829          
   4830            if(IS_TIM_BREAK_INSTANCE(TIMx))
   4831            {
   4832              /* Check parameters */
   4833              assert_param(IS_TIM_OCNIDLE_STATE(OC_Config->OCNIdleState));
   4834              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4835          
   4836              /* Reset the Output Compare and Output Compare N IDLE State */
   4837              tmpcr2 &= ~TIM_CR2_OIS3;
   4838              tmpcr2 &= ~TIM_CR2_OIS3N;
   4839              /* Set the Output Idle state */
   4840              tmpcr2 |= (OC_Config->OCIdleState << 4U);
   4841              /* Set the Output N Idle state */
   4842              tmpcr2 |= (OC_Config->OCNIdleState << 4U);
   4843            }
   4844          
   4845            /* Write to TIMx CR2 */
   4846            TIMx->CR2 = tmpcr2;
   4847          
   4848            /* Write to TIMx CCMR2 */
   4849            TIMx->CCMR2 = tmpccmrx;
   4850          
   4851            /* Set the Capture Compare Register value */
   4852            TIMx->CCR3 = OC_Config->Pulse;
   4853          
   4854            /* Write to TIMx CCER */
   4855            TIMx->CCER = tmpccer;
   4856          }
   4857          
   4858          /**
   4859            * @brief  Time Ouput Compare 4 configuration
   4860            * @param  TIMx  to select the TIM peripheral
   4861            * @param  OC_Config : The ouput configuration structure
   4862            * @retval None
   4863            */
   4864          static void TIM_OC4_SetConfig(TIM_TypeDef *TIMx, TIM_OC_InitTypeDef *OC_Config)
   4865          {
   4866            uint32_t tmpccmrx = 0U;
   4867            uint32_t tmpccer = 0U;
   4868            uint32_t tmpcr2 = 0U;
   4869          
   4870            /* Disable the Channel 4: Reset the CC4E Bit */
   4871            TIMx->CCER &= ~TIM_CCER_CC4E;
   4872          
   4873            /* Get the TIMx CCER register value */
   4874            tmpccer = TIMx->CCER;
   4875            /* Get the TIMx CR2 register value */
   4876            tmpcr2 =  TIMx->CR2;
   4877          
   4878            /* Get the TIMx CCMR2 register value */
   4879            tmpccmrx = TIMx->CCMR2;
   4880          
   4881            /* Reset the Output Compare mode and Capture/Compare selection Bits */
   4882            tmpccmrx &= ~TIM_CCMR2_OC4M;
   4883            tmpccmrx &= ~TIM_CCMR2_CC4S;
   4884          
   4885            /* Select the Output Compare Mode */
   4886            tmpccmrx |= (OC_Config->OCMode << 8U);
   4887          
   4888            /* Reset the Output Polarity level */
   4889            tmpccer &= ~TIM_CCER_CC4P;
   4890            /* Set the Output Compare Polarity */
   4891            tmpccer |= (OC_Config->OCPolarity << 12U);
   4892          
   4893            if(IS_TIM_BREAK_INSTANCE(TIMx))
   4894            {
   4895              assert_param(IS_TIM_OCIDLE_STATE(OC_Config->OCIdleState));
   4896          
   4897             /* Reset the Output Compare IDLE State */
   4898              tmpcr2 &= ~TIM_CR2_OIS4;
   4899              /* Set the Output Idle state */
   4900              tmpcr2 |= (OC_Config->OCIdleState << 6);
   4901            }
   4902          
   4903            /* Write to TIMx CR2 */
   4904            TIMx->CR2 = tmpcr2;
   4905          
   4906            /* Write to TIMx CCMR2 */
   4907            TIMx->CCMR2 = tmpccmrx;
   4908          
   4909            /* Set the Capture Compare Register value */
   4910            TIMx->CCR4 = OC_Config->Pulse;
   4911          
   4912            /* Write to TIMx CCER */
   4913            TIMx->CCER = tmpccer;
   4914          }
   4915          
   4916          
   4917          /**
   4918            * @brief  Time Slave configuration
   4919            * @param  htim: pointer to a TIM_HandleTypeDef structure that contains
   4920            *                the configuration information for TIM module.
   4921            * @param  sSlaveConfig: The slave configuration structure
   4922            * @retval None
   4923            */
   4924          static void TIM_SlaveTimer_SetConfig(TIM_HandleTypeDef *htim,
   4925                                        TIM_SlaveConfigTypeDef * sSlaveConfig)
   4926          {
   4927            uint32_t tmpsmcr = 0U;
   4928            uint32_t tmpccmr1 = 0U;
   4929            uint32_t tmpccer = 0U;
   4930          
   4931            /* Get the TIMx SMCR register value */
   4932            tmpsmcr = htim->Instance->SMCR;
   4933          
   4934            /* Reset the Trigger Selection Bits */
   4935            tmpsmcr &= ~TIM_SMCR_TS;
   4936            /* Set the Input Trigger source */
   4937            tmpsmcr |= sSlaveConfig->InputTrigger;
   4938          
   4939            /* Reset the slave mode Bits */
   4940            tmpsmcr &= ~TIM_SMCR_SMS;
   4941            /* Set the slave mode */
   4942            tmpsmcr |= sSlaveConfig->SlaveMode;
   4943          
   4944            /* Write to TIMx SMCR */
   4945            htim->Instance->SMCR = tmpsmcr;
   4946          
   4947            /* Configure the trigger prescaler, filter, and polarity */
   4948            switch (sSlaveConfig->InputTrigger)
   4949            {
   4950            case TIM_TS_ETRF:
   4951              {
   4952                /* Check the parameters */
   4953                assert_param(IS_TIM_CLOCKSOURCE_ETRMODE1_INSTANCE(htim->Instance));
   4954                assert_param(IS_TIM_TRIGGERPRESCALER(sSlaveConfig->TriggerPrescaler));
   4955                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4956                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4957                /* Configure the ETR Trigger source */
   4958                TIM_ETR_SetConfig(htim->Instance,
   4959                                  sSlaveConfig->TriggerPrescaler,
   4960                                  sSlaveConfig->TriggerPolarity,
   4961                                  sSlaveConfig->TriggerFilter);
   4962              }
   4963              break;
   4964          
   4965            case TIM_TS_TI1F_ED:
   4966              {
   4967                /* Check the parameters */
   4968                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4969                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4970          
   4971                /* Disable the Channel 1: Reset the CC1E Bit */
   4972                tmpccer = htim->Instance->CCER;
   4973                htim->Instance->CCER &= ~TIM_CCER_CC1E;
   4974                tmpccmr1 = htim->Instance->CCMR1;
   4975          
   4976                /* Set the filter */
   4977                tmpccmr1 &= ~TIM_CCMR1_IC1F;
   4978                tmpccmr1 |= ((sSlaveConfig->TriggerFilter) << 4U);
   4979          
   4980                /* Write to TIMx CCMR1 and CCER registers */
   4981                htim->Instance->CCMR1 = tmpccmr1;
   4982                htim->Instance->CCER = tmpccer;
   4983          
   4984              }
   4985              break;
   4986          
   4987            case TIM_TS_TI1FP1:
   4988              {
   4989                /* Check the parameters */
   4990                assert_param(IS_TIM_CC1_INSTANCE(htim->Instance));
   4991                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   4992                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   4993          
   4994                /* Configure TI1 Filter and Polarity */
   4995                TIM_TI1_ConfigInputStage(htim->Instance,
   4996                                         sSlaveConfig->TriggerPolarity,
   4997                                         sSlaveConfig->TriggerFilter);
   4998              }
   4999              break;
   5000          
   5001            case TIM_TS_TI2FP2:
   5002              {
   5003                /* Check the parameters */
   5004                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5005                assert_param(IS_TIM_TRIGGERPOLARITY(sSlaveConfig->TriggerPolarity));
   5006                assert_param(IS_TIM_TRIGGERFILTER(sSlaveConfig->TriggerFilter));
   5007          
   5008                /* Configure TI2 Filter and Polarity */
   5009                TIM_TI2_ConfigInputStage(htim->Instance,
   5010                                          sSlaveConfig->TriggerPolarity,
   5011                                          sSlaveConfig->TriggerFilter);
   5012              }
   5013              break;
   5014          
   5015            case TIM_TS_ITR0:
   5016              {
   5017                /* Check the parameter */
   5018                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5019              }
   5020              break;
   5021          
   5022            case TIM_TS_ITR1:
   5023              {
   5024                /* Check the parameter */
   5025                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5026              }
   5027              break;
   5028          
   5029            case TIM_TS_ITR2:
   5030              {
   5031                /* Check the parameter */
   5032                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5033              }
   5034              break;
   5035          
   5036            case TIM_TS_ITR3:
   5037              {
   5038                /* Check the parameter */
   5039                assert_param(IS_TIM_CC2_INSTANCE(htim->Instance));
   5040              }
   5041              break;
   5042          
   5043            default:
   5044              break;
   5045            }
   5046          }
   5047          
   5048          /**
   5049            * @brief  Configure the TI1 as Input.
   5050            * @param  TIMx  to select the TIM peripheral.
   5051            * @param  TIM_ICPolarity : The Input Polarity.
   5052            *          This parameter can be one of the following values:
   5053            *            @arg TIM_ICPOLARITY_RISING
   5054            *            @arg TIM_ICPOLARITY_FALLING
   5055            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5056            * @param  TIM_ICSelection : specifies the input to be used.
   5057            *          This parameter can be one of the following values:
   5058            *            @arg TIM_ICSELECTION_DIRECTTI:    TIM Input 1 is selected to be connected to IC1.
   5059            *            @arg TIM_ICSELECTION_INDIRECTTI:  TIM Input 1 is selected to be connected to IC2.
   5060            *            @arg TIM_ICSELECTION_TRC:         TIM Input 1 is selected to be connected to TRC.
   5061            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5062            *          This parameter must be a value between 0x00 and 0x0F.
   5063            * @retval None
   5064            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI2FP1 
   5065            *       (on channel2 path) is used as the input signal. Therefore CCMR1 must be 
   5066            *        protected against un-initialized filter and polarity values.
   5067            */
   5068          void TIM_TI1_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5069                                 uint32_t TIM_ICFilter)
   5070          {
   5071            uint32_t tmpccmr1 = 0U;
   5072            uint32_t tmpccer = 0U;
   5073          
   5074            /* Disable the Channel 1: Reset the CC1E Bit */
   5075            TIMx->CCER &= ~TIM_CCER_CC1E;
   5076            tmpccmr1 = TIMx->CCMR1;
   5077            tmpccer = TIMx->CCER;
   5078          
   5079            /* Select the Input */
   5080            if(IS_TIM_CC2_INSTANCE(TIMx) != RESET)
   5081            {
   5082              tmpccmr1 &= ~TIM_CCMR1_CC1S;
   5083              tmpccmr1 |= TIM_ICSelection;
   5084            }
   5085            else
   5086            {
   5087              tmpccmr1 |= TIM_CCMR1_CC1S_0;
   5088            }
   5089          
   5090            /* Set the filter */
   5091            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5092            tmpccmr1 |= ((TIM_ICFilter << 4U) & TIM_CCMR1_IC1F);
   5093          
   5094            /* Select the Polarity and set the CC1E Bit */
   5095            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5096            tmpccer |= (TIM_ICPolarity & (TIM_CCER_CC1P | TIM_CCER_CC1NP));
   5097          
   5098            /* Write to TIMx CCMR1 and CCER registers */
   5099            TIMx->CCMR1 = tmpccmr1;
   5100            TIMx->CCER = tmpccer;
   5101          }
   5102          
   5103          /**
   5104            * @brief  Configure the Polarity and Filter for TI1.
   5105            * @param  TIMx  to select the TIM peripheral.
   5106            * @param  TIM_ICPolarity : The Input Polarity.
   5107            *          This parameter can be one of the following values:
   5108            *            @arg TIM_ICPOLARITY_RISING   
   5109            *            @arg TIM_ICPOLARITY_FALLING
   5110            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5111            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5112            *          This parameter must be a value between 0x00 and 0x0F.
   5113            * @retval None
   5114            */
   5115          static void TIM_TI1_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5116          {
   5117            uint32_t tmpccmr1 = 0U;
   5118            uint32_t tmpccer = 0U;
   5119          
   5120            /* Disable the Channel 1: Reset the CC1E Bit */
   5121            tmpccer = TIMx->CCER;
   5122            TIMx->CCER &= ~TIM_CCER_CC1E;
   5123            tmpccmr1 = TIMx->CCMR1;
   5124          
   5125            /* Set the filter */
   5126            tmpccmr1 &= ~TIM_CCMR1_IC1F;
   5127            tmpccmr1 |= (TIM_ICFilter << 4U);
   5128          
   5129            /* Select the Polarity and set the CC1E Bit */
   5130            tmpccer &= ~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
   5131            tmpccer |= TIM_ICPolarity;
   5132          
   5133            /* Write to TIMx CCMR1 and CCER registers */
   5134            TIMx->CCMR1 = tmpccmr1;
   5135            TIMx->CCER = tmpccer;
   5136          }
   5137          
   5138          /**
   5139            * @brief  Configure the TI2 as Input.
   5140            * @param  TIMx  to select the TIM peripheral
   5141            * @param  TIM_ICPolarity : The Input Polarity.
   5142            *          This parameter can be one of the following values:
   5143            *            @arg TIM_ICPOLARITY_RISING   
   5144            *            @arg TIM_ICPOLARITY_FALLING
   5145            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5146            * @param  TIM_ICSelection : specifies the input to be used.
   5147            *          This parameter can be one of the following values:
   5148            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 2 is selected to be connected to IC2.
   5149            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 2 is selected to be connected to IC1.
   5150            *            @arg TIM_ICSELECTION_TRC:        TIM Input 2 is selected to be connected to TRC.
   5151            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5152            *          This parameter must be a value between 0x00 and 0x0F.
   5153            * @retval None
   5154            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI1FP2 
   5155            *       (on channel1 path) is used as the input signal. Therefore CCMR1 must be 
   5156            *        protected against un-initialized filter and polarity values.
   5157            */
   5158          static void TIM_TI2_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5159                                 uint32_t TIM_ICFilter)
   5160          {
   5161            uint32_t tmpccmr1 = 0U;
   5162            uint32_t tmpccer = 0U;
   5163          
   5164            /* Disable the Channel 2: Reset the CC2E Bit */
   5165            TIMx->CCER &= ~TIM_CCER_CC2E;
   5166            tmpccmr1 = TIMx->CCMR1;
   5167            tmpccer = TIMx->CCER;
   5168          
   5169            /* Select the Input */
   5170            tmpccmr1 &= ~TIM_CCMR1_CC2S;
   5171            tmpccmr1 |= (TIM_ICSelection << 8U);
   5172          
   5173            /* Set the filter */
   5174            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5175            tmpccmr1 |= ((TIM_ICFilter << 12U) & TIM_CCMR1_IC2F);
   5176          
   5177            /* Select the Polarity and set the CC2E Bit */
   5178            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5179            tmpccer |= ((TIM_ICPolarity << 4U) & (TIM_CCER_CC2P | TIM_CCER_CC2NP));
   5180          
   5181            /* Write to TIMx CCMR1 and CCER registers */
   5182            TIMx->CCMR1 = tmpccmr1 ;
   5183            TIMx->CCER = tmpccer;
   5184          }
   5185          
   5186          /**
   5187            * @brief  Configure the Polarity and Filter for TI2.
   5188            * @param  TIMx  to select the TIM peripheral.
   5189            * @param  TIM_ICPolarity : The Input Polarity.
   5190            *          This parameter can be one of the following values:
   5191            *            @arg TIM_ICPOLARITY_RISING  
   5192            *            @arg TIM_ICPOLARITY_FALLING
   5193            *            @arg TIM_ICPOLARITY_BOTHEDGE
   5194            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5195            *          This parameter must be a value between 0x00 and 0x0F.
   5196            * @retval None
   5197            */
   5198          static void TIM_TI2_ConfigInputStage(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICFilter)
   5199          {
   5200            uint32_t tmpccmr1 = 0U;
   5201            uint32_t tmpccer = 0U;
   5202          
   5203            /* Disable the Channel 2: Reset the CC2E Bit */
   5204            TIMx->CCER &= ~TIM_CCER_CC2E;
   5205            tmpccmr1 = TIMx->CCMR1;
   5206            tmpccer = TIMx->CCER;
   5207          
   5208            /* Set the filter */
   5209            tmpccmr1 &= ~TIM_CCMR1_IC2F;
   5210            tmpccmr1 |= (TIM_ICFilter << 12U);
   5211          
   5212            /* Select the Polarity and set the CC2E Bit */
   5213            tmpccer &= ~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
   5214            tmpccer |= (TIM_ICPolarity << 4U);
   5215          
   5216            /* Write to TIMx CCMR1 and CCER registers */
   5217            TIMx->CCMR1 = tmpccmr1 ;
   5218            TIMx->CCER = tmpccer;
   5219          }
   5220          
   5221          /**
   5222            * @brief  Configure the TI3 as Input.
   5223            * @param  TIMx  to select the TIM peripheral
   5224            * @param  TIM_ICPolarity : The Input Polarity.
   5225            *          This parameter can be one of the following values:
   5226            *            @arg TIM_ICPOLARITY_RISING  
   5227            *            @arg TIM_ICPOLARITY_FALLING
   5228            * @param  TIM_ICSelection : specifies the input to be used.
   5229            *          This parameter can be one of the following values:
   5230            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 3 is selected to be connected to IC3.
   5231            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 3 is selected to be connected to IC4.
   5232            *            @arg TIM_ICSELECTION_TRC:        TIM Input 3 is selected to be connected to TRC.
   5233            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5234            *          This parameter must be a value between 0x00 and 0x0F.
   5235            * @retval None
   5236            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI3FP4 
   5237            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5238            *        protected against un-initialized filter and polarity values.
   5239            */
   5240          static void TIM_TI3_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5241                                 uint32_t TIM_ICFilter)
   5242          {
   5243            uint32_t tmpccmr2 = 0U;
   5244            uint32_t tmpccer = 0U;
   5245          
   5246            /* Disable the Channel 3: Reset the CC3E Bit */
   5247            TIMx->CCER &= ~TIM_CCER_CC3E;
   5248            tmpccmr2 = TIMx->CCMR2;
   5249            tmpccer = TIMx->CCER;
   5250          
   5251            /* Select the Input */
   5252            tmpccmr2 &= ~TIM_CCMR2_CC3S;
   5253            tmpccmr2 |= TIM_ICSelection;
   5254          
   5255            /* Set the filter */
   5256            tmpccmr2 &= ~TIM_CCMR2_IC3F;
   5257            tmpccmr2 |= ((TIM_ICFilter << 4U) & TIM_CCMR2_IC3F);
   5258          
   5259            /* Select the Polarity and set the CC3E Bit */
   5260            tmpccer &= ~(TIM_CCER_CC3P);
   5261            tmpccer |= ((TIM_ICPolarity << 8U) & (TIM_CCER_CC3P));
   5262          
   5263            /* Write to TIMx CCMR2 and CCER registers */
   5264            TIMx->CCMR2 = tmpccmr2;
   5265            TIMx->CCER = tmpccer;
   5266          }
   5267          
   5268          /**
   5269            * @brief  Configure the TI4 as Input.
   5270            * @param  TIMx to select the TIM peripheral
   5271            * @param  TIM_ICPolarity : The Input Polarity.
   5272            *          This parameter can be one of the following values:
   5273            *            @arg TIM_ICPOLARITY_RISING  
   5274            *            @arg TIM_ICPOLARITY_FALLING
   5275            * @param  TIM_ICSelection : specifies the input to be used.
   5276            *          This parameter can be one of the following values:
   5277            *            @arg TIM_ICSELECTION_DIRECTTI:   TIM Input 4 is selected to be connected to IC4.
   5278            *            @arg TIM_ICSELECTION_INDIRECTTI: TIM Input 4 is selected to be connected to IC3.
   5279            *            @arg TIM_ICSELECTION_TRC:        TIM Input 4 is selected to be connected to TRC.
   5280            * @param  TIM_ICFilter : Specifies the Input Capture Filter.
   5281            *          This parameter must be a value between 0x00 and 0x0F.
   5282            * @note TIM_ICFilter and TIM_ICPolarity are not used in INDIRECT mode as TI4FP3 
   5283            *       (on channel1 path) is used as the input signal. Therefore CCMR2 must be 
   5284            *        protected against un-initialized filter and polarity values.
   5285            * @retval None
   5286            */
   5287          static void TIM_TI4_SetConfig(TIM_TypeDef *TIMx, uint32_t TIM_ICPolarity, uint32_t TIM_ICSelection,
   5288                                 uint32_t TIM_ICFilter)
   5289          {
   5290            uint32_t tmpccmr2 = 0U;
   5291            uint32_t tmpccer = 0U;
   5292          
   5293            /* Disable the Channel 4: Reset the CC4E Bit */
   5294            TIMx->CCER &= ~TIM_CCER_CC4E;
   5295            tmpccmr2 = TIMx->CCMR2;
   5296            tmpccer = TIMx->CCER;
   5297          
   5298            /* Select the Input */
   5299            tmpccmr2 &= ~TIM_CCMR2_CC4S;
   5300            tmpccmr2 |= (TIM_ICSelection << 8U);
   5301          
   5302            /* Set the filter */
   5303            tmpccmr2 &= ~TIM_CCMR2_IC4F;
   5304            tmpccmr2 |= ((TIM_ICFilter << 12U) & TIM_CCMR2_IC4F);
   5305          
   5306            /* Select the Polarity and set the CC4E Bit */
   5307            tmpccer &= ~TIM_CCER_CC4P;
   5308            tmpccer |= ((TIM_ICPolarity << 12U) & TIM_CCER_CC4P);
   5309          
   5310            /* Write to TIMx CCMR2 and CCER registers */
   5311            TIMx->CCMR2 = tmpccmr2;
   5312            TIMx->CCER = tmpccer ;
   5313          }
   5314          
   5315          /**
   5316            * @brief  Selects the Input Trigger source
   5317            * @param  TIMx  to select the TIM peripheral
   5318            * @param  InputTriggerSource : The Input Trigger source.
   5319            *          This parameter can be one of the following values:
   5320            *            @arg TIM_TS_ITR0 : Internal Trigger 0
   5321            *            @arg TIM_TS_ITR1 : Internal Trigger 1
   5322            *            @arg TIM_TS_ITR2 : Internal Trigger 2
   5323            *            @arg TIM_TS_ITR3 : Internal Trigger 3
   5324            *            @arg TIM_TS_TI1F_ED : TI1 Edge Detector
   5325            *            @arg TIM_TS_TI1FP1 : Filtered Timer Input 1
   5326            *            @arg TIM_TS_TI2FP2 : Filtered Timer Input 2
   5327            *            @arg TIM_TS_ETRF : External Trigger input
   5328            * @retval None
   5329            */
   5330          static void TIM_ITRx_SetConfig(TIM_TypeDef *TIMx, uint16_t InputTriggerSource)
   5331          {
   5332            uint32_t tmpsmcr = 0U;
   5333          
   5334             /* Get the TIMx SMCR register value */
   5335             tmpsmcr = TIMx->SMCR;
   5336             /* Reset the TS Bits */
   5337             tmpsmcr &= ~TIM_SMCR_TS;
   5338             /* Set the Input Trigger source and the slave mode*/
   5339             tmpsmcr |= InputTriggerSource | TIM_SLAVEMODE_EXTERNAL1;
   5340             /* Write to TIMx SMCR */
   5341             TIMx->SMCR = tmpsmcr;
   5342          }
   5343          /**
   5344            * @brief  Configures the TIMx External Trigger (ETR).
   5345            * @param  TIMx  to select the TIM peripheral
   5346            * @param  TIM_ExtTRGPrescaler : The external Trigger Prescaler.
   5347            *          This parameter can be one of the following values:
   5348            *            @arg TIM_ETRPRESCALER_DIV1: ETRP Prescaler OFF.
   5349            *            @arg TIM_ETRPRESCALER_DIV2: ETRP frequency divided by 2.
   5350            *            @arg TIM_ETRPRESCALER_DIV4: ETRP frequency divided by 4.
   5351            *            @arg TIM_ETRPRESCALER_DIV8: ETRP frequency divided by 8.
   5352            * @param  TIM_ExtTRGPolarity : The external Trigger Polarity.
   5353            *          This parameter can be one of the following values:
   5354            *            @arg TIM_ETRPOLARITY_INVERTED: active low or falling edge active.
   5355            *            @arg TIM_ETRPOLARITY_NONINVERTED: active high or rising edge active.
   5356            * @param  ExtTRGFilter : External Trigger Filter.
   5357            *          This parameter must be a value between 0x00 and 0x0F
   5358            * @retval None
   5359            */
   5360          static void TIM_ETR_SetConfig(TIM_TypeDef* TIMx, uint32_t TIM_ExtTRGPrescaler,
   5361                                 uint32_t TIM_ExtTRGPolarity, uint32_t ExtTRGFilter)
   5362          {
   5363            uint32_t tmpsmcr = 0U;
   5364          
   5365            tmpsmcr = TIMx->SMCR;
   5366          
   5367            /* Reset the ETR Bits */
   5368            tmpsmcr &= ~(TIM_SMCR_ETF | TIM_SMCR_ETPS | TIM_SMCR_ECE | TIM_SMCR_ETP);
   5369          
   5370            /* Set the Prescaler, the Filter value and the Polarity */
   5371            tmpsmcr |= (uint32_t)(TIM_ExtTRGPrescaler | (TIM_ExtTRGPolarity | (ExtTRGFilter << 8U)));
   5372          
   5373            /* Write to TIMx SMCR */
   5374            TIMx->SMCR = tmpsmcr;
   5375          }
   5376          
   5377          /**
   5378            * @brief  Enables or disables the TIM Capture Compare Channel x.
   5379            * @param  TIMx  to select the TIM peripheral
   5380            * @param  Channel : specifies the TIM Channel
   5381            *          This parameter can be one of the following values:
   5382            *            @arg TIM_CHANNEL_1: TIM Channel 1
   5383            *            @arg TIM_CHANNEL_2: TIM Channel 2
   5384            *            @arg TIM_CHANNEL_3: TIM Channel 3
   5385            *            @arg TIM_CHANNEL_4: TIM Channel 4
   5386            * @param  ChannelState : specifies the TIM Channel CCxE bit new state.
   5387            *          This parameter can be: TIM_CCx_ENABLE or TIM_CCx_Disable.
   5388            * @retval None
   5389            */
   5390          void TIM_CCxChannelCmd(TIM_TypeDef* TIMx, uint32_t Channel, uint32_t ChannelState)
   5391          {
   5392            uint32_t tmp = 0U;
   5393          
   5394            /* Check the parameters */
   5395            assert_param(IS_TIM_CC1_INSTANCE(TIMx));
   5396            assert_param(IS_TIM_CHANNELS(Channel));
   5397          
   5398            tmp = TIM_CCER_CC1E << Channel;
   5399          
   5400            /* Reset the CCxE Bit */
   5401            TIMx->CCER &= ~tmp;
   5402          
   5403            /* Set or reset the CCxE Bit */
   5404            TIMx->CCER |=  (uint32_t)(ChannelState << Channel);
   5405          }
   5406          
   5407          /**
   5408            * @}
   5409            */
   5410          
   5411          #endif /* HAL_TIM_MODULE_ENABLED */
   5412          /**
   5413            * @}
   5414            */
   5415          
   5416          /**
   5417            * @}
   5418            */
   5419          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   HAL_TIM_Base_DeInit
         8   -> HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_GetState
       8   HAL_TIM_Base_Init
         8   -> HAL_TIM_Base_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_Base_MspDeInit
       0   HAL_TIM_Base_MspInit
       0   HAL_TIM_Base_Start
      16   HAL_TIM_Base_Start_DMA
        16   -> HAL_DMA_Start_IT
       0   HAL_TIM_Base_Start_IT
       0   HAL_TIM_Base_Stop
       0   HAL_TIM_Base_Stop_DMA
       0   HAL_TIM_Base_Stop_IT
      16   HAL_TIM_ConfigClockSource
        16   -> TIM_ETR_SetConfig
        16   -> TIM_ITRx_SetConfig
        16   -> TIM_TI1_ConfigInputStage
        16   -> TIM_TI2_ConfigInputStage
      24   HAL_TIM_ConfigOCrefClear
        24   -> TIM_ETR_SetConfig
       4   HAL_TIM_ConfigTI1Input
      24   HAL_TIM_DMABurst_ReadStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_ReadStop
        16   -> HAL_DMA_Abort
      24   HAL_TIM_DMABurst_WriteStart
        24   -> HAL_DMA_Start_IT
      16   HAL_TIM_DMABurst_WriteStop
        16   -> HAL_DMA_Abort
       8   HAL_TIM_Encoder_DeInit
         8   -> HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_GetState
      24   HAL_TIM_Encoder_Init
        24   -> HAL_TIM_Encoder_MspInit
        24   -> TIM_Base_SetConfig
       0   HAL_TIM_Encoder_MspDeInit
       0   HAL_TIM_Encoder_MspInit
      16   HAL_TIM_Encoder_Start
        16   -> TIM_CCxChannelCmd
      32   HAL_TIM_Encoder_Start_DMA
        32   -> HAL_DMA_Start_IT
        32   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_Encoder_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_ErrorCallback
       0   HAL_TIM_GenerateEvent
       0   HAL_TIM_IC_CaptureCallback
      16   HAL_TIM_IC_ConfigChannel
        16   -> TIM_TI1_SetConfig
        16   -> TIM_TI2_SetConfig
        16   -> TIM_TI3_SetConfig
        16   -> TIM_TI4_SetConfig
       8   HAL_TIM_IC_DeInit
         8   -> HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_GetState
       8   HAL_TIM_IC_Init
         8   -> HAL_TIM_IC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_IC_MspDeInit
       0   HAL_TIM_IC_MspInit
      16   HAL_TIM_IC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_IC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_IC_Stop_IT
        16   -> TIM_CCxChannelCmd
       8   HAL_TIM_IRQHandler
         8   -> HAL_TIMEx_BreakCallback
         8   -> HAL_TIMEx_CommutationCallback
         8   -> HAL_TIM_IC_CaptureCallback
         8   -> HAL_TIM_OC_DelayElapsedCallback
         8   -> HAL_TIM_PWM_PulseFinishedCallback
         8   -> HAL_TIM_PeriodElapsedCallback
         8   -> HAL_TIM_TriggerCallback
      16   HAL_TIM_OC_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_OC_DeInit
         8   -> HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_DelayElapsedCallback
       0   HAL_TIM_OC_GetState
       8   HAL_TIM_OC_Init
         8   -> HAL_TIM_OC_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_OC_MspDeInit
       0   HAL_TIM_OC_MspInit
      16   HAL_TIM_OC_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_OC_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OC_Stop_IT
        16   -> TIM_CCxChannelCmd
      48   HAL_TIM_OnePulse_ConfigChannel
        48   -> TIM_OC1_SetConfig
        48   -> TIM_OC2_SetConfig
        48   -> TIM_TI1_SetConfig
        48   -> TIM_TI2_SetConfig
       8   HAL_TIM_OnePulse_DeInit
         8   -> HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_GetState
      16   HAL_TIM_OnePulse_Init
        16   -> HAL_TIM_OnePulse_MspInit
        16   -> TIM_Base_SetConfig
       0   HAL_TIM_OnePulse_MspDeInit
       0   HAL_TIM_OnePulse_MspInit
      16   HAL_TIM_OnePulse_Start
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_OnePulse_Stop_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_ConfigChannel
        16   -> TIM_OC1_SetConfig
        16   -> TIM_OC2_SetConfig
        16   -> TIM_OC3_SetConfig
        16   -> TIM_OC4_SetConfig
       8   HAL_TIM_PWM_DeInit
         8   -> HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_GetState
       8   HAL_TIM_PWM_Init
         8   -> HAL_TIM_PWM_MspInit
         8   -> TIM_Base_SetConfig
       0   HAL_TIM_PWM_MspDeInit
       0   HAL_TIM_PWM_MspInit
       0   HAL_TIM_PWM_PulseFinishedCallback
      16   HAL_TIM_PWM_Start
        16   -> TIM_CCxChannelCmd
      24   HAL_TIM_PWM_Start_DMA
        24   -> HAL_DMA_Start_IT
        24   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Start_IT
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_DMA
        16   -> TIM_CCxChannelCmd
      16   HAL_TIM_PWM_Stop_IT
        16   -> TIM_CCxChannelCmd
       0   HAL_TIM_PeriodElapsedCallback
       0   HAL_TIM_ReadCapturedValue
      16   HAL_TIM_SlaveConfigSynchronization
        16   -> TIM_SlaveTimer_SetConfig
      16   HAL_TIM_SlaveConfigSynchronization_IT
        16   -> TIM_SlaveTimer_SetConfig
       0   HAL_TIM_TriggerCallback
       4   TIM_Base_SetConfig
      12   TIM_CCxChannelCmd
      16   TIM_DMACaptureCplt
        16   -> HAL_TIM_IC_CaptureCallback
      16   TIM_DMADelayPulseCplt
        16   -> HAL_TIM_PWM_PulseFinishedCallback
      16   TIM_DMAError
        16   -> HAL_TIM_ErrorCallback
      16   TIM_DMAPeriodElapsedCplt
        16   -> HAL_TIM_PeriodElapsedCallback
      16   TIM_DMATriggerCplt
        16   -> HAL_TIM_TriggerCallback
      12   TIM_ETR_SetConfig
       4   TIM_ITRx_SetConfig
      20   TIM_OC1_SetConfig
      16   TIM_OC2_SetConfig
      16   TIM_OC3_SetConfig
      16   TIM_OC4_SetConfig
      24   TIM_SlaveTimer_SetConfig
        24   -> TIM_ETR_SetConfig
        24   -> TIM_TI1_ConfigInputStage
        24   -> TIM_TI2_ConfigInputStage
      12   TIM_TI1_ConfigInputStage
      16   TIM_TI1_SetConfig
      12   TIM_TI2_ConfigInputStage
      16   TIM_TI2_SetConfig
      16   TIM_TI3_SetConfig
      16   TIM_TI4_SetConfig


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable16
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable20
       4  ??DataTable21
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
      68  HAL_TIM_Base_DeInit
       6  HAL_TIM_Base_GetState
      56  HAL_TIM_Base_Init
       2  HAL_TIM_Base_MspDeInit
       2  HAL_TIM_Base_MspInit
      30  HAL_TIM_Base_Start
     112  HAL_TIM_Base_Start_DMA
      30  HAL_TIM_Base_Start_IT
      54  HAL_TIM_Base_Stop
      60  HAL_TIM_Base_Stop_DMA
      54  HAL_TIM_Base_Stop_IT
     284  HAL_TIM_ConfigClockSource
     242  HAL_TIM_ConfigOCrefClear
      26  HAL_TIM_ConfigTI1Input
     396  HAL_TIM_DMABurst_ReadStart
     122  HAL_TIM_DMABurst_ReadStop
     396  HAL_TIM_DMABurst_WriteStart
     122  HAL_TIM_DMABurst_WriteStop
      68  HAL_TIM_Encoder_DeInit
       6  HAL_TIM_Encoder_GetState
     190  HAL_TIM_Encoder_Init
       2  HAL_TIM_Encoder_MspDeInit
       2  HAL_TIM_Encoder_MspInit
      78  HAL_TIM_Encoder_Start
     344  HAL_TIM_Encoder_Start_DMA
     126  HAL_TIM_Encoder_Start_IT
     102  HAL_TIM_Encoder_Stop
     152  HAL_TIM_Encoder_Stop_DMA
     152  HAL_TIM_Encoder_Stop_IT
       2  HAL_TIM_ErrorCallback
      46  HAL_TIM_GenerateEvent
       2  HAL_TIM_IC_CaptureCallback
     214  HAL_TIM_IC_ConfigChannel
      68  HAL_TIM_IC_DeInit
       6  HAL_TIM_IC_GetState
      56  HAL_TIM_IC_Init
       2  HAL_TIM_IC_MspDeInit
       2  HAL_TIM_IC_MspInit
      32  HAL_TIM_IC_Start
     290  HAL_TIM_IC_Start_DMA
     108  HAL_TIM_IC_Start_IT
      56  HAL_TIM_IC_Stop
     138  HAL_TIM_IC_Stop_DMA
     132  HAL_TIM_IC_Stop_IT
     374  HAL_TIM_IRQHandler
     108  HAL_TIM_OC_ConfigChannel
      68  HAL_TIM_OC_DeInit
       2  HAL_TIM_OC_DelayElapsedCallback
       6  HAL_TIM_OC_GetState
      56  HAL_TIM_OC_Init
       2  HAL_TIM_OC_MspDeInit
       2  HAL_TIM_OC_MspInit
      54  HAL_TIM_OC_Start
     312  HAL_TIM_OC_Start_DMA
     130  HAL_TIM_OC_Start_IT
     102  HAL_TIM_OC_Stop
     184  HAL_TIM_OC_Stop_DMA
     178  HAL_TIM_OC_Stop_IT
     280  HAL_TIM_OnePulse_ConfigChannel
      68  HAL_TIM_OnePulse_DeInit
       6  HAL_TIM_OnePulse_GetState
      80  HAL_TIM_OnePulse_Init
       2  HAL_TIM_OnePulse_MspDeInit
       2  HAL_TIM_OnePulse_MspInit
      50  HAL_TIM_OnePulse_Start
      76  HAL_TIM_OnePulse_Start_IT
     110  HAL_TIM_OnePulse_Stop
     136  HAL_TIM_OnePulse_Stop_IT
     256  HAL_TIM_PWM_ConfigChannel
      68  HAL_TIM_PWM_DeInit
       6  HAL_TIM_PWM_GetState
      56  HAL_TIM_PWM_Init
       2  HAL_TIM_PWM_MspDeInit
       2  HAL_TIM_PWM_MspInit
       2  HAL_TIM_PWM_PulseFinishedCallback
      54  HAL_TIM_PWM_Start
     312  HAL_TIM_PWM_Start_DMA
     130  HAL_TIM_PWM_Start_IT
     108  HAL_TIM_PWM_Stop
     184  HAL_TIM_PWM_Stop_DMA
     178  HAL_TIM_PWM_Stop_IT
       2  HAL_TIM_PeriodElapsedCallback
      84  HAL_TIM_ReadCapturedValue
      78  HAL_TIM_SlaveConfigSynchronization
      78  HAL_TIM_SlaveConfigSynchronization_IT
       2  HAL_TIM_TriggerCallback
     102  TIM_Base_SetConfig
      28  TIM_CCxChannelCmd
      70  TIM_DMACaptureCplt
      70  TIM_DMADelayPulseCplt
      20  TIM_DMAError
      20  TIM_DMAPeriodElapsedCplt
      20  TIM_DMATriggerCplt
      26  TIM_ETR_SetConfig
      26  TIM_ITRx_SetConfig
      96  TIM_OC1_SetConfig
     110  TIM_OC2_SetConfig
     104  TIM_OC3_SetConfig
      82  TIM_OC4_SetConfig
     178  TIM_SlaveTimer_SetConfig
      40  TIM_TI1_ConfigInputStage
      98  TIM_TI1_SetConfig
      42  TIM_TI2_ConfigInputStage
      66  TIM_TI2_SetConfig
      64  TIM_TI3_SetConfig
      66  TIM_TI4_SetConfig

 
 9'816 bytes in section .text
 
 9'780 bytes of CODE memory (+ 36 bytes shared)

Errors: none
Warnings: none
